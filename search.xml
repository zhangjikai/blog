<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【Java】 JVM 如何保存 Java 对象]]></title>
    <url>%2F2019%2F09%2F08%2F%E3%80%90Java%E3%80%91-JVM-%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98-Java-%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[前言本文主要讲解一下在 JVM 中如何保存 Java 对象以及 Java 对象指针压缩相关的东西。 JVM 体系结构 图片摘自 https://www.artima.com/insidejvm/ed2/jvm2.html 上图是 JVM 规范中定义的体系结构（这个只是定义的规范，实际的 JVM 实现中可能与这个结构会有差异），这里我们主要看下运行时数据区（runtime data areas）的内容，以下摘自 The Java® Virtual Machine Specification Java SE 8 Edition PC register - If that method is not native , the pc register contains the address of the Java Virtual Machine instruction currently being executed. Java stacks - A Java Virtual Machine stack is analogous to the stack of a conventional language such as C: it holds local variables and partial results, and plays a part in method invocation and return. Heap - The heap is the run-time data area from which memory for all class instances and arrays is allocated. Method area - The method area is analogous to the storage area for compiled code of a conventional language or analogous to the “text” segment in an operating system process. It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods used in class and instance initialization and interfaceinitialization. Native method stacks - An implementation of the Java Virtual Machine may use conventional stacks, colloquially called “C stacks,” to support native methods (methods written in a language other than the Java programming language). Native method stacks may also be used by the implementation of an interpreter() for the Java Virtual Machine’sinstruction set in a language such as C。 堆和方法区是所有类共享的，其中堆主要存储对象实体，方法区存储的信息比较多，主要包括下面几类： 类的基本类型信息 类型的全限定名 直接超类的全限定名（除了 Object） 是类还是接口 访问修饰符 该类的常量池 虚拟机会为每个转载的类型维护一个常量池 字段信息 字段名称 字段类型 字段修饰符（public，private，protected，static，final，volatile，transient） 方法信息 方法名 方法的返回值类型或者void 方法的参数数量和类型（按照声明顺序） 方法的修饰符（public，private，protected，static，final，synchronized，natvie，abstract） 如果不是abstract和native方法，还会保存下面的信息 方法的字节码 操作数栈和局部变量区的大小 异常表 类（静态）变量 静态常量和非静态常量的处理方式不同，每个类都会把用到的其他类的静态常量拷贝到自己的常量池中。 指向 ClassLoader 类的引用。 指向 Class 类的引用，对于每个被装载的类型，JVM 都会为其创建一个 java.lang.Classs 类的实例（该实例存在heap中），并且JVM 会以某种方式将该实例和方法区中对应的类型关联起来。 对象如何保存我们知道一个Java对象包含两部分内容，字段和方法，每个对象的字段值都可能不同，但是所用的方法都是一样的，如果每个对象都保存一套方法定义，显然会浪费很多的空间。所以方法定义相关的都放到了方法区，对象只保存自己的实例数据和指向方法定义的指针。下图是对象保存的一种方式，也是 Hotspot 虚拟机采用的方式，对象在堆中只保存实例的数据，同时会有一个指针指向方法区中的一个方法表（和 c++ 中的 Virtual method table 类似）。方法表保存两个部分：指向类数据的指针和执行各个方法的指针。这里将类数据和方法分开存储，是为了更加快速的找到方法。每个类都会对应一个方法表，这种实现方式会稍微浪费一些内存，但是会获得更好的性能。 图片摘自 https://www.artima.com/insidejvm/ed2/jvm6.html 我们知道对象是有继承关系的，如果子类没有覆写父类的方法，那么子类会指向父类的中的方法。 图片摘自 https://www.artima.com/insidejvm/ed2/linkmod12.html HotSpot 内存结构上面主要是 Java 虚拟机规范中定义的规范，每种虚拟机实现的方式可能不太相同，这里我们主要看下 HotSpot 虚拟机的实现，后面的内容都是基于 HotSpot 虚拟机。在 Java8 中，HotSpot VM 移除了永生代（PermGen），添加了元数据空间（Metaspace），元空间不使用虚拟机内存，而是使用本地内存。元空间主要和方法区对应，存储类的元数据和常量池（String常量的实例存在堆中）等信息。 图片摘自 http://java-latte.blogspot.com/2014/03/metaspace-in-java-8.html Ordinary Object Pointer (OOP)在 JVM 中 Java 对象使用 OOP（Ordinary Object Pointer） 来表示，格式如下图所示。 OOP 主要包含两个部分：对象头和实例数据。对象头主要包含四个部分： Mark Word - 会存储对象的多种标记信息，例如哈希值、GC标记、锁等信息 Klass Word - 主要指向类的元数据 32-bit length word - 只有数组对象才有，记录数组的长度 32-bit gap - Java 是 8 字节对齐的（关于为什么要进行内存对齐，可以参考 这篇文章），该字段主要用做对齐填充用 对象头后面就是实例数据，可能是基本数据，也可能是指向其他对象的引用。如果实例数据的大小不是 8 的倍数，那么也会插入一些填充的数据来对齐。对于继承的情况，会先存放父类的实例数据，然后再存放子类的实例数据，如下图所以： Mark word、Klass word 以及对象的引用大小和 JVM 位数相关，32位 JVM 是 4 字节大小，64 位 JVM 是 8 字节大小。对于引用来说，4字节来寻址的话的最多可以表示 232，也就是做大只能支持 4GB 的内存，一般来说4GB 的内存是不大够用的，所以我们常用的是 64 位的 JVM，但是使用 64 位 JVM 带来的一个问题就是引用从 4 个字节变成了 8 个字节，也就是会多占一倍的空间，这样会导致更加频繁的 GC 周期，导致性能变差。 Compressed OOPs我们使用压缩的 OOP 来实现在64位的 JVM 上使用32位大小的引用来寻址，这个方式主要是基于 Java 对象是 8 字节对齐，即后三位全部为 0，也就是在当前的对象引用中后三位实际上是没有用到的。基于上面的逻辑，我们就可以做一下优化，将当前32位值的表示为第 4-35 位的值，也就是实际的值相当于左移了三位，如下图所示。这样我们就有35位来寻址，内存最大就可以支持到 32GB。 图片摘自 https://www.baeldung.com/jvm-compressed-oops 开启了压缩之后，堆中 OOP 里的下列字段会被压缩： 每个对象的 Kclass 字段（Mark不会压缩） 指向其他 OOP 的引用 OOP 数组中的每个元素 下面是 Integer 对象在不同情况下占的内存大小，因为 Java 是 8 字节对齐，所以在64位 VM 上未开启压缩时，Integer 还要加上一个 32bit 填充，即总的大小是 192 bit。 图片摘自 https://www.javacodegeeks.com/2016/05/compressedoops-introduction-compressed-references-java.html 我们可以在启动 Java 程序时使用 -XX:+UseCompressedOops 来开启压缩，Java7之后，如果最大内存小于32G，会自动开启 OOP 压缩。如果想在超过 32G 内存的情况下使用压缩，可以通过指定Java 对象对齐的字节数来实现 -XX:ObjectAlignmentInBytes，该值必须在 8 到 256 之间，并且是 2 的指数倍。假设指定为 16，那么就可以使用 64G 的内存，但是由于对齐造成的内存浪费也会更多。 另外在 Java11 中添加的 ZGC 垃圾回收器必须使用 64 位的指针，所以它不支持压缩的OOP。 参考文章 Inside the Java Virtual Machine Compressed OOPs in the JVM Getting Started with HotSpot and OpenJDK Know Thy Java Object Memory Layout CompressedOops CompressedOops: Introduction to compressed references in Java Metaspace in Java 8]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java 8】Lambda 表达式]]></title>
    <url>%2F2017%2F12%2F08%2F%E3%80%90Java%208%E3%80%91Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义Lambda(λ) 表达式是一种在 被调用的位置 或者 作为参数传递给函数的位置 定义匿名函数对象 的简便方法。下面是关于 Lambda 表达式的几个点： 匿名（Anonymous） - 不像其他普通方法那样具有名字 函数（Function） - Lambda 表达式不像普通方法那样属于某个特定的类，它是独立于类存在的。但是和方法一样，Lambda 表达式有参数列表、函数主体和返回值，还可能有可以抛出的异常列表。 传递（Passed around）- Lambda 表达式可以作为参数传递给方法或者存储在变量中。 简洁（Concise）- 无需像匿名类那样写很多的模板代码。 下面是一个示例12345678910111213@FunctionalInterfaceinterface Calculator &#123; int cal(int a, int b);&#125;public class HelloWorld &#123; public static void main(String[] args) &#123; Calculator c = (a, b) -&gt; a + b; System.out.println(c.cal(1, 2)); c = (a, b) -&gt; a * b; System.out.println(c.cal(1, 2)); &#125;&#125; Lambda 形式Lambda 表达式的基本形式如下所示：1(argument list) -&gt; code 下面是一个例子： 如上所示： Lambda 表达式包含三个部分： 参数列表（A list of parameters） - 上图中为 (Apple a1, Apple a2) 箭头（An arrow） - 把参数列表和 Lambda 主体分隔开 Lambda 主体（The body of the lambda） - 上图中为 a1.getWeight().compareTo(a2.getWeight())，该 Lambda 主体会返回 compareTo 的结果。 Lambda 函数的主体可以是表达式（expression）或者语句（statement），所以 Lambda 函数返回值有下面两种情况： 如果 Lambda 主体为表达式，那么 Lambda 函数的返回值就是表达式的计算值 如果 Lambda 主体为语句，那么 Lambda 返回值就是语句的返回值 关于语句和表达式的区别，可以参考 这篇文章，这里简单说一下：假设有一条语句 int c = a + b;，那么表达式就是指 c = a + b，即不包含 int 和 ;，每个表达式都会有一个计算值（void 也算一种特殊的计算值）。 所以细分一下，Lambda 表达式有两种形式：1(parameters) -&gt; expression 和（使用大括号）1(parameters) -&gt; &#123;statements&#125; 下面是 Lambda 表达式的几个例子： 使用场景 使用示例 boolean 表达式 (List&lt;String&gt; list) -&gt; list.isEmpty() 创建对象 () -&gt; new Apple(10) Consuming from an object (Apple a) -&gt; { System.out.println(a.getWeight()); } Select/extract from an object (String s) -&gt; s.length() 合并两个值 (int a, int b) -&gt; a * b 比较两个对象 (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()) 函数式接口我们可以在函数式接口 （Functional interface）中使用 Lambda 表达式。简单来说，函数式接口就是只定义一个抽象方法的接口（接口中可以包含额外的 default 方法）。例如 Comparator 和 Runnable 都是函数式接口：1234567public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2);&#125;public interface Runnable &#123; void run();&#125; 我们一般在接口定义中加上 @FunctionalInterface 注解来声明该接口是一个函数式接口。例如下面的形式：1234@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; R apply(T t);&#125; 当一个接口通过 FunctionalInterface 被声明为函数式接口时，编译器将会检查接口的合法性，如果接口不合法，会报编译错误。 现在考虑一个问题，Lambda 表达式是如何匹配函数式接口的呢？假设我们有一个如下定义的函数式接口：1234@FunctionalInterfaceinterface Calculator &#123; int cal(int a, int b);&#125; 下面是使用 lambda 表达式以及匿名类来创建 Calculator 对象的示例代码。在下面的代码中对象 c 和 c2 的实现是等价的。12345678910public void demo() &#123; Calculator c = (int a, int b) -&gt; a + b; Calculator c2 = new Calculator() &#123; @Override public int cal(int a, int b) &#123; return a + b; &#125; &#125;;&#125; 从上面的例子中，我们可以看到 Lambda 表达式 是和函数式接口中的 抽象方法 进行匹配的，其中 Lambda 表达式中参数匹配 cal 方法的参数，Lambda body 的内容作为抽象方法的具体实现，Lambda body 的计算值作为方法的返回值。这也是为什么要求函数式接口只能有一个抽象方法的原因。 函数式接口中抽象方法的签名（signature）描述了 Lambda 表达式的签名，因为 Lambda 表达式并没有名字，所以这里的签名只关注三个方面：方法参数 、返回值 以及 异常声明。我们将抽象方法所描述的 Lambda 形式称为函数描述符（function descriptor）。在 Calculator 类中，cal 方法对应的函数描述符为 (int, int) -&gt; int，即接受两个 int 类型作为参数，表达式的计算值为 int 类型。所以下面的 Lambda 表达式都是合法的：123(int a, int b) -&gt; a(int a, int b) -&gt; a + b(int a, int b) -&gt; 0 如果 Lambda 表达式抛出一个可检查异常，那么对应的抽象方法所声明的 throws 语句也要与之匹配。看下面的一个例子：1234567891011121314@FunctionalInterfaceinterface ThrowExceptionInterface &#123; void run(int a, int b);&#125;public class LambdaTest &#123; public void throwException() &#123; // 这里编译时会报 Unhandled Exception：java.io.Exception ThrowExceptionInterface t = (int a, int b) -&gt; &#123; throw new IOException(); &#125;; &#125;&#125; 其实也很好理解，Lambda body 中的内容会作为抽象方法的具体实现，在方法中抛出了异常但是方法声明中却没有相关的异常声明，编译器肯定要报错的。 另外还有一个特殊的 void 兼容规则。如果抽象方法的返回值为 void，即对应的函数描述符为 (T) -&gt; void，那么对于 body 为 语句表达式（statement expression） 的 Lambda 表达式，只要求参数列表匹配即可。看下面的例子：1234567891011121314@FunctionalInterfaceinterface VoidInterface &#123; void run(int a);&#125;public class LambdaTest &#123; public static void voidTest() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 这里 a++ 返回一个 int，但是和 void 兼容 VoidInterface v = (int a) -&gt; a++; // 下面的代码会报错，因为 a-1 不是一个语句表达式 v = (int a) -&gt; a-1; &#125;&#125; 这里说一下语句表达式: The term “statement expression” or “expression statement” refers to expressions that are also allowed to be used as a statement. 语法表达式有下面四类： Assignment expressions Any use of ++ or – Method invocations Object creation expressions 类型检查Lambda 表达式本身并不包含它是实现哪个函数式接口的信息，编译器会根据 Lambda 表达式所处的上下文（context）环境来推断 Lambda 表达式的目标类型（target type），例如对于下面的代码：1Calculator c = (int a, int b) -&gt; a + b; Lambda 表达式会赋值给 Calculator 对象，那么该 Lambda 表达式对应的目标类型就是 Calculator 接口，该接口中的 cal 方法对应的函数描述符为 (int, int) -&gt; int，这个和 (int a, int b) -&gt; a + b 可以匹配，这样就完成了类型检查。下图是一个完整的例子： 类型推断在上面我们提到编译器会根据上下文环境推断出与 Lambda 表达式对应的函数式接口，这意味着编译器同样可以根据接口中抽象方法的函数函数描述符推断出 Lambda 表达式的签名，这样编译器就可以知道 Lambda 表达式的参数类型，这样就可以省略 Lambda 表达式中的参数类型，123Calculator c = (a, b) -&gt; a + b;// 当只有一个参数时，可以省略掉 ()VoidInterface v = a -&gt; a++; Java 8 中的函数式接口在 Java 8 中定义了一些函数式接口，位于 java.util.function 包下，下面是这些接口的总览：12345678910111213141516171819202122232425262728293031323334353637383940414243+--- BiConsumer.java+--- BiFunction.java+--- BinaryOperator.java+--- BiPredicate.java+--- BooleanSupplier.java+--- Consumer.java+--- DoubleBinaryOperator.java+--- DoubleConsumer.java+--- DoubleFunction.java+--- DoublePredicate.java+--- DoubleSupplier.java+--- DoubleToIntFunction.java+--- DoubleToLongFunction.java+--- DoubleUnaryOperator.java+--- Function.java+--- IntBinaryOperator.java+--- IntConsumer.java+--- IntFunction.java+--- IntPredicate.java+--- IntSupplier.java+--- IntToDoubleFunction.java+--- IntToLongFunction.java+--- IntUnaryOperator.java+--- LongBinaryOperator.java+--- LongConsumer.java+--- LongFunction.java+--- LongPredicate.java+--- LongSupplier.java+--- LongToDoubleFunction.java+--- LongToIntFunction.java+--- LongUnaryOperator.java+--- ObjDoubleConsumer.java+--- ObjIntConsumer.java+--- ObjLongConsumer.java+--- Predicate.java+--- Supplier.java+--- ToDoubleBiFunction.java+--- ToDoubleFunction.java+--- ToIntBiFunction.java+--- ToIntFunction.java+--- ToLongBiFunction.java+--- ToLongFunction.java+--- UnaryOperator.java Predicate用来测试对象是否满足某种条件。该接口定义了一个 test 方法，接受一个泛型对象（T），并返回测试结果（boolean），函数描述符为 T -&gt; boolean。下面是一个使用示例：12345678public &lt;T&gt; boolean judge(T t, Predicate&lt;T&gt; p) &#123; return p.test(t);&#125;public void testPredicate() &#123; String text = "111"; System.out.println(judge(text, s -&gt; s != null));&#125; 下面是 Predicate 接口的实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Represents a predicate (boolean-valued function) of one argument. */@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; /** * Evaluates this predicate on the given argument. * * @param t the input argument * @return true if the input argument matches the predicate, * otherwise false */ boolean test(T t); /** * Returns a composed predicate that represents a short-circuiting logical * AND of this predicate and another. When evaluating the composed * predicate, if this predicate is false, then the other * predicate is not evaluated. */ default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) &amp;&amp; other.test(t); &#125; /** * Returns a predicate that represents the logical negation of this * predicate. */ default Predicate&lt;T&gt; negate() &#123; return (t) -&gt; !test(t); &#125; /** * Returns a composed predicate that represents a short-circuiting logical * OR of this predicate and another. When evaluating the composed * predicate, if this predicate is true, then the other * predicate is not evaluated. */ default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) || other.test(t); &#125; /** * Returns a predicate that tests if two arguments are equal according * to &#123;@link Objects#equals(Object, Object)&#125;. */ static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) &#123; return (null == targetRef) ? Objects::isNull : object -&gt; targetRef.equals(object); &#125;&#125; 我们看到在 Predicate 类中，除了 test 方法，还定义了三个 default 方法，and, or 和 negate，它们分别对应逻辑运算中的与（&amp;&amp;）、或（||）、非（!）操作。通过这三个方法，我们可以构造更复杂的 predicate 表达式：12345678public void testPredicate() &#123; String text = "111"; Predicate&lt;String&gt; a = s - &gt; s != null; Predicate&lt;String&gt; b = s - &gt; s.length() &gt; 3; System.out.println(judge(text, a.and(b))); System.out.println(judge(text, a.negate())); System.out.println(judge(text, a.or(b)));&#125; 对应的输出结果为：123falsefalsetrue 另外 and 和 or 方法是按照在表达式链中的位置，从左向右确定优先级的。因此 a.or(b).and(c) 可以看作 (a || b) &amp;&amp; c。 BiPredicateBiPredicate 针对两个参数对象（T, U）进行测试，函数描述符为 (T, U) -&gt; boolean。下面是该接口的定义：1234567891011121314151617181920212223/** * Represents a predicate (boolean-valued function) of two arguments. This is * the two-arity specialization of &#123;@link Predicate&#125;. */@FunctionalInterfacepublic interface BiPredicate&lt;T, U&gt; &#123; boolean test(T t, U u); default BiPredicate&lt;T, U&gt; and(BiPredicate&lt;? super T, ? super U&gt; other) &#123; Objects.requireNonNull(other); return (T t, U u) -&gt; test(t, u) &amp;&amp; other.test(t, u); &#125; default BiPredicate&lt;T, U&gt; negate() &#123; return (T t, U u) -&gt; !test(t, u); &#125; default BiPredicate&lt;T, U&gt; or(BiPredicate&lt;? super T, ? super U&gt; other) &#123; Objects.requireNonNull(other); return (T t, U u) -&gt; test(t, u) || other.test(t, u); &#125;&#125; 下面是一个使用示例：12345public void testBiPredicate() &#123; BiPredicate&lt;Integer, Integer&gt; b = (x, y) -&gt; x &gt; 0 &amp;&amp; y &gt; 3; boolean r = b.test(1, 4); System.out.println(r);&#125; ConsumerConsumer（消费者），针对对象进行某种操作（消费对象）。该接口定义了一个 accept 方法，会将该方法作用于目标对象，函数描述符为 T -&gt; void。下面是使用示例：123456789public &lt;T&gt; void consume(T t, Consumer&lt;T&gt; c) &#123; c.accept(t);&#125;@Testpublic void testConsume() &#123; String text = "1234"; consume(text, s -&gt; System.out.println(s.substring(2)));&#125; 下面是 Consumer 类的代码123456789101112131415161718192021222324252627/** * Represents an operation that accepts a single input argument and returns no * result. Unlike most other functional interfaces, Consumer is expected * to operate via side-effects. */@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t); /** * Returns a composed Consumer that performs, in sequence, this * operation followed by the after operation. If performing either * operation throws an exception, it is relayed to the caller of the * composed operation. If performing this operation throws an exception, * the after operation will not be performed. */ default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;; &#125;&#125; Consumer 中定义了一个 andThen 的 default 方法，通过该方法我们可以对目标对象进行链式（chain）处理，下面是一个示例：12345678public void testConsume() &#123; StringBuilder builder = new StringBuilder(); Consumer &lt;StringBuilder&gt; a = s -&gt; s.append("abcd"); Consumer &lt;StringBuilder&gt; b = s -&gt; s.reverse(); Consumer &lt;StringBuilder&gt; c = s -&gt; s.append("1234"); consume(builder, a.andThen(b).andThen(c)); System.out.println(builder.toString());&#125; 输出结果为：1dcba1234 BiConsumerBiConsumer 针对两个对象（T, U）进行操作，对应的函数描述符为 (T, U) -&gt; void。下面是该接口的定义：1234567891011121314151617181920/** * Represents an operation that accepts two input arguments and returns no * result. This is the two-arity specialization of Consumer. * Unlike most other functional interfaces, BiConsumer is expected * to operate via side-effects. */@FunctionalInterfacepublic interface BiConsumer&lt;T, U&gt; &#123; void accept(T t, U u); default BiConsumer&lt;T, U&gt; andThen(BiConsumer&lt;? super T, ? super U&gt; after) &#123; Objects.requireNonNull(after); return (l, r) -&gt; &#123; accept(l, r); after.accept(l, r); &#125;; &#125;&#125; 下面是一个例子：1234public void testBiConsumer() &#123; BiConsumer&lt;String, String&gt; b = (x, y) -&gt; System.out.println(x + y); b.accept("111", "222");&#125; SupplierSupplier（供应商），返回一个泛型对象（生产对象）。该接口中定义了一个 get 方法，没有方法参数，返回值是一个泛型对象，函数描述符为 () -&gt; T。下面是一个使用示例12345678public &lt;T&gt; T supplier(Supplier&lt;T&gt; s) &#123; return s.get();&#125;public void testSupplier() &#123; String text = supplier(() -&gt; "1111"); System.out.println(text);&#125; 下面是 Supplier 接口的定义：1234567891011/** * Represents a supplier of results. */@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; /** * Gets a result. */ T get();&#125; FunctionFunction 接口就相当于 y=f(x) 中的函数 f，接收一个 x（argument）返回计算值 y（result）。该接口定义了一个 apply 方法，接收一个 T 类型的对象，返回一个 R 类型的结果，函数描述符为 T -&gt; R。下面是一个使用示例：12345678910public &lt;T, R&gt; R func(T t, Function&lt;T, R&gt; f) &#123; return f.apply(t);&#125;public void testFunction() &#123; String text = "1234"; int i = func(text, t -&gt; Integer.parseInt(t)); // 输出 1235 System.out.println(i + 1);&#125; 下面是 Function 接口的定义：12345678910111213141516171819202122232425262728293031323334353637383940/** * Represents a function that accepts one argument and produces a result. */@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; /** * Applies this function to the given argument. */ R apply(T t); /** * Returns a composed function that first applies the before * function to its input, and then applies this function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. */ default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123; Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v)); &#125; /** * Returns a composed function that first applies this function to * its input, and then applies the after function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. */ default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t)); &#125; /** * Returns a function that always returns its input argument. */ static &lt;T&gt; Function&lt;T, T&gt; identity() &#123; return t -&gt; t; &#125;&#125; 在 Function 接口中定义了两个 default 方法：compose 和 andThen 可以进行链式的调用，假设有两个函数 f(x) 和 g(x):12f.compose(g) =&gt; f(g(x))f.andThen(g) =&gt; g(f(x)) 下图是一个详细的解释 下面是一个使用示例：1234567891011public void testFunction() &#123; Function&lt;Integer, Integer&gt; f = x -&gt; x + 1; Function&lt;Integer, Integer&gt; g = x -&gt; x * 2; int i = func(1, f.andThen(g)); // 输出 4 System.out.println(i); i = func(1, f.compose(g)); // 输出 3 System.out.println(i);&#125; UnaryOperatorUnaryOperator 是一种特殊的 Function，表示操作数和返回值是同一种类型，函数描述符为 T -&gt; T。下面是该接口的定义：123456789101112131415/** * Represents an operation on a single operand that produces a result of the * same type as its operand. This is a specialization of &#123;@code Function&#125; for * the case where the operand and result are of the same type. */@FunctionalInterfacepublic interface UnaryOperator&lt;T&gt; extends Function&lt;T, T&gt; &#123; /** * Returns a unary operator that always returns its input argument. */ static &lt;T&gt; UnaryOperator&lt;T&gt; identity() &#123; return t -&gt; t; &#125;&#125; 下面是一个使用示例：1234public void testUnaryOperator() &#123; UnaryOperator&lt;Integer&gt; u = x -&gt; x + 1; System.out.println(u.apply(1));&#125; BiFunctionBiFunction 接收两个参数（T, U），返回一个结果（R），类似于 z=f(x, y)，对应的函数描述符为 (T, U) -&gt; R。下面是该接口的具体实现：12345678910111213141516171819202122232425262728/** * Represents a function that accepts two arguments and produces a result. * This is the two-arity specialization of Function. */@FunctionalInterfacepublic interface BiFunction&lt;T, U, R&gt; &#123; /** * Applies this function to the given arguments. * * @param t the first function argument * @param u the second function argument * @return the function result */ R apply(T t, U u); /** * Returns a composed function that first applies this function to * its input, and then applies the &#123;@code after&#125; function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. */ default &lt;V&gt; BiFunction&lt;T, U, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123; Objects.requireNonNull(after); return (T t, U u) -&gt; after.apply(apply(t, u)); &#125;&#125; 下面是一个使用示例：12345public void testBiFunction() &#123; BiFunction&lt;Integer, Double, String&gt; b = (i, d) -&gt; String.valueOf(i + d); String r = b.apply(1, 2.5); System.out.println(r);&#125; BinaryOperatorBinaryOperator 是一种特殊的 BiFunction，表示接收的参数和返回的结果都是同一种类型 T，函数描述符为 (T, T) -&gt; T。下面是该接口的定义：1234567891011121314151617181920212223242526/** * Represents an operation upon two operands of the same type, producing a result * of the same type as the operands. This is a specialization of * BiFunction for the case where the operands and the result are all of * the same type. */@FunctionalInterfacepublic interface BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; &#123; /** * Returns a BinaryOperator which returns the lesser of two elements * according to the specified Comparator. */ public static &lt;T&gt; BinaryOperator&lt;T&gt; minBy(Comparator&lt;? super T&gt; comparator) &#123; Objects.requireNonNull(comparator); return (a, b) -&gt; comparator.compare(a, b) &lt;= 0 ? a : b; &#125; /** * Returns a BinaryOperator which returns the greater of two elements * according to the specified Comparator. */ public static &lt;T&gt; BinaryOperator&lt;T&gt; maxBy(Comparator&lt;? super T&gt; comparator) &#123; Objects.requireNonNull(comparator); return (a, b) -&gt; comparator.compare(a, b) &gt;= 0 ? a : b; &#125;&#125; 下面是一个使用示例:123456789101112131415public void testBinaryOperator() &#123; BinaryOperator&lt;Integer&gt; b = (x, y) -&gt; x + y; int z = b.apply(1, 3); System.out.println(z); BinaryOperator&lt;Integer&gt; min = BinaryOperator.minBy((x, y) -&gt; x - y); // 输出 1 z = min.apply(1, 3); System.out.println(z); // 输出 3 BinaryOperator&lt;Integer&gt; max = BinaryOperator.maxBy((x, y) -&gt; x - y); z = max.apply(1, 3); System.out.println(z);&#125; Primitive specializations在上面提到的接口中，都是接受泛型参数，我们知道泛型参数只能是引用类型，也就是说对于 int 这样的基本类型，我们要首先装箱（boxing）成 Integer 类型，在使用的时候再拆箱（unboxing）成 int。虽然 Java 提供了自动装箱机制，但是在性能方面是要付出代价的。所以对于上述的函数式接口，Java 8 提供了针对基本类型的版本，以此来避免输入输出是基本类型时的自动装箱操作。以 Predicate 为例，假设我们要检测一个 int 是否满足某个条件，我们可以使用 IntPredicate ：12345public void testIntPredicate() &#123; IntPredicate ip = x -&gt; x &gt; 3; boolean r = ip.test(4); System.out.println(r);&#125; 下面是 IntPredicate 的定义，我们可以看到它将泛型 T 改为了基本类型 int。123456789101112131415161718192021222324/** * Represents a predicate (boolean-valued function) of one &#123;@code int&#125;-valued * argument. This is the &#123;@code int&#125;-consuming primitive type specialization of * &#123;@link Predicate&#125;. */@FunctionalInterfacepublic interface IntPredicate &#123; boolean test(int value); default IntPredicate and(IntPredicate other) &#123; Objects.requireNonNull(other); return (value) -&gt; test(value) &amp;&amp; other.test(value); &#125; default IntPredicate negate() &#123; return (value) -&gt; !test(value); &#125; default IntPredicate or(IntPredicate other) &#123; Objects.requireNonNull(other); return (value) -&gt; test(value) || other.test(value); &#125;&#125; 下表列出了 Java 8 中的函数式接口以及其对应的基本类型版本： 函数式接口 函数描述符 基本类型版本 Predicate&lt;T&gt; T -&gt; boolean IntPredicate, LongPredicate, DoublePredicate BiPredicate&lt;T&gt; (L, R) -&gt; boolean Consumer&lt;T&gt; T -&gt; void IntConsumer, LongConsumer, DoubleConsumer BiConsumer&lt;T, U&gt; (T, U) -&gt; void ObjIntConsumer&lt;T&gt;, ObjLongConsumer&lt;T&gt;, ObjDoubleConsumer&lt;T&gt; Supplier&lt;T&gt; () -&gt; T BooleanSupplier, IntSupplier, LongSupplier, DoubleSupplier Function&lt;T, R&gt; T -&gt; R IntFunction&lt;R&gt;, IntToDoubleFunction, IntToLongFunction, LongFunction&lt;R&gt;, LongToDoubleFunction, LongToIntFunction, DoubleFunction&lt;R&gt;, ToIntFunction&lt;T&gt;, ToDoubleFunction&lt;T&gt;, ToLongFunction&lt;T&gt; UnaryOperator&lt;T&gt; T -&gt; T IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator BiFunction&lt;T, U, R&gt; (T, U) -&gt; R ToIntBiFunction&lt;T, U&gt;, ToLongBiFunction&lt;T, U&gt;, ToDoubleBiFunction&lt;T, U&gt; BinaryOperator&lt;T&gt; (T, T) -&gt; T IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator]]></content>
      <categories>
        <category>Java 8</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Django】Django ORM 学习笔记]]></title>
    <url>%2F2017%2F06%2F24%2F%E3%80%90Django%E3%80%91Django-ORM-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言ORM，即Object-Relational Mapping（对象关系映射），它的作用是在关系型数据库和业务实体对象之间作一个映射，这样，我们在具体的操作业务对象的时候，就不需要再去和复杂的SQL语句打交道，只需简单的操作对象的属性和方法。下面是一个示例。通过使用 ORM，我们只需要操作 Author 和 Blog 对象，而不用操作相关的数据库表。这里主要介绍一下 Django ORM 的相关使用。 优缺点使用 ORM 最大的优点就是快速开发，让我们将更多的精力放在业务上而不是数据库上，下面是 ORM 的几个优点 隐藏了数据访问细节，使通用数据库交互变得简单易行。同时 ORM 避免了不规范、冗余、风格不统一的 SQL 语句，可以避免很多人为的 bug，方便编码风格的统一和后期维护。 将数据库表和对象模型关联，我们只需针对相关的对象模型进行编码，无须考虑对象模型和数据库表之间的转化，大大提高了程序的开发效率。 方便数据库的迁移。当需要迁移到新的数据库时，不需要修改对象模型，只需要修改数据库的配置。 ORM 的最令人诟病的地方就是性能问题，不过现在已经提高了很多，下面是 ORM 的几个缺点 性能问题 自动化进行数据库关系的映射需要消耗系统资源 程序员编码 在处理多表联查、where 条件复杂的查询时，ORM 可能会生成的效率低下的 SQL 通过 Lazy load 和 Cache 很大程度上改善了性能问题 SQL 调优，SQL 语句是由 ORM 框架自动生成，虽然减少了 SQL 语句错误的发生，但是也给 SQL 调优带来了困难。 越是功能强大的 ORM 越消耗内存，因为一个 ORM Object 会带有很多成员变量和成员函数。 对象和关系之间并不是完美映射 一般来说 ORM 足以满足我们的需求，如果对性能要求特别高或者查询十分复杂，可以考虑使用原生 SQL 和 ORM 共用的方式 Django ORM在 Django 框架中集成了 ORM 模块，我们来看下具体的使用，部分内容会给出基于 MySQL 的 SQL 语句。 Manager在创建完 Model 对象之后，Django 会自动为其关联一个 Manager 对象，该对象是 Model 进行数据库操作的接口。默认的 Manager 对象名称为 objects，下面是使用 Manager 进行增删改查的一个示例：123456789101112131415161718192021def save_blog(): # 使用 get 检索数据时，如果数据不存在，会报 DoesNotExist 错误 # 可以使用 Blog.objects.all().filter(id=1).first() 方法 author = Author.objects.get(id=1) blog = Blog(title='blog2', content='blog2', author=author) blog.save()def update_blog(): blog = Blog.objects.all().get(id=2) blog.title = 'change_title' blog.save()def delete_blog(): blog = Blog.objects.all().filter(id=2).first() if blog is not None: blog.delete()def fetch_blog(): blogs = Blog.objects.all() for blog in blogs: print blog 我们可以自定义 Manager 的名称，如下所示：1234567from django.db import modelsclass Person(models.Model): #... people = models.Manager()Person.people.all() 同时我们也可以定义自己的 Manager，为 Manager 加上一些额外的功能，下面的示例会为 Author 添加上所写 Blog 数量信息：123456789101112131415161718192021222324252627282930313233class AuthorManager(models.Manager): def with_blog_counts(self, **kwargs): from django.db import connection cursor = connection.cursor() condition = '' if kwargs.has_key('id'): condition = 'a.id = %s and ' % kwargs['id'] query = ''' SELECT a.id, a.name, COUNT(b.id) FROM orm_author a LEFT JOIN orm_blog b ON a.id = b.author_id WHERE %s TRUE GROUP BY a.id ''' % condition cursor.execute(query) result_list = [] for row in cursor.fetchall(): author = self.model(id=row[0], name=row[1]) author.blog_count = row[2] result_list.append(author) return result_listclass Author(models.Model): name = models.CharField(max_length=50) objects = AuthorManager()authors = Author.objects.with_blog_counts(id=2) for author in authors: print author.name, author.blog_count 另外我们也可以为 Model 指定多个 Manager123class Author(models.Model): manager = models.Manager() manager2 = AuthorManager() QuerySet从数据库中查询出来的结果一般是一个集合，这个集合称为 QuerySet。QuerySet 有两种来源：通过 Manager 的方法获取、通过 QuerySet 自身的方法获得。Manager 的查询方法和 QuerySet 的方法大部分同名、同意（Manager的就是基于 QuerySet 的实现的），例如 filter, exclude等，但两者也有不同的方法，例如 Manager 的 create、get_or_create，QuerySet 的 delete 等。 基本查询下面是 QuerySet (也是 Manager的)的几个基本的查询方法 all() - 获得数据库中所有实例的一个 QuerySet 1234Blog.objects.all()# 对应SQL# SELECT `orm_blog`.`id`, `orm_blog`.`author_id`, `orm_blog`.`title`, `orm_blog`.`content`# FROM `orm_blog`() filter(**kwargs) - 返回满足查询条件的 QuerySet 1234Blog.objects.filter(title='blog2')# 对应 SQL# SELECT `orm_blog`.`id`, `orm_blog`.`author_id`, `orm_blog`.`title`, `orm_blog`.`content`# FROM `orm_blog` WHERE `orm_blog`.`title` = 'blog2' exclude(**kwargs) - 获得不满足查询条件的 QuerySet 1234Blog.objects.exclude(title='blog2')# 对应 SQL# SELECT `orm_blog`.`id`, `orm_blog`.`author_id`, `orm_blog`.`title`, `orm_blog`.`content`# FROM `orm_blog` WHERE NOT (`orm_blog`.`title` = 'blog2') get(**kwargs) — 从数据库中获得一个匹配的结果（一个实例），如果没有匹配结果或者匹配结果大于一个都会报错 字段查询在前面的 filter、exclude 和 get 方法中，我们需要传入参数作为选择条件: title=&#39;blog2&#39;，这个就是字段查询。字段查询的格式如下1field__lookuptype=value # 中间是两个下划线 lookuptype 的类型有下面几种 exact 精确匹配，默认的 lookup type。上面的 title=&#39;blog2&#39; 就相当于 title__exact=&#39;blog2&#39; gt : 大于 gte : 大于等于 lt : 小于 lte :小于等于 in : in contains : 包含，区分大小写 - a LIKE BINARY &#39;%b%&#39; icontains : 包含，不区分大小写 - a LIKE &#39;%b%&#39; iexact : 大小写不敏感的精确匹配 - a LIKE &#39;b&#39; startswith : 匹配开头，区分大小写 - a LIKE BINARY &#39;b%&#39; istartswith : 匹配开头，不区分大小写 - a LIKE &#39;b%&#39; endswith : 匹配结尾，区分大小写 - a LIKE BINARY &#39;%b&#39; iendswith : 匹配结尾，不区分大小写 - a LIKE &#39;%b&#39; 我们还可以进行关联查询，下面的例子是查询所有 author name 为 zjk 的 blog，123456blogs = Blog.objects.filter(author__name='zjk')# SQL:# SELECT `orm_blog`.`id`, `orm_blog`.`author_id`, `orm_blog`.`title`, `orm_blog`.`content`# FROM `orm_blog` INNER JOIN `orm_author` ON (`orm_blog`.`author_id` = `orm_author`.`id`)# WHERE `orm_author`.`name` = 'zjk' 限制 QuerySet有时候我们并不需要获取查询集的全部数据，而只需要一个子集，一个常见的场景就是进行分页查询。使用 Python 的切片语法可以限制 QuerySet 的实例数量，ORM 会将翻译成 SQL 的 LIMIT 和 OFFSET 子句，下面是几个例子： 放回 QuerySet 的前 5 个元素 12345blogs = Blog.objects.all()[:5]# SQL：# SELECT `orm_blog`.`id`, `orm_blog`.`author_id`, `orm_blog`.`title`, `orm_blog`.`content`# FROM `orm_blog` LIMIT 5 返回 QuerySet 的第 6-10 个元素 12345blogs = Blog.objects.all()[5:10]# SQL:# SELECT `orm_blog`.`id`, `orm_blog`.`author_id`, `orm_blog`.`title`, `orm_blog`.`content`# FROM `orm_blog` LIMIT 5 OFFSET 5 使用切片的 step 参数，下面代码返回第 1、3、5、7、9 个元素 12345blogs = Blog.objects.all()[:10:2]# SQL:# SELECT `orm_blog`.`id`, `orm_blog`.`author_id`, `orm_blog`.`title`, `orm_blog`.`content`# FROM `orm_blog` LIMIT 10 如果只要访问一个元素，可以直接用索引来访问： 12345blog = Blog.objects.all()[2]# SQL:# SELECT `orm_blog`.`id`, `orm_blog`.`author_id`, `orm_blog`.`title`, `orm_blog`.`content`# FROM `orm_blog` LIMIT 1 OFFSET 2 Lazy loadQuerySet 是惰性加载的，创建查询集不会访问数据库，只有查询集需要求值时，才会真正运行这个查询。在下面的例子中只有执行 print q 才会真正的去查询数据库。123456789q = Blog.objects.filter(title='blog2')q = q.filter(content='blog2')q = q.exclude(id=3)# 执行下面的语句才会真正访问数据库print q# SQL:# SELECT `orm_blog`.`id`, `orm_blog`.`author_id`, `orm_blog`.`title`, `orm_blog`.`content` FROM `orm_blog`# WHERE (`orm_blog`.`title` = 'blog2' AND `orm_blog`.`content` = 'blog2' AND NOT (`orm_blog`.`id` = 3)) LIMIT 21 关联对象也是惰性加载，只有用到了关联对象的值才会访问数据库12345678910blog = Blog.objects.filter(id=3).first()print blog.title# 只有执行下面的语句才会访问数据库获取 author 的值，也就是执行第二条 SQLprint blog.author.name# SQL:# SELECT `orm_blog`.`id`, `orm_blog`.`author_id`, `orm_blog`.`title`, `orm_blog`.`content`# FROM `orm_blog` WHERE `orm_blog`.`id` = 3 ORDER BY `orm_blog`.`id` ASC LIMIT 1## SELECT `orm_author`.`id`, `orm_author`.`name` FROM `orm_author` WHERE `orm_author`.`id` = 1 一般来说只要用到了 QuerySet 以及里面对象的信息，就会访问数据库。下面是文档中给出的几种会对查询集求值的情况： 迭代：在首次迭代查询集时会执行数据库查询 切片(限制查询集)：对查询集执行切片操作时，指定 step 参数 序列化／缓存 repr：对查询集调用 repr 函数 len：对查询集调用 len 函数 list: 对查询集调用 list() 方法强制求值 bool:测试一个查询集的布尔值，例如使用bool(), or, and 或者 if 语句都将导致查询集的求值 缓存每个 QuerySet 都包含一个缓存来最小化对数据库的访问，下面是一个示例：12345678# 下面代码会访问两次数据库print [blog.title for blog in Blog.objects.all()]print [blog.content for blog in Blog.objects.all()]# 下面代码只会访问一次数据库blogs = Blog.objects.all()print [blog.title for blog in blogs]print [blog.content for blog in blogs] 在一个新的 QuerySet 中，缓存为空。当首次对 QuerySet 的所有实例进行求值时，会将查询结果保存到 QuerySet 的缓冲中。当再访问该 QuerySet 时，会直接从缓冲中取数据。下面是一个示意图： 如果只对 QuerySet 的部分实例（query_set[5], query_set[0:10]）进行求值，首先会到 QuerySet 的缓冲中查找是否已经缓存了这些实例，如果有就使用缓存值，如果没有就查询数据库，但是不会将查询结果保存到缓冲中。如下图所示： 如果 QuerySet 数量很大不希望被缓存，遍历时使用 iterator 方法:123blogs = Blog.objects.all()for blog in blogs.iterator(): print blog.title 关联查询在讲关联查询之前，首先看一下下面的一个示例。我们前面提到，关联实例是惰性加载的，因此对于下面的代码，每次 for 循环都要访问一次数据库，会严重影响性能。因此我们需要一次将 blog 以及 author 的信息全部取出来，这就是我们马上要讲的关联查询。123456789for blog in Blog.objects.all(): print blog.title, blog.author.name# SQL:# SELECT `orm_blog`.`id`, `orm_blog`.`author_id`, `orm_blog`.`title`, `orm_blog`.`content` FROM `orm_blog`## SELECT `orm_author`.`id`, `orm_author`.`name` FROM `orm_author` WHERE `orm_author`.`id` = 1# SELECT `orm_author`.`id`, `orm_author`.`name` FROM `orm_author` WHERE `orm_author`.`id` = 1.# . . . . . . 关联查询就是在查询当前实例的同时，把其关联的实例数据也一块取出来。在下图中 orm_blog 通过一个外键和 orm_author 关联。关联大体上可以分为两种： 只有一个关联实例： 外键关联中包含外键的表、OneToOneField，例如下图中的 orm_blog 只与一个 orm_author 的实例关联 有多个关联实例：外键关联中不含外键的表、ManyToManyField，例如下图中的 orm_author 就与多个 orm_blog 实例关联 因此 Django ORM 中的关联查询也分两中 select_related(单关联实例) 和 prefetch_related(多关联实例) select_relatedselect_related 用来处理单关联实例的情况，适用于 ForeignKey 和 OneToOneField。在查询时，会对关联的表进行 join 操作，取出全部的信息，下面是一个示例：1234567blog = Blog.objects.select_related().filter(id=3).first()print blog.id, blog.author.name# SQL# SELECT `orm_blog`.`id`, `orm_blog`.`author_id`, `orm_blog`.`title`, `orm_blog`.`content`, `orm_author`.`id`, `orm_author`.`name`# FROM `orm_blog` INNER JOIN `orm_author` ON (`orm_blog`.`author_id` = `orm_author`.`id`)# WHERE `orm_blog`.`id` = 3 ORDER BY `orm_blog`.`id` ASC LIMIT 1 下面是一个示意图： select_related 会沿着外键递归查询，例如上图中取表 1 的实例时，会沿着外键将表 3 的数据一块取出来。我们可以传入 depth 参数来指定递归的深度。 如果需要清除 QuerySet 上以前的 select_related 添加的关联字段，可以传入 None 做参数 prefetch_relatedprefetch_related 主要适用于 OneTwoMany 和 ManyToManyField。和 select_related 类似，prefetch_related 在查询时会同时取出关联实例的值。与 select_related 不同的是 prefetch_related 不使用 JOIN 方式来查询数据库，而是分别查每个表，最后使用 Python 来实现 JOIN 操作。下面是一个示例：12345678910author = Author.objects.prefetch_related('blog_set').filter(name='zjk').first()for blog in author.blog_set.all(): print blog# SQL:# SELECT `orm_author`.`id`, `orm_author`.`name` FROM `orm_author`# WHERE `orm_author`.`name` = 'zjk' ORDER BY `orm_author`.`id` ASC LIMIT 1## SELECT `orm_blog`.`id`, `orm_blog`.`author_id`, `orm_blog`.`title`, `orm_blog`.`content`# FROM `orm_blog` WHERE `orm_blog`.`author_id` IN (1) 下面是一个示意图： 如果查询出关联对象的 QuerySet 之后，再对该 QuerySet 执行查询条件，会使该 QuerySet 失效（也就是需要再次访问数据库）。如果在查询关联对象时需要使用查询条件，可以使用 Prefetch 对象，下面是一个示例： 1234567891011121314from django.db.models import Prefetchauthors = Author.objects.prefetch_related(Prefetch( 'blog_set', queryset=Blog.objects.filter(title='blog2'), to_attr='blogs'))for author in authors: print author.blogs# SQL:# SELECT `orm_author`.`id`, `orm_author`.`name` FROM `orm_author`# # SELECT `orm_blog`.`id`, `orm_blog`.`author_id`, `orm_blog`.`title`, `orm_blog`.`content`# FROM `orm_blog` WHERE (`orm_blog`.`title` = 'blog2' AND `orm_blog`.`author_id` IN (1, 2)) Q 查询在前面所讲的 filter 和 exclude 方法，对于传入的查询条件都是执行的 AND 操作，如果我们需要对查询条件执行 OR 操作，例如查询 blog 表中 title=‘blog1’ 或者 title=‘blog2’ 的实例，就需要用到 Q 查询。Q 查询支持使用 |、&amp;、~ 操作符，分别对象查询条件的 OR、AND 和 NOT 操作。下面是一个示例：123456789from django.db.models import Qblogs = Blog.objects.filter(Q(id=10) | Q(title='blog2'))for blog in blogs: print blog# SQL:# SELECT `orm_blog`.`id`, `orm_blog`.`author_id`, `orm_blog`.`title`, `orm_blog`.`content`# FROM `orm_blog` WHERE (`orm_blog`.`id` = 10 OR `orm_blog`.`title` = ‘blog2') F 查询F 查询主要用来处理表中字段之间的比较，例如查询 blog 表中 title=conent 的记录。同时 F 查询还支持计算（加减乘除）。下面是一个示例：1234567891011121314151617from django.db.models import Fblogs = Blog.objects.filter(title=F('content'))for blog in blogs: print blog# SQL:# SELECT `orm_blog`.`id`, `orm_blog`.`author_id`, `orm_blog`.`title`, `orm_blog`.`content`# FROM `orm_blog` WHERE `orm_blog`.`title` = (`orm_blog`.`content`)blogs = Blog.objects.filter(title=F('content')+2)for blog in blogs: print blog# SQL：# SELECT `orm_blog`.`id`, `orm_blog`.`author_id`, `orm_blog`.`title`, `orm_blog`.`content`# FROM `orm_blog` WHERE `orm_blog`.`title` = ((`orm_blog`.`content` + 2)) values 和 values_list有些时候我们不需要获取实例中所有的数据，而只需要获得几个字段的数据即可，使用 values 和 values_list 可以指定检索的字段。values 会返回一个 dict 数组，而 values_list 会返回 list 数组。下面是一个例子：1234567891011121314blogs = Blog.objects.filter(id=5).values('title')print blogs# &lt;QuerySet [&#123;u'title': u’blog2'&#125;]&gt;blogs = Blog.objects.filter(id=5).values_list('title')print blogs# &lt;QuerySet [(u’blog2',)]&gt;blogs = Blog.objects.filter(id=5).values_list('title', flat=True)print blogs# &lt;QuerySet [u’blog2']&gt; aggregate 和 annotate通过 aggregate 和 annotate 可以使用 SQL 的聚合函数，例如 SUM、COUNT、MIN 等。aggregate: 针对所有记录调用聚合函数，返回一个 dict 对象，下面是使用示例：123456789101112131415from django.db.models import Minfrom django.db.models import Sumresult = Blog.objects.aggregate(Min('id'))print result# &#123;u'id__min': 3L&#125;# SELECT MIN(`orm_blog`.`id`) AS `id__min` FROM `orm_blog`# 自定义属性名result = Blog.objects.aggregate(total=Sum('id'))print result# &#123;'total': Decimal(‘657')&#125;# SELECT SUM(`orm_blog`.`id`) AS `total` FROM `orm_blog annotate 先使用 groupby 分组，然后对于每组再调用聚合函数，返回 QuerySet 对象。 annotate 默认按照 id 进行分组，如果需要按其他字段分组，要结合 values ／values_list 方法。下面是使用示例：123456789101112131415161718192021222324#认按照 id 进行分组blogs = Blog.objects.annotate(Count('title'))for blog in blogs: print blog.title__count# SELECT `orm_blog`.`id`, `orm_blog`.`author_id`, `orm_blog`.`title`, `orm_blog`.`content`, # COUNT(`orm_blog`.`title`) AS `title__count` FROM `orm_blog` GROUP BY `orm_blog`.`id` ORDER BY NULL# 使用 values 方法，会按照 values 中传入的属性分组blogs = Blog.objects.values('title').annotate(Count('title'))for blog in blogs: print blog['title__count']# SELECT `orm_blog`.`title`, COUNT(`orm_blog`.`title`) AS `title__count` FROM `orm_blog`# GROUP BY `orm_blog`.`title` ORDER BY NULLblogs = Blog.objects.values('title', 'content').annotate(Count('title'))for blog in blogs: print blog['title__count']# SELECT `orm_blog`.`title`, `orm_blog`.`content`, COUNT(`orm_blog`.`title`) AS `title__count`# FROM `orm_blog` GROUP BY `orm_blog`.`title`, `orm_blog`.`content` ORDER BY NULL 下图是 aggregate 和 annotate 的比较： extra如何一些查询比较复杂可以考虑使用 extra 方法。extra 能在 ORM 生成的 SQL 子句中注入 SQL 代码，语法格式如下：12# 至少保证一个参数不为空extra(select=None, where=None, params=None, tables=None, order_by=None, select_params=None) select：在 select 子句中插入 SQL 代码 1234567891011blogs = Blog.objects.extra(select=&#123; 'is_one': ‘id=5'&#125;)# SELECT (id=5) AS `is_one`, `orm_blog`.`id`. . . . .authors = Author.objects.extra( select=&#123; 'blog_count' : 'select count(*) from orm_blog where orm_blog.author_id = orm_author.id' &#125;)# SELECT (select count(*) from orm_blog where orm_blog.author_id = orm_author.id) AS `blog_count` . . . select_params: 设置 select 参数 1234567blogs = Blog.objects.extra( select=&#123; 'a': '%s' &#125;, select_params=(‘id=1',))# SELECT ('id=1') AS `a` . . . . . where: 在 where 子句中插入 SQL 代码 1234blogs = Blog.objects.extra( where=['id=4 or id=5'])# SELECT . . . . . . FROM `orm_blog` WHERE (id=4 or id=5) params: 为 where 设置参数 12345blogs = Blog.objects.extra( where=['id=%s'], params=(1,))# SELECT . . . . . . FROM `orm_blog` WHERE (id=1) tables: 在 FROM 子句中插入 table 名称 1234blogs = Blog.objects.extra( tables=['orm_author', 'auth_group'])# SELECT . . . . . . FROM `orm_blog` , `orm_author` , `auth_group` order_by：在 order_by 子句中插入排序字段 12345# - 表示倒序blogs = Blog.objects.extra( order_by=['-id', 'title'])# SELECT . . . . . . FROM `orm_blog` ORDER BY `orm_blog`.`id` DESC, `orm_blog`.`title` ASC 原始 SQL 查询使用 Manager 的 raw 方法可以用于原始的 SQL 查询，并返回 Model 的实例：123blogs = Blog.objects.raw('select * from orm_blog')for blog in blogs: print blog.id , blog.title 如果 SQL 中没有获取某个字段，那么会惰性加载该字段12345678910# 没有取 title，在后面使用时会访问数据库blogs = Blog.objects.raw('select id from orm_blog')for blog in blogs: print blog.id print blog.title# select id from orm_blog# SELECT `orm_blog`.`id`, `orm_blog`.`title` FROM `orm_blog` WHERE `orm_blog`.`id` = 3# SELECT `orm_blog`.`id`, `orm_blog`.`title` FROM `orm_blog` WHERE `orm_blog`.`id` = 4#. . . . 一些优化 如果只需要判断实例是否存在，使用 exists 更高效 12345blogs = Blog.objects.filter(id=5)if blogs.exists(): print 'record exist’# SELECT (1) AS `a` FROM `orm_blog` WHERE `orm_blog`.`id` = 5 LIMIT 1 如果只需要得到实例的数量，使用 count 函数 1234blogs = Blog.objects.filter(id=5)print blogs.count()# SELECT COUNT(*) AS `__count` FROM `orm_blog` WHERE `orm_blog`.`id` = 5]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Django ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Vue】使用 Vue2 开发一个项目列表展示应用]]></title>
    <url>%2F2017%2F04%2F27%2F%E3%80%90Vue%E3%80%91%E4%BD%BF%E7%94%A8-Vue2-%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E5%88%97%E8%A1%A8%E5%B1%95%E7%A4%BA%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言一直没有找到一个合适的展示个人项目的模板，所以自己动手使用 Vue 写了一个。该模板基于 Markdown 文件进行配置，只需要按一定规则编写 Markdown 文件，然后使用一个 在线工具 转为 JSON 文件即可。下面是该项目的在线地址和源码。本文主要记录一下项目中用到的相关知识。 在线演示 &nbsp;&nbsp; 源码 效果程序最终的效果如下图所示： 整个项目只包含两个组件：项目介绍 和 侧边导航，逻辑比较简单，十分适合入门。 环境配置这里我们使用 Gulp 和 Webpack 用作项目构建工具。初次使用 Gulp 和 Webpack 可能不太适应，因为它们的配置可能让你看的一头雾水。不过不用担心，这两个毕竟只是一个工具，在初始时没有必要特别的了解它们的工作原理，只要能运行起来就可以。等到使用了一段时间之后，自然而然的就知道该如何配置了。这里主要记录一下项目中使用的配置，如果想要系统的学习如何使用这两个工具，可以参考下面的文章： Gulp入门教程 一小时包教会 —— webpack 入门指南 Gulp 和 Webpack 集成Gulp 和 Webpack 集成一个比较简单的方式就是将 Webpack 作为 Gulp 的一个 task，如下面的形式：12345678910111213141516171819202122var gulp = require("gulp");var webpack = require("webpack");gulp.task("webpack", function (callback) &#123; //webpack配置文件 var config = &#123; watch: true, entry: &#123; index: __dirname + '/src/js/index.js' &#125;, output: &#123; path: __dirname + '/dist/js', filename: '[name].js' &#125; //........ &#125;; webpack(config, function (err, stats) &#123; console.log(stats.toString()); &#125;);&#125;);gulp.task('default', [ 'webpack']); 下面我们分别介绍一下 gulp 和 webpack 的配置 Gulp 配置Gulp 中主要配置了两个任务：webpack 和 browserSync，这里主要说一下 browserSync。browserSync 主要用来自动刷新浏览器。首先我们配置需要监听的文件，当这些文件发生改变后，调用 browserSync 使浏览器自动刷新页面。下面是具体的配置1234567891011121314151617181920212223var gulp = require("gulp");var browserSync = require('browser-sync');// 添加 browserSync 任务gulp.task('browserSync', function () &#123; browserSync(&#123; server: &#123; baseDir: '.' &#125;, port: 80 &#125;)&#125;);// 配置需要监听的文件，当这些文件发生变化之后// 将调用 browserSync.reload 使浏览器自动刷新gulp.task("watch", function () &#123; gulp.watch("./**/*.html", browserSync.reload); gulp.watch("dist/**/*.js", browserSync.reload); gulp.watch("dist/**/*.css", browserSync.reload);&#125;);// 添加到默认任务gulp.task('default', ['browserSync', 'watch', 'webpack']); Webpack 配置我们使用 webpack 进行资源打包的工作，就是说将各种资源（css、js、图片等）交给 Webpack 进行管理，它会将资源整合压缩，我们在页面中只需引用压缩之后的文件即可。webpack 的基础配置文件如下所示123456789101112131415161718192021222324252627282930313233343536373839404142gulp.task("webpack", function (callback) &#123; //webpack配置文件 var config = &#123; // true 表示 监听文件的变化 watch: true, // 加载的插件项 plugins: [ new ExtractTextPlugin("../css/[name].css") ], // 入口文件配置 entry: &#123; index: __dirname + '/src/js/index.js' &#125;, // 输出文件配置 output: &#123; path: __dirname + '/dist/js', filename: '[name].js' &#125;, module: &#123; // 加载器配置，它告诉 Webpack 每一种文件需要采用什么加载器来处理， // 只有配置好了加载器才能处理相关的文件。 // test 用来测试是什么文件，loader 表示对应的加载器 loaders: [ &#123;test: /\.vue$/, loader: 'vue-loader'&#125; ] &#125;, resolve: &#123; // 模块别名定义，方便后续直接引用别名，无须多写长长的地址 // 例如下面的示例，使用时只需要写 import Vue from "vue" alias: &#123; vue: path.join(__dirname, "/node_modules/vue/dist/vue.min.js") &#125;, // 自动扩展文件后缀名，在引入文件时只需写文件名，而不用写后缀 extensions: ['.js', '.json', '.less', '.vue'] &#125; &#125;; webpack(config, function (err, stats) &#123; console.log(stats.toString()); &#125;);&#125;); webpack 的相关配置说明可以参考前面的给出的文章，下面说一下使用 webpack 2 遇到的坑： extract-text-webpack-pluginextract-text-webpack-plugin 会将 css 样式打包成一个独立的 css 文件，而不是直接将样式打包到 js 文件中。下面是使用方法12345678910111213141516171819&#123; plugins: [new ExtractTextPlugin("../css/[name].css")], module: &#123; loaders: [&#123; test: /\.css$/, loader: ExtractTextPlugin.extract(&#123; fallback: "style-loader", use: "css-loader" &#125;) &#125;, &#123; test: /\.less$/, loader: ExtractTextPlugin.extract(&#123; fallback: "style-loader", use: "css-loader!less-loader" &#125;) &#125; &#125;,&#125; 这里需要注意的地方就是，extract-text-webpack-plugin 在 webpack 1 和 webapck 2 中的安装方式不同，需要根据使用的 webpack 版本来安装：1234# for webpack 1npm install --save-dev extract-text-webpack-plugin# for webpack 2npm install --save-dev extract-text-webpack-plugin@beta 压缩文件使用 UglifyJsPlugin 插件可以压缩 css 和 js 文件，但是一开始时总是无法压缩文件，后来查阅了一下资料，大概是因为下面几个原因： uglifyjs-webpack-plugin 依赖于 uglify-js，而 uglify-js 默认不支持 ES6 语法，所以需要安装支持 ES6 语法的 uglify-js 1npm install mishoo/UglifyJS2#harmony --save webpack 2 中，UglifyJsPlugin 默认不压缩 loaders，如果要启动 loaders 压缩，需要加入下面的配置： 12345plugins: [ new webpack.LoaderOptionsPlugin(&#123; minimize: true &#125;)] 如果按上面的修改了还是不能压缩文件，可以试着将 node_modules 删除，然后重新安装依赖。 Vue本部分主要记录一下程序中用到的 Vue 语法，如果想要系统的学习一下 Vue.js，可以参考下面的文章： Vue.js 教程 HelloWorld我们首先来看一个最简单的 Vue 示例：123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;div id="app"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 每个 Vue 应用都会创建一个 Vue 的根实例，在根实例中需要传入 html 标签的 id，用来告诉 Vue 该标签中的内容需要被 Vue 来解析。上面是一个简单的数据绑定的示例，在运行实 &#123;{ message }} 会被解析为 “Hello Vue!”。 基础 本节参考自 Vue 中文文档，略有修改 在写 Vue 应用之前，我们要熟悉一下 Vue 的基本语法，主要包括数据绑定、事件处理、条件、循环等，下面我们依次看下相关的知识。 数据绑定Vue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。下面是 Vue.js 数据绑定的相关语法： 文本 数据绑定最常见的形式就是使用 “Muestache” 语法（双大括号），如下面的形式： 1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125; &lt;/span&gt; Muestache 标签会被解析为对应对象上的 msg 属性值。当 msg 属性发生改变之后，Muestache 标签处解析的内容也会随着更新。 通过使用 v-once 指令，我们可以执行一次性解析，即数据改变时，解析的内容不会随着更新。需要注意的是 v-once 会影响该节点上的所有数据绑定 1&lt;span v-once&gt;This will never change: &#123;&#123; msg &#125;&#125;&lt;/span&gt; Raw HTML 不论属性值是什么内容，Muestache 标签里的内容都会被解析为纯文本。如果希望将绑定的值解析为 HTML 格式，就需要使用 v-html 指令： 1&lt;div v-html="variable"&gt;&lt;/div&gt; 属性值 Mustache 语法不能用在 HTML 的属性中，如果想为属性绑定变量，需要使用 v-bind 指令： 1&lt;div v-bind:id="dynamicId"&gt;&lt;/div&gt; 假设 dynamicId=1，那么上面代码就会被解析为 1&lt;div id="1"&gt;&lt;/div&gt; 另外 v-bind 指令可以被缩写为 :，所以我们在程序中经常看到的是下面的语法形式： 123&lt;div :id="dynamicId"&gt;&lt;/div&gt;&lt;!-- 等价于 --&gt;&lt;div v-bind:id="dynamicId"&gt;&lt;/div&gt; 表达式 对于所有的数据绑定， Vue.js 都提供了完全的 JavaScript 表达式支持，如下面的形式： 1234567891011// 加法&#123;&#123; number + 1 &#125;&#125;// 三元表达式&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;// JS 库函数&#123;&#123; message.split('').reverse().join('') &#125;&#125;// 指令中使用表达式&lt;div v-bind:id="'list-' + id"&gt;&lt;/div&gt; 事件处理通过使用 v-on 指令可以监听 DOM 事件来触发 JS 处理函数，下面是一个完整的示例：123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;div id="app"&gt; &lt;button v-on:click="increase"&gt;增加 1&lt;/button&gt; &lt;p&gt;这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; counter: 0 &#125;, methods: &#123; increase: function() &#123; this.counter++; &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通常情况下，v-on 会被简写为 @，所以我们在程序中一般是看到下面的形式123&lt;button @click="increase"&gt;增加 1&lt;/button&gt;&lt;!-- 等价于 --&gt;&lt;button v-on:click="increase"&gt;增加 1&lt;/button&gt; 条件指令 v-if通过 v-if 指令我们可以根据某些条件来决定是否渲染内容，如下面的形式1&lt;h1 v-if="ok"&gt;Yes&lt;/h1&gt; 我们通常将 v-if 和 v-else 结合起来使用，如下所示：123456&lt;div v-if="Math.random() &gt; 0.5"&gt; Now you see me&lt;/div&gt;&lt;div v-else&gt; Now you don't&lt;/div&gt; 在 Vue 2.1.0 中新增了一个 v-else-if 指令，可以进行链式判断：123456789101112&lt;div v-if="type === 'A'"&gt; A&lt;/div&gt;&lt;div v-else-if="type === 'B'"&gt; B&lt;/div&gt;&lt;div v-else-if="type === 'C'"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 循环指令 v-for通过 v-for 指令，我们可以根据一组数据进行迭代渲染，下面是一个基本示例：12345&lt;ul id="example-1"&gt; &lt;li v-for="item in items"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 123456789var example1 = new Vue(&#123; el: '#example-1', data: &#123; items: [ &#123;message: 'Foo' &#125;, &#123;message: 'Bar' &#125; ] &#125;&#125;) 上面是一个简单的对数组迭代的示例，我们还可以针对对象进行迭代，如果只使用一个参数，就是针对对象的属性值进行迭代：12345&lt;ul id="repeat-object" class="demo"&gt; &lt;li v-for="value in object"&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 如果传入第二个参数，就是针对对象的属性值以及属性名进行迭代，注意这里二个参数表示的是属性名，也就是 key123&lt;div v-for="(value, key) in object"&gt; &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/div&gt; 如果再传入第三个参数，第三个参数就表示索引123&lt;div v-for="(value, key, index) in object"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/div&gt; 组件组件是 Vue.js 最强大的功能之一。组件可以扩展 HTML元素，封装可重用的代码。在我们的程序中包含两个组件：project 组件和 sidebar 组件，如下图所示。这里我们主要介绍单文件组件的使用，即将组件用到 html、js 和 css 都写在一个文件里，每个组件自成一个系统。 文件结构单文件组件一般使用 “.vue” 作为后缀名，一般的文件结构如下所示： project.vue 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; &#123;&#123; key &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data: function() &#123; return &#123; "key": "value" &#125; &#125;, methods: &#123; demoMethod: function() &#123; &#125; &#125; &#125;&lt;/script&gt;&lt;style lang="less"&gt; @import "xxx.less";&lt;/style&gt; export 将模块输出，default 表明使用文件名作为模块输出名，这就类似于将模块在系统中注册一下，然后其他模块才可用使用 import 引用该模块。 然后我们需要在主文件中注册该组件： index.js 12import project from '../components/project/project.vue'Vue.component("project", project); 当注册完成之后，就可以 html 中使用该组件了 index.html 1&lt;project&gt;&lt;/project&gt; 生命周期Vue 的要给组件会经历 创建 -&gt; 编译 -&gt; 挂载 -&gt; 卸载 -&gt; 销毁 等一系列事件，这些事件发生的前后都会触发一个相关的钩子（hook）函数，通过这些钩子函数，我们可以在事件发生的前后做一些操作，下面先看下官方给出的一个 Vue 对象的生命周期图，其中红框内标出的就是对应的钩子函数 下面是关于这些钩子函数的解释： hook 描述 beforeCreate 组件实例刚被创建，组件属性计算之前 created 组件实例创建完成，属性已绑定，但是 DOM 还未生成， $el 属性还不存在 beforeMount 模板编译/挂载之前 mounted 模板编译/挂载之后 mounted 模板编译/挂载之后（不保证组件已在 document 中） beforeUpdate 组件更新之前 updated 组件更新之后 activated for keep-alive，组件被激活时调用 deactivated for keep-alive，组件被移除时调用 beforeDestory 组件销毁前调用 destoryed 组件销毁后调用 下面是钩子函数的使用方法：1234567export default &#123; created: function() &#123; console.log("component created"); &#125;, data &#123;&#125;, methods: &#123;&#125;&#125; 父子组件通信父子组件通信可以使用 props down 和 events up 来描述，父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息，下面示意图： 图片来自 https://github.com/webplus/blog/issues/10 父组件向子组件传递数据通过使用 props，父组件可以把数据传递给子组件，这种传递是单向的，当父组件的属性发生变化时，会传递给子组件，但是不会反过来。下面是一个示例 comp.vue 12345678910&lt;template&gt; &lt;span&gt;&#123;&#123; message &#125;&#125;&#123;&#123; shortMsg &#125;&#125;&lt;/span&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: ["message", "shortMsg"], &#125;&lt;/script&gt; index.html 123456789101112131415&lt;div id="app"&gt; &lt;!-- 在这里将信息传递给子组件，:message 表示子组件中的变量名 --&gt; &lt;comp :message="hello" :short-msg = "hi"&gt;&lt;/comp&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; "hello": "Hello", "hi": "Hi" &#125; &#125;)&lt;/script&gt; 在上面的流程中，父组件首先将要传递的数据绑定到子组件的属性上，然后子组件在 props 中声明与绑定属性相同的变量名，就可以使用该变量了，需要注意的一点是如果变量采用驼峰的命名方式，在绑定属性时，就要将驼峰格式改为 - 连接的形式，如果上面所示 shortMsg -&gt; short-msg。 子组件向父组件通信如果子组件需要把信息传递给父组件，可以使用自定义事件： 使用 $on(eventName) 监听事件 使用 $emit(eventName) 触发事件 下面是一个示例： comp.vue 12345678910&lt;script&gt; export default &#123; methods: &#123; noticeParent: function() &#123; // 事件名，传输值 this.$emit('child_change', "value"); &#125; &#125; &#125;&lt;/script&gt; index.html 12345678910111213&lt;div id="app"&gt; &lt;comp @child_change="childChange"&gt;&lt;/comp&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', methods: &#123; childChange: function(msg) &#123; console.log("child change", msg); &#125; &#125; &#125;);&lt;/script&gt; 在上面的代码中，父组件通过 v-on 绑定了 child_chagne 事件，当 child_chagne 事件被触发时候就会调用 childChange 方法。在子组件中可以通过 $emit 触发 child_change 事件。这里需要注意的是事件名不用采用驼峰命名，也不要用 - 字符，可以使用下划线 _ 连接单词。 Event Bus 通信Event Bus 通信模式是一种更加通用的通信方式，它既可以用于父子组件也可以用于非父子组件。它的原理就是使用一个空的 Vue 实例作为中央事件总线，通过自定义事件的监听和触发，来完成通信功能，下面是一个示意图： 图片来自 https://github.com/webplus/blog/issues/10 下面我们来看一个具体的实例： 首先定义一个空的 Vue 实例，作为事件总线 EventBus.js 12import Vue from 'vue'export default new Vue() 在组件一中针对某个事件进行监听 comp1.vue 12345678910&lt;script&gt;import eventBus from "EventBus.js"export default &#123; created: function() &#123; eventBus.$on("change", function() &#123; console.log("change"); &#125;) &#125;&#125;&lt;/script&gt; 在组件二中触发相应事件完成通信 comp2.vue 12345678910&lt;script&gt;import eventBus from "EventBus.js"export default &#123; methods: &#123; notice: function() &#123; this.$emit('change', "value"); &#125; &#125;&#125;&lt;/script&gt; ES6 本节摘自 ECMAScript 6 入门 与 ES5 相比，ES6 提供了更加完善的功能和语法，程序中我们使用部分 ES6 语法，这里做一个简单的记录，如果想要系统的学习 ES6，可以参考下面的文章： ECMAScript 6 入门 letES6 新增了 let 命令，用于声明变量。使用 let 声明的变量具有块级作用域，所以在声明变量时，应该使用 let，而不是 var。1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 for of 循环ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for…of循环，作为遍历所有数据结构的统一的方法12345const arr = ['red', 'green', 'blue'];for(let v of arr) &#123; console.log(v); // red green blue&#125; Set 和 MapES6 引入了 Set 和 Map 结构。下面是两者的具体介绍 Set 属性 属性 描述 Set.prototype.size 返回Set实例的成员总数。 方法 方法名 描述 add(value) 添加某个值，返回Set结构本身。 delete(value) 删除某个值，返回一个布尔值，表示删除是否成功。 has(value) 返回一个布尔值，表示该值是否为Set的成员。 clear() 清除所有成员，没有返回值。 &nbsp; &nbsp; keys() 返回键名的遍历器 values() 返回键值的遍历器 entries() 返回键值对的遍历器 forEach() 使用回调函数遍历每个成员 使用示例：1234567const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125; Map 属性 属性 描述 Map.prototype.size 返回 Map 实例的成员总数。 方法 方法名 描述 set(key, value) set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。 get(key) 读取 key 对应的键值，如果找不到 key，返回 undefined。 has(key) 返回一个布尔值，表示某个键是否在当前 Map 对象之中。 delete(key) 删除某个键，返回true。如果删除失败，返回false。 clear() 清除所有成员，没有返回值。 &nbsp; &nbsp; keys() 返回键名的遍历器 values() 返回键值的遍历器 entries() 返回所有成员的遍历器 forEach() 遍历 Map 的所有成员。 使用示例：123456789const m = new Map();const o = &#123;p: 'Hello World'&#125;;m.set(o, 'content')m.get(o) // "content"m.has(o) // truem.delete(o) // truem.has(o) // false 参考文章 Vue 2.0 升（cai）级（keng）之旅 Vue 2.0开发实践（组件间通讯） Vuejs2.0 组件通讯总结]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java 并发】详解 ThreadPoolExecutor]]></title>
    <url>%2F2017%2F04%2F22%2F%E3%80%90Java-%E5%B9%B6%E5%8F%91%E3%80%91%E8%AF%A6%E8%A7%A3-ThreadPoolExecutor%2F</url>
    <content type="text"><![CDATA[前言线程池是并发中一项常用的优化方法，通过对线程复用，减少线程的创建，降低资源消耗，提高程序响应速度。在 Java 中我们一般通过 Exectuors 提供的工厂方法来创建线程池，但是线程池的最终实现类是 ThreadPoolExecutor，下面我们详细分析一下 ThreadPoolExecutor 的实现。 基本使用我们首先看下线程池的基本使用。在下面的代码中我们创建一个固定大小的线程池，该线程池中最多包含 5 个线程，当任务数量超过线程的数量时，就将任务添加到任务队列，等线程空闲之后再从任务队列中获取任务。1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * Created by Jikai Zhang on 2017/4/17. */public class ThreadPoolDemo &#123; static class WorkThread implements Runnable &#123; private String command; public WorkThread(String command) &#123; this.command = command; &#125; @Override public void run() &#123; System.out.println("Thread-" + Thread.currentThread().getId() + " start. Command=" + command); processCommand(); System.out.println("Thread-" + Thread.currentThread().getId() + " end."); &#125; private void processCommand() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; ExecutorService executor = Executors.newFixedThreadPool(5); for (int i = 0; i &lt; 10; i++) &#123; Runnable work = new WorkThread("" + i); executor.execute(work); &#125; executor.shutdown(); while (!executor.isTerminated()) &#123; &#125; System.out.println("Finish all threads."); &#125;&#125; 概述在分析线程池的具体实现之前，我们首先看下线程池具体的工作流程，只有先熟悉了流程，才能更好的理解线程池的实现。线程池一般都会关联一个任务队列，用来缓存任务，当线程执行完一个任务之后，会从任务队列中取下一个任务。ThreadPoolExecutor 中使用阻塞队列作为任务队列，当任务队列为空时，就会阻塞请求任务的线程。下面是 ThreadPoolExecutor 整体的图示： 图片来自 Java 并发编程的艺术 下面我们着重看下 ThreadPoolExecutor 添加任务和关闭线程池的流程。下图是 ThreadPoolExecutor 添加任务的流程： 我们首先看下添加任务的具体流程： 如果线程池中的线程数量少于 corePoolSize，那么直接创建一个新的线程（不论线程池中是否有空闲线程），然后把该任务分配给新建线程，同时将线程加入到线程池中。 如果线程池的线程数量大于等于 corePoolSize，就将任务添加到任务队列 如果任务队列已经饱和（对于有边界的任务队列），那么就看下线程池中的线程数量是否少于 maximumPoolSize，如果少于，就创建新的线程，将当前任务分配给新线程，同时将线程加入到线程池中。否则就对该任务执行 reject 策略。 在 ThreadPoolExecutor 中通过两个量来控制线程池的大小：corePoolSize 和 maximumPoolSize。corePoolSize 表示正常状态下线程池中应该持有的存活线程数量，maximumPoolSize 表示线程池可以持有的最大线程数量。当线程池中的线程数量不超过 corePoolSize 时，位于线程池中的线程被看作 core 线程，默认情况下，线程池不对 core 线程进行超时控制，也就是 core 线程会一直存活在线程池中，直到线程池被关闭（这里忽略线程异常关闭的情况）。当线程池中的线程数量超过 corePoolSize 时，额外的线程被看作非 core 线程，线程池会对这部分线程进行超时控制，当线程空闲一段时间之后会销毁该线程。非 core 线程主要用来处理某段时间并发任务特别多的情况，即之前的线程配置无法及时处理那么多的任务量，需要额外的线程来帮助。而当这批任务处理完成之后，额外的线程就有些多余了（线程越多占的资源越多），因此需要及时销毁。 ThreadPoolExecutor 定义线程数量上限是 2^29 - 1 = 536870911（后面会讲到为什么是这个数），同时用户可以自定义最大线程数量，ThreadPoolExecutor 处理时会选两者之间的较小值。当线程池的线程数量等于 maximumPoolSize 时，说明线程池也已经饱和了，此时对于新来的任务就要执行 reject 策略，JDK 中定义了四种拒绝策略： AbortPolicy：直接抛出异常，默认策略 CallerRunsPolicy：使用调用者所在的线程执行任务 DiscardOldestPolicy：丢弃当前任务队列中最前面的任务，并执行 execute 方法添加新任务 DiscardPolicy：直接丢弃任务 下面再看一下线程池的关闭。线程池的关闭分为两种：平缓关闭（shutdown）和立即关闭（shutdownNow）。当调用 shutdown 方法之后，线程池不再接受新的任务，但是仍然会将任务队列中已有的任务执行完毕。而调用 shutdownNow 方法之后，线程池不仅不再接受新的任务，也不会再执行任务队列中剩余的任务，同时会通过中断的方式尝试停止正在执行任务的线程（我们知道对于中断，线程可能响应也可能不响应，所以不能保证一定停止线程）。 具体实现下面我们从源码的角度分析一下 ThreadPoolExecutor 的实现。 WorkerThreadPoolExecutor 中每个线程都关联一个 Worker 对象，而 ThreadPool 里实际上保存的就是线程关联的 Worker 对象。 Worker 类对线程进行包装，它除了保存关联线程的信息，还保存一些其他的信息，如线程创建时分配的首任务，线程已完成的任务数量。Worker 实现了 Runnable 接口，创建线程时往 Thread 类传的参数就是该对象，所以线程创建后会执行 Worker 的 run 方法。同时 Worker 类还继承了 AbstractQueuedSynchronizer，使自身成为一个不可重入的互斥锁（以下称为 Worker 锁，注意 Worker 锁是不可重入的，也就是说该锁只能被一个线程获取一次），因此每个线程实际上也关联了一个互斥锁。当线程执行任务时，需要首先获得关联的 Worker 锁，执行完任务之后再释放该锁。Worker 锁的主要作用是为了平缓关闭线程池时，判断线程是否空闲（根据能否获得 Worker 锁），后续会详细讲解。下面是 Worker 类的实现，我们只保留了一些必要的内容： 12345678910111213141516171819202122232425262728293031323334353637383940private final class Worker extends AbstractQueuedSynchronizer implements Runnable &#123; // 当前 Worker 对象关联的线程 final Thread thread; // 线程创建后的初始任务 Runnable firstTask; // 线程完成的任务数量 volatile long completedTasks; /** * Creates with given first task and thread from ThreadFactory. * @param firstTask the first task (null if none) */ Worker(Runnable firstTask) &#123; // 只有 state 为 0，线程才能获取到 Worker 锁，这里将 state 设为 -1， // 表明任何线程都无法获取锁，在 shutdown 方法中，如果要中断线程，需要首先获得线程 // 关联的 Worker 锁，而 shutdownNow 中断线程之前，会首先判断 state 是否大于等于 0 // 所以这里将 state 设为 -1，可以防止当前线程被中断 setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; // 创建线程时将自身传入 this.thread = getThreadFactory().newThread(this); &#125; /** Delegates main run loop to outer runWorker */ // 线程创建之后会运行该方法 public void run() &#123; runWorker(this); &#125; // 只要线程启动了，就中断线程，用于 shutdownNow 方法 void interruptIfStarted() &#123; Thread t; if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123;&#125; &#125; &#125;&#125; 我们看到在 Worker 的构造函数中将 state 设为了 -1，注释里给出的解释是：禁止中断直到执行了 runWorker 方法。其实这里包含了两个问题：1.为什么要等到执行了 runWorker 方法 2.怎样禁止中断。对于第一个问题，我们知道中断是针对运行的线程，当线程创建之后只有调用了 start 方法，线程才真正运行，而 start 方法的调用是在 runWorker 方法中的，也就是有只有执行了 runWorker 方法，线程才真正启动。对于第二个问题，这个主要是针对 shutdown 和 shutdownNow 方法的。在 shutdown 方法中，中断线程之前会首先尝试获取线程的 Worker 锁，只有获得了 Worker 锁才对线程进行中断。而获得 Worker 锁的前提是 Worker 的锁的状态变量 state 为 0，当 state 设为 -1 之后，任何线程都无法获得该锁，那么也就无法对线程执行中断操作。而在 shutdownNow 方法中，会调用 Worker 的 interruptIfStarted 方法来中断线程，而 interruptIfStarted 方法只有在 state &gt;= 0 时才会中断线程，所以将 state 设为 -1 可以防止线程被提前中断。当执行 runWorker 方法时，会为传入 Worker 对象执行 unlock 操作（也就是将 state 加 1），使 Worker 对象的 state 变为 0，这样就使线程处于可被中断的状态了。 状态变量在 ThreadPoolExecutor 中定义了一个 AtomicInteger 类型的变量 ctl，用来保存线程池的状态和线程数量信息。下面是该变量的定义：1private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); ctl 使用低 29 位保存线程的数量（这就是线程池最大线程数量为 2^29-1 的原因），高 3 位保存线程池的状态。为了提取出这两个信息，ThreadPoolExecutor 定义了一个低 29 位全为 1 的变量 CAPACITY，通过和 CAPACITY 进行 &amp; 运算可以获得线程的数量，通过和 ~CAPACITY 进行 &amp; 运算可以获得线程池的状态，下面是程序中的实现：123456789101112131415// 存储线程数量的 bit 位数，这里是 29private static final int COUNT_BITS = Integer.SIZE - 3;// 用于提取线程池的运行状态以及线程数量，低 29 位全为 1，高 3 位为0private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1;// 获得线程池的运行状态private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY;&#125;// 获得线程的数量private static int workerCountOf(int c) &#123; return c &amp; CAPACITY;&#125; ThreadPoolExecutor 中为线程池定义了五种状态： RUNNING：正常状态，接受新的任务，并处理任务队列中的任务 SHUTDOWN：不接受新的任务，但是处理已经在任务队列中的任务 STOP： 不接受新的任务，也不处理已经在任务队列中的任务，同时会尝试停止正在执行任务的线程 TIDYING： 线程池和任务队列都为空，该状态下线程会执行 terminated() 方法 TERMINATED：terminated() 方法执行完毕 下面是 JDK 中关于这 5 个变量的定义：1234567891011121314// 11100000000000000000000000000000 -536870912private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;// 00000000000000000000000000000000 0private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;// 00100000000000000000000000000000 536870912private static final int STOP = 1 &lt;&lt; COUNT_BITS;// 01000000000000000000000000000000 1073741824private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;// 01100000000000000000000000000000 1610612736private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; 下面是各状态之间的转换： RUNNING -&gt; SHUTDOWN：调用了 shutdown() 方法 （perhaps implicitly in finalize()） (RUNNING or SHUTDOWN) -&gt; STOP：调用了shutdownNow() 方法 SHUTDOWN -&gt; TIDYING：线程池和任务队列都为空 STOP -&gt; TIDYING：线程池为空 TIDYING -&gt; TERMINATED：执行完 terminated() 方法 添加任务通过 execute 或者 submit 方法都可以向线程池中添加一个任务，submit 会返回一个 Future 对象来获取线程的返回值，下面是 submit 方法的实现：123456public Future &lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture &lt;Void&gt; ftask = newTaskFor(task, null); execute(ftask); return ftask;&#125; 我们看到 submit 中只是将 Runnable 对象包装了一下，最终还是调用了 execute 方法。下面我们看下 execute 方法的实现：123456789101112131415161718192021222324252627282930313233343536373839404142public void execute(Runnable command) &#123; // command 不能为 null if (command == null) throw new NullPointerException(); int c = ctl.get(); // 线程数量少于 corePoolSize，会创建一个新的线程执行该任务 if (workerCountOf(c) &lt; corePoolSize) &#123; // true 表示当前添加的线程为核心线程 if (addWorker(command, true)) return; c = ctl.get(); &#125; // 线程数量大于等于 corePoolSize，首先尝试将任务添加到任务队列 // workQueue.offer 会将任务添加到队列尾部 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; // 重新检查状态 int recheck = ctl.get(); // 如果发现当前线程池不是处于 Running 状态，就移除之前的任务 // 移除任务过程有锁保护 if (!isRunning(recheck) &amp;&amp; remove(command)) &#123; reject(command); &#125; else if (workerCountOf(recheck) == 0) &#123; // workerCountOf 用来统计当前的工作线程数量，程序执行到这里，有下面两种可能： // 1. 当前线程池处于 Running 状态，但是工作线程数量为 0， // 需要创建新的线程 // 2. 移除任务失败，但是工作线程数量为 0， // 需要创建新的线程来完成移除失败的任务 // // 因为前面对任务做了判断，所以正常情况下向 addWorker 里传入的任务 // 不可能为 null，这里传入 null 是告诉 addWorker 需要创建新的线程， // 在 addWorker 里对 null 有专门的处理逻辑 addWorker(null, false); &#125; // 下面的 else 说明线程池不是 Running 状态或者任务队列满了， &#125; else if (!addWorker(command, false)) &#123; // 这里说明线程池不是 Running 状态或者线程池饱和了 reject(command); &#125;&#125; 在前面我们提到了线程池添加任务的流程，这里再重述一下 如果线程池的线程数量少于 corePoolSize，则新建一个线程，执行当前任务，并将该任务加入到线程池 如果线程池中的线程数量大于等于 corePoolSize，则首先将任务添加到任务队列 如果任务队列已满，则继续创建线程，如果线程池达到了饱和值 maximumPoolSize，则调用 reject 策略处理该任务。 addWorker 方法会创建并启动线程，当线程池不处于 Running 状态并且传入的任务不为 null，addWorker 就无法成功创建线程。下面看下它的具体实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private boolean addWorker(Runnable firstTask, boolean core) &#123; // retry 类似于 goto，continue retry 跳转到 retry 定义， // 而 break retry 跳出 retry retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // 我们在下面详细讲解该条件 if (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; !workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); // 线程数量大于系统规定的最大线程数或者大于 corePoolSize/maximumPoolSize // 表明线程池中无法添加新的线程，这里 wc &gt;= CAPACITY 为了防止 corePoolSize // 或者 maximumPoolSize 大于CAPACITY if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) &#123; return false; &#125; // 使用 CAS 方式将线程数量增加，如果成功就跳出 retry if (compareAndIncrementWorkerCount(c)) &#123; break retry; &#125; c = ctl.get(); // Re-read ctl // 如果线程池运行状态发生了改变就从 retry（外层循环）处重新开始， if (runStateOf(c) != rs) continue retry; // 程序执行到这里说 CAS 没有成功，那么就再次执行 CAS &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; // 创建 work w = new Worker(firstTask); final Thread t = w.thread; // t != null 说明线程创建成功了 if (t != null) &#123; // 程序用一个 HashSet 存储线程，而 HashSet 不是线程的安全的， // 所以将线程加入 HashSet 的过程需要加锁。 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int rs = runStateOf(ctl.get()); // 1. rs &lt; SHUTDOWN 说明程序在运行状态 // 2. rs == SHUTDOWN 说明当前线程处于平缓关闭状态，而 firstTask == null // 说明当前创建的线程是为了处理任务队列中剩余的任务（故意传入 null） if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; // 线程是存活状态说明线程提前开始了。 if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; // 启动线程 t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (!workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125; 这里我们着重看下返回 false 的条件：123if (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; !workQueue.isEmpty()))// 等价于if(rs &gt;= SHUTDOWN &amp;&amp; (rs != SHUTDOWN || firstTask != null || workQueue.isEmpty())) 我们依次看下上面的条件： rs &gt;= SHUTDOWN &amp;&amp; rs != SHUTDOWN：说明线程池处于 STOP，TIDYING 或者 TERMINATED 状态下，处于这三种状态说明线程池处理完了所有任务或者不再执行剩余的任务，可以直接返回 rs == SHUTDOWN &amp;&amp; firstTask != null：如果上面的条件不成立，说明当前线程池的状态一定是处于 SHUTDOWN 状态，在 execute 方法中，我们提到了如果传入 null，说明创建线程是为了执行队列中剩余的任务（此时线程池中没有工作线程），这时就不应该返回。而如果 firstTask != null，说明不是为了处理队列中剩余的任务，可以返回。 rs == SHUTDOWN &amp;&amp; workQueue.isEmpty()：说经任务队列中的任务已经全部执行完了，无需创建新的线程，可以返回。 当创建了线程并成功启动之后，会执行 Worker 的 run 方法，而该方法最终调用了 ThreadPoolExecutor 的 runWorker 方法，并且将自身作为参数传进去了，下面是 runWorker 方法的实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; // 这里将 Worker 中的 state 设为 0，以便其他线程可以获得锁 // 从而可以中断当前线程 w.unlock(); // allow interrupts // 用来标记线程是正常退出循环还是异常退出 boolean completedAbruptly = true; try &#123; // 如果任务不为空，说明是刚创建线程，如果任务为空，则从队列中取任务 // 如果队列没有任务，线程就会阻塞在这里 while (task != null || (task = getTask()) != null) &#123; w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; // 任务执行之前做一些处理，空函数，需要用户定义处理逻辑 beforeExecute(wt, task); Throwable thrown = null; try &#123; task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; // 因为 runnable 方法不能抛出 checkedException ，所以这里 // 将异常包装成 Error 抛出 throw new Error(x); &#125; finally &#123; // 任务执行完之后做一些处理，默认空函数 afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125;&#125; 在上面的代码中，第一个 if 判断的逻辑有点难理解，我们将它拿出分析一下。1234567private static boolean runStateAtLeast(int c, int s) &#123; return c &gt;= s;&#125;if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); 这段 if 代码块的功能有两个： 如果当前线程池的状态小于 STOP，也就是处于 RUNNING 或者 SHUTDOWN 状态，要保证线程池中的线程处于非中断状态 如果当前线程池的状态大于等于 STOP，也就是处于 STOP，TIDYING 或者 TERMINATED 状态，要保证线程池中的线程处于中断状态 上面的 if 代码中括号比较多，我们先将其分为两个大条件： runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP)) &amp;&amp; !wt.isInterrupted() 我们先看第二个条件：!wt.isInterrupted()，该条件说明当前线程没有被中断，只有在线程没有被中断的前提下，才有可能对线程执行中断操作。然后我们将第一个大条件再进行拆分，可以分为下面两个条件： runStateAtLeast(ctl.get(), STOP) || Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP) 我们先看第一个条件，该条件说明线程处于 STOP 以及之后的状态，线程应该被中断。如果该条件不成立，说明当前线程不应该被中断，那么会调用 Thread.interrupted() 方法，该方法会首返回线程的中断状态，然后重置线程中断状态（设为 false），如果中断状态本来就为 false，那么就可以就可以跳出 if 代码块了，但是如果中断状态是 true，说明线程被中断过了，此时我们就要判断线程的中断是不是由 shutdownNow 方法（并发调用，该方法会中断线程池的线程，并修改线程池状态为 STOP，后面会讲到）造成的，所以我们需要再检查一下线程的状态，如果发现当前线程池已经变为 STOP 或者之后的状态，说明确实是由 shutdownNow 方法造成的，需要重新对线程进行中断，如果不是那就不需要再中断线程了。 我们看到在 runWorker 里会一直循环调用 getTask 来获取任务，下面来看下 getTask 的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * getTask 返回 null，说明当前线程需要被回收了 */private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // rs &gt;= SHUTDOWN 说明当前线程池至少处于待关闭状态，不再接受新的任务 // 1. rs &gt;= STOP： 说明不需要在再处理任务了（即便有任务） // 2. workQueue.isEmpty(): 说明任务队列中剩余的任务已经处理完了 if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); // Are workers subject to culling? // timed 用于判断是否需要对线程进行超时控制 // 1. allowCoreThreadTimeOut: 为 true 说明可以对 core 线程进行超时控制 // 2. wc &gt; corePoolSize: 说明线程池中有非 core 线程 boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; // 1. wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut) // 线程数量大于 maximumPoolSize 值了 或者 允许超时控制并且超时了 // 2. wc &gt; 1 || workQueue.isEmpty() // 线程中活动线程的数量大于 1 或者 任务队列为空（不需要在留线程执行剩余的任务了） // 如果上面 1 和 2 都成立，就使用 CAS 将线程数量减 1 并返回 null 回收当前线程 // 如果 CAS 失败了就重试 if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; // 如果允许超时控制，则执行 poll 方法，该方法响应超时，当 keepAliveTime 时间内 // 仍然没有获取到任务，就返回 null。take 方法不响应超时操作，当获取不到任务时会一直等待。 // 另外不管 poll 还是 take 方法都会响应中断，如果没有新的任务添加到队列中 // 会直接抛出 InterruptedException Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; // 执行到这里说明超时了 timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125; 当 getTask 返回 null 的时候说明线程需要被回收了，我们总结一下在 getTask 中返回 null 的情况： 线程池总工作线程数量大于 maximumPoolSize（一般是由于我们调用 setMaximumPoolSize 方法重新设置了 maximumPoolSize） 线程池已经被停止 （状态 &gt;= STOP） 线程池处于 SHUTDOWN 状态，并且任务队列为空 线程在等待任务时超时 我们将 runWorker 和 getTask 结合起来看，整个流程就比较明朗了： 通过 while 循环不断的从任务队列中获取任务，如果当前任务队列中没有任务，就阻塞线程。如果 getTask 返回 null，表明当前线程应该被回收，执行回收线程的逻辑。 如果成功获取任务，首先判断线程池的状态，根据线程池状态设置当前线程的中断状态 在执行任务之前做一些预处理（用户实现） 执行任务 在执行任务之后做一些后处理（用户实现） 上面两个方法是整个线程池中比较核心的部分，在这两个方法中，完成了任务获取与阻塞线程的工作。下面是线程 提交 -&gt; 处理任务 -&gt; 回收 的流程图： 下面我们再看下 processWorkerExit 方法，该方法主要用来完成线程的回收工作：1234567891011121314151617181920212223242526272829303132333435363738private void processWorkerExit(Worker w, boolean completedAbruptly) &#123; // 如果 completedAbruptly 为 true，说明线程是由于抛出异常而跳出循环的， // 没有正确执行 getTask 中减少线程数量的逻辑，所以这里要将线程数量减一 if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted decrementWorkerCount(); final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // 更新已完成的任务数量，并移除工作线程 completedTaskCount += w.completedTasks; workers.remove(w); &#125; finally &#123; mainLock.unlock(); &#125; // 尝试终止线程池 tryTerminate(); int c = ctl.get(); // 如果线程状态是 SHUTDOWN 或者 RUNNING，需要保证线程中的最少线程数量 // 1. 如果线程是由于抛出异常而结束的，直接添加一个线程 // 2. 如果线程是正常结束的 // * 如果允许对 core 线程进行超时控制，并且任务队列中有任务 // 则保证线程数量大于等于 1 // * 如果不允许对 core 进行超时控制，则保证线程数量大于等于 corePoolSize if (runStateLessThan(c, STOP)) &#123; if (!completedAbruptly) &#123; int min = allowCoreThreadTimeOut ? 0 : corePoolSize; if (min == 0 &amp;&amp; !workQueue.isEmpty()) min = 1; if (workerCountOf(c) &gt;= min) return; // replacement not needed &#125; addWorker(null, false); &#125;&#125; 我们看到 processWorkerExit 中调用了 tryTerminate 方法，该方法主要用来终止线程池。如果线程池满足终止条件，首先将线程池状态设为 TIDYING，然后执行 terminated 方法，最后将线程池状态设为 TERMINATED。在 shutdown 和 shutdownNow 方法中也会调用该方法 。12345678910111213141516171819202122232425262728293031323334353637383940final void tryTerminate() &#123; for (;;) &#123; int c = ctl.get(); // 如果出现下面三种情况，就不执行终止线程池的逻辑，直接返回 // 1. 当前线程池处于 RUNNING 状态，不能停止 // 2. 当前线程池状态为 TIDYING 或者 TERMINATED，不需要停止 // 3. 当前线程池状态为 SHUTDOWN 并且任务队列不为空 if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; !workQueue.isEmpty())) return; // 判断工作线程的数量是否为 0 if (workerCountOf(c) != 0) &#123; // Eligible to terminate // 如果工作线程数量不为 0，就尝试中断正在线程池中的空闲线程 // ONLY_ONE 说明只尝试中断线程池中第一个线程（不管线程空不空闲） interruptIdleWorkers(ONLY_ONE); return; &#125; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // 将线程状态设为 TIDYING，如果设置不成功说明线程池的状态发生了变化，需要重试 // 这里线程池状态从 TIDYING 到 TERMINATED 状态转换是原子的 if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123; try &#123; // 执行 terminated 方法（默认空方法） terminated(); &#125; finally &#123; // 将线程状态设为 TERMINATED ctl.set(ctlOf(TERMINATED, 0)); termination.signalAll(); &#125; return; &#125; &#125; finally &#123; mainLock.unlock(); &#125; // else retry on failed CAS &#125;&#125; 在 tryTerminate 方法中， 如果满足下面两个条件，就将线程池状态设为 TERMINATED： 线程池状态为 SHUTDOWN 并且线程池和任务队列均为空 线程池状态为 STOP 并且线程池为空 如果线程池处于 SHUTDOWN 或者 STOP 状态，但是工作线程不为空，那么 tryTerminate 会尝试去中断线程池中的一个线程，这样做主要是为了防止 shutdown 的中断信号丢失（我们在 shutdown 方法处再详细讨论）。下面看下 interruptIdleWorkers 方法，该方法主要中断 空闲 线程。123456789101112131415161718192021222324private void interruptIdleWorkers(boolean onlyOne) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; for (Worker w: workers) &#123; Thread t = w.thread; // 首先看当前线程是否已经中断，如果没有中断，就看线程是否处于空闲状态 // 如果能获得线程关联的 Worker 锁，说明线程处于空闲状态，可以中断 // 否则说明线程不能中断 if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123;&#125; finally &#123; w.unlock(); &#125; &#125; // 如果 onlyOne 为 true，只尝试中断第一个线程 if (onlyOne) break; &#125; &#125; finally &#123; mainLock.unlock(); &#125;&#125; 关闭线程池通过 shutdown 和 shutdownNow 我们可以关闭线程池，关于两者的区别在前面已经提到了，这里不再赘述。我们首先看下 shutdown 方法：1234567891011121314151617public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // 检查当前线程是否有关闭线程池的权限 checkShutdownAccess(); // 将线程池状态设为 SHUTDOWN advanceRunState(SHUTDOWN); // 中断线程，这里最终调用 interruptIdleWorkers(false); interruptIdleWorkers(); // hook 方法，默认为空，让用户在线程池关闭时可以做一些操作 onShutdown(); // hook for ScheduledThreadPoolExecutor &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate();&#125; 在前面我们知道 interruptIdleWorkers 会先检查线程是否是空闲状态，如果发现线程不是空闲状态，才会中断线程。而这时中断线程的主要目的是让在任务队列中阻塞的线程醒过来。考虑下面的情况，如果执行 interruptIdleWorkers 时，线程正在运行，所以没有被中断，但是线程执行完任务之后，任务队列恰好为空，线程就会处于阻塞状态，而此时 shutdown 已经执行完 interruptIdleWorkers 操作了（即线程错过了 shutdown 的中断信号），如果没有额外操作，线程会一直处于阻塞状态。所以为了防止这种情况，在 tryTerminate() 中也增加了 interruptIdleWorkers 操作，主要就是为了弥补 shutdown 中丢失的信号。 最后我们再看下 shutdownNow 方法：12345678910111213141516171819public List &lt; Runnable &gt; shutdownNow() &#123; List &lt; Runnable &gt; tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // 检查线程是否具有关闭线程池的权限 checkShutdownAccess(); // 更改线程状态 advanceRunState(STOP); // 中断线程 interruptWorkers(); // 清除任务队列，并将任务返回 tasks = drainQueue(); &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate(); return tasks;&#125; 然后我们看下 interruptWorkers 方法：1234567891011private void interruptWorkers() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // 不管线程是否空闲都执行中断 for (Worker w: workers) w.interruptIfStarted(); &#125; finally &#123; mainLock.unlock(); &#125;&#125; 从上面的代码中我们可以看到在 interruptWorkers 方法中，只要线程开始了，就对线程执行中断，所以 shutdownNow 的中断信号不会丢失。最后我们再看下 drainQueue 方法，该方法主要作用是清空任务队列，并将队列中剩余的任务返回。123456789101112131415private List &lt;Runnable&gt; drainQueue() &#123; BlockingQueue &lt;Runnable&gt; q = workQueue; ArrayList &lt;Runnable&gt; taskList = new ArrayList &lt; Runnable &gt; (); // 该方法会将阻塞队列中的所有项添加到 taskList 中 // 然后清空任务队列，该方法是线程安全的 q.drainTo(taskList); if (!q.isEmpty()) &#123; // 将 List 转换为 数组，传入的 Runnable[0] 用来说明是转为 Runnable 数组 for (Runnable r: q.toArray(new Runnable[0])) &#123; if (q.remove(r)) taskList.add(r); &#125; &#125; return taskList;&#125; 线程池监控 本节摘自 深入理解Java线程池：ThreadPoolExecutor 通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用 getTaskCount：线程池已经执行的和未执行的任务总数； getCompletedTaskCount：线程池已完成的任务数量，该值小于等于taskCount； getLargestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了maximumPoolSize； getPoolSize：线程池当前的线程数量； getActiveCount：当前线程池中正在执行任务的线程数量。 通过这些方法，可以对线程池进行监控，在ThreadPoolExecutor类中提供了几个空方法，如beforeExecute方法，afterExecute方法和terminated方法，可以扩展这些方法在执行前或执行后增加一些新的操作，例如统计线程池的执行任务的时间等，可以继承自ThreadPoolExecutor来进行扩展。 参考文章 Java线程池架构(一)原理和源码解析 Java线程池–原理及源码分析 http://blog.csdn.net/qq_35101189/article/details/55804778 http://zhanjindong.com/2015/03/30/java-concurrent-package-ThreadPoolExecutor 深入理解Java线程池：ThreadPoolExecutor]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java并发】详解 AbstractQueuedSynchronizer]]></title>
    <url>%2F2017%2F04%2F15%2F%E3%80%90Java-%E5%B9%B6%E5%8F%91%E3%80%91%E8%AF%A6%E8%A7%A3-AbstractQueuedSynchronizer%2F</url>
    <content type="text"><![CDATA[前言队列同步器 AbstractQueuedSynchronizer（以下简称 AQS），是用来构建锁或者其他同步组件的基础框架。它使用一个 int 成员变量来表示同步状态，通过 CAS 操作对同步状态进行修改，确保状态的改变是安全的。通过内置的 FIFO （First In First Out）队列来完成资源获取线程的排队工作。更多关于 Java 多线程的文章可以转到 这里 AQS 和 synchronized在介绍 AQS 的使用之前，需要首先说明一点，AQS 同步和 synchronized 关键字同步（以下简称 synchronized 同步）是采用的两种不同的机制。首先看下 synchronized 同步，synchronized 关键字经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码需要关联到一个监视对象，当线程执行 monitorenter 指令时，需要首先获得获得监视对象的锁，这里监视对象锁就是进入同步块的凭证，只有获得了凭证才可以进入同步块，当线程离开同步块时，会执行 monitorexit 指令，释放对象锁。 在 AQS 同步中，使用一个 int 类型的变量 state 来表示当前同步块的状态。以独占式同步（一次只能有一个线程进入同步块）为例，state 的有效值有两个 0 和 1，其中 0 表示当前同步块中没有线程，1 表示同步块中已经有线程在执行。当线程要进入同步块时，需要首先判断 state 的值是否为 0，假设为 0，会尝试将 state 修改为 1，只有修改成功了之后，线程才可以进入同步块。注意上面提到的两个条件： state 为 0，证明当前同步块中没有线程在执行，所以当前线程可以尝试获得进入同步块的凭证，而这里的凭证就是是否成功将 state 修改为 1（在 synchronized 同步中，我们说的凭证是对象锁，但是对象锁的最终实现是否和这种方式类似，没有找到相关的资料） 成功将 state 修改为 1，通过使用 CAS 操作，我们可以确保即便有多个线程同时修改 state，也只有一个线程会修改成功。关于 CAS 的具体解释会在后面提到。 当线程离开同步块时，会修改 state 的值，将其设为 0，并唤醒等待的线程。所以在 AQS 同步中，我们说线程获得了锁，实际上是指线程成功修改了状态变量 state，而线程释放了锁，是指线程将状态变量置为了可修改的状态（在独占式同步中就是置为了 0），让其他线程可以再次尝试修改状态变量。在下面的表述中，我们说线程获得和释放了锁，就是上述含义， 这与 synchronized 同步中说的获得和释放锁的含义不同，需要区别理解。 基本使用 本节摘自 Java 并发编程的艺术 AQS 的设计是基于模板方法的，使用者需要继承 AQS 并重写指定的方法。在后续的流程中，AQS 提供的模板方法会调用重写的方法。一般来说，我们需要重写的方法主要有下面 5 个： 方法名称 描述 protected boolean tryAcquire(int) 独占式获取锁，实现该方法需要查询当前状态并判断同步状态是否和预期值相同，然后使用 CAS 操作设置同步状态 protected boolean tryRelease(int) 独占式释放锁，实际也是修改同步变量 protected int tryAcquireShared(int) 共享式获取锁，返回大于等于 0 的值，表示获取锁成功，反之获取失败 protected boolean tryReleaseShared(int) 共享式释放锁 protected boolean isHeldExclusively() 判断调用该方法的线程是否持有互斥锁 在自定义的同步组件中，我们一般会调用 AQS 提供的模板方法。AQS 提供的模板方法基本上分为 3 类： 独占式获取与释放锁、共享式获取与释放锁以及查询同步队列中的等待线程情况。下面是相关的模板方法： 方法名称 描述 void acquire(int) 独占式获取锁，如果当前线程成功获取锁，那么方法就返回，否则会将当前线程放入同步队列等待。该方法会调用重写的 tryAcquire(int arg) 方法判断是否可以获得锁 void acquireInterruptibly(int) 和 acquire(int) 相同，但是该方法响应中断，当线程在同步队列中等待时，如果线程被中断，会抛出 InterruptedException 异常并返回。 boolean tryAcquireNanos(int, long) 在 acquireInterruptibly(int) 基础上添加了超时控制，同时支持中断和超时，当在指定时间内没有获得锁时，会返回 false，获取到了返回 true void acquireShared(int) 共享式获得锁，如果成功获得锁就返回，否则将当前线程放入同步队列等待，与独占式获取锁的不同是，同一时刻可以有多个线程获得共享锁，该方法调用 tryAcquireShared(int) acquireSharedInterruptibly(int) 与 acquireShared(int) 相同，该方法响应中断 tryAcquireSharedNanos(int, long) 在 acquireSharedInterruptibly(int) 基础上添加了超时控制 boolean release(int) 独占式释放锁，该方法会在释放锁后，将同步队列中第一个等待节点唤醒 boolean releaseShared(int) 共享式释放锁 Collection getQueuedThreads() 获得同步队列中等待的线程集合 自定义组件通过使用同步器提供的模板方法来实现自己的同步语义。下面我们通过两个示例，看下如何借助于 AQS 来实现锁的同步语义。我们首先实现一个独占锁（排它锁），独占锁就是说在某个时刻内，只能有一个线程持有独占锁，只有持有锁的线程释放了独占锁，其他线程才可以获取独占锁。下面是具体实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.AbstractQueuedSynchronizer;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;/* * Created by Jikai Zhang on 2017/4/6. * &lt;p&gt; * 自定义独占锁 */public class Mutex implements Lock &#123; // 通过继承 AQS，自定义同步器 private static class Sync extends AbstractQueuedSynchronizer &#123; // 当前线程是否被独占 @Override protected boolean isHeldExclusively() &#123; return getState() == 1; &#125; // 尝试获得锁 @Override protected boolean tryAcquire(int arg) &#123; // 只有当 state 的值为 0，并且线程成功将 state 值修改为 1 之后，线程才可以获得独占锁 if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; @Override protected boolean tryRelease(int arg) &#123; // state 为 0 说明当前同步块中没有锁了，无需释放 if (getState() == 0) &#123; throw new IllegalMonitorStateException(); &#125; // 将独占的线程设为 null setExclusiveOwnerThread(null); // 将状态变量的值设为 0，以便其他线程可以成功修改状态变量从而获得锁 setState(0); return true; &#125; Condition newCondition() &#123; return new ConditionObject(); &#125; &#125; // 将操作代理到 Sync 上 private final Sync sync = new Sync(); @Override public void lock() &#123; sync.acquire(1); &#125; @Override public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; @Override public boolean tryLock() &#123; return sync.tryAcquire(1); &#125; @Override public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(time)); &#125; @Override public void unlock() &#123; sync.release(1); &#125; @Override public Condition newCondition() &#123; return sync.newCondition(); &#125; public boolean hasQueuedThreads() &#123; return sync.hasQueuedThreads(); &#125; public boolean isLocked() &#123; return sync.isHeldExclusively(); &#125; public static void withoutMutex() throws InterruptedException &#123; System.out.println("Without mutex: "); int threadCount = 2; final Thread threads[] = new Thread[threadCount]; for (int i = 0; i &lt; threads.length; i++) &#123; final int index = i; threads[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 100000; j++) &#123; if (j % 20000 == 0) &#123; System.out.println("Thread-" + index + ": j =" + j); &#125; &#125; &#125; &#125;); &#125; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i].start(); &#125; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i].join(); &#125; &#125; public static void withMutex() &#123; System.out.println("With mutex: "); final Mutex mutex = new Mutex(); int threadCount = 2; final Thread threads[] = new Thread[threadCount]; for (int i = 0; i &lt; threads.length; i++) &#123; final int index = i; threads[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; mutex.lock(); try &#123; for (int j = 0; j &lt; 100000; j++) &#123; if (j % 20000 == 0) &#123; System.out.println("Thread-" + index + ": j =" + j); &#125; &#125; &#125; finally &#123; mutex.unlock(); &#125; &#125; &#125;); &#125; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i].start(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; withoutMutex(); System.out.println(); withMutex(); &#125;&#125; 程序的运行结果如下面所示。我们看到使用了 Mutex 之后，线程 0 和线程 1 不会再交替执行，而是当一个线程执行完，另外一个线程再执行。1234567891011121314151617181920212223Without mutex:Thread-0: j =0Thread-1: j =0Thread-0: j =20000Thread-1: j =20000Thread-0: j =40000Thread-1: j =40000Thread-0: j =60000Thread-1: j =60000Thread-1: j =80000Thread-0: j =80000With mutex:Thread-0: j =0Thread-0: j =20000Thread-0: j =40000Thread-0: j =60000Thread-0: j =80000Thread-1: j =0Thread-1: j =20000Thread-1: j =40000Thread-1: j =60000Thread-1: j =80000 下面在看一个共享锁的示例。在该示例中，我们定义两个共享资源，即同一时间内允许两个线程同时执行。我们将同步变量的初始状态 state 设为 2，当一个线程获取了共享锁之后，将 state 减 1，线程释放了共享锁后，将 state 加 1。状态的合法范围是 0、1 和 2，其中 0 表示已经资源已经用光了，此时线程再要获得共享锁就需要进入同步序列等待。下面是具体实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.AbstractQueuedSynchronizer;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;/** * Created by Jikai Zhang on 2017/4/9. * &lt;p&gt; * 自定义共享锁 */public class TwinsLock implements Lock &#123; private static class Sync extends AbstractQueuedSynchronizer &#123; public Sync(int resourceCount) &#123; if (resourceCount &lt;= 0) &#123; throw new IllegalArgumentException("resourceCount must be larger than zero."); &#125; // 设置可以共享的资源总数 setState(resourceCount); &#125; @Override protected int tryAcquireShared(int reduceCount) &#123; // 使用尝试获得资源，如果成功修改了状态变量（获得了资源） // 或者资源的总量小于 0（没有资源了），则返回。 for (; ; ) &#123; int lastCount = getState(); int newCount = lastCount - reduceCount; if (newCount &lt; 0 || compareAndSetState(lastCount, newCount)) &#123; return newCount; &#125; &#125; &#125; @Override protected boolean tryReleaseShared(int returnCount) &#123; // 释放共享资源，因为可能有多个线程同时执行，所以需要使用 CAS 操作来修改资源总数。 for (; ; ) &#123; int lastCount = getState(); int newCount = lastCount + returnCount; if (compareAndSetState(lastCount, newCount)) &#123; return true; &#125; &#125; &#125; &#125; // 定义两个共享资源，说明同一时间内可以有两个线程同时运行 private final Sync sync = new Sync(2); @Override public void lock() &#123; sync.acquireShared(1); &#125; @Override public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; @Override public boolean tryLock() &#123; return sync.tryAcquireShared(1) &gt;= 0; &#125; @Override public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(time)); &#125; @Override public void unlock() &#123; sync.releaseShared(1); &#125; @Override public Condition newCondition() &#123; throw new UnsupportedOperationException(); &#125; public static void main(String[] args) &#123; final Lock lock = new TwinsLock(); int threadCounts = 10; Thread threads[] = new Thread[threadCounts]; for (int i = 0; i &lt; threadCounts; i++) &#123; final int index = i; threads[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; lock.lock(); try &#123; TimeUnit.SECONDS.sleep(1); System.out.println(Thread.currentThread().getName()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); &#125; for (int i = 0; i &lt; threadCounts; i++) &#123; threads[i].start(); &#125; &#125;&#125; 运行程序，我们会发现程序每次都会同时打印两条语句，如下面的形式，证明同时有两个线程在执行。12345678Thread-0Thread-1Thread-3Thread-2Thread-8Thread-4Thread-3Thread-6 CAS 操作CAS（Compare and Swap），比较并交换，通过利用底层硬件平台的特性，实现原子性操作。CAS 操作涉及到3个操作数，内存值 V，旧的期望值 A，需要修改的新值 B。当且仅当预期值 A 和 内存值 V 相同时，才将内存值 V 修改为 B，否则什么都不做。CAS 操作类似于执行了下面流程123if(oldValue == memory[valueAddress]) &#123; memory[valueAddress] = newValue;&#125; 在上面的流程中，其实涉及到了两个操作，比较以及替换，为了确保程序正确，需要确保这两个操作的原子性（也就是说确保这两个操作同时进行，中间不会有其他线程干扰）。现在的 CPU 中，提供了相关的底层 CAS 指令，即 CPU 底层指令确保了比较和交换两个操作作为一个原子操作进行（其实在这一点上还是有排他锁的. 只是比起用synchronized, 这里的排他时间要短的多.），Java 中的 CAS 函数是借助于底层的 CAS 指令来实现的。更多关于 CPU 底层实现的原理可以参考 这篇文章。我们来看下 Java 中对于 CAS 函数的定义： 1234567891011121314151617181920/** * Atomically update Java variable to x if it is currently * holding expected. * @return true if successful */public final native boolean compareAndSwapObject(Object o, long offset, Object expected, Object x);/** * Atomically update Java variable to x if it is currently * holding expected. * @return true if successful */public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x);/** * Atomically update Java variable to x if it is currently * holding expected. * @return true if successful */public final native boolean compareAndSwapLong(Object o, long offset, long expected, long x); 上面三个函数定义在 sun.misc.Unsafe 类中，使用该类可以进行一些底层的操作，例如直接操作原生内存，更多关于 Unsafe 类的文章可以参考 这篇。以 compareAndSwapInt 为例，我们看下如何使用 CAS 函数：123456789101112131415161718192021222324252627282930313233343536373839404142434445import sun.misc.Unsafe;import java.lang.reflect.Field;/** * Created by Jikai Zhang on 2017/4/8. */public class CASIntTest &#123; private volatile int count = 0; private static final Unsafe unsafe = getUnsafe(); private static final long offset; // 获得 count 属性在 CASIntTest 中的偏移量（内存地址偏移） static &#123; try &#123; offset = unsafe.objectFieldOffset(CASIntTest.class.getDeclaredField("count")); &#125; catch (NoSuchFieldException e) &#123; throw new Error(e); &#125; &#125; // 通过反射的方式获得 Unsafe 类 public static Unsafe getUnsafe() &#123; Unsafe unsafe = null; try &#123; Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe"); theUnsafe.setAccessible(true); unsafe = (Unsafe) theUnsafe.get(null); &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; return unsafe; &#125; public void increment() &#123; int previous = count; unsafe.compareAndSwapInt(this, offset, previous, previous + 1); &#125; public static void main(String[] args) &#123; CASIntTest casIntTest = new CASIntTest(); casIntTest.increment(); System.out.println(casIntTest.count); &#125;&#125; 在 CASIntTest 类中，我们定义一个 count 变量，其中 increment 方法是将 count 的值加 1。下面是 increase 方法的代码：12int previous = count;unsafe.compareAndSwapInt(this, offset, previous, previous + 1); 在没有线程竞争的条件下，该代码执行的结果是将 count 变量的值加 1（多个线程竞争可能会有线程执行失败），但是在 compareAndSwapInt 函数中，我们并没有传入 count 变量，那么函数是如何修改的 count 变量值？其实我们往 compareAndSwapInt 函数中传入了 count 变量在堆内存中的地址，函数直接修改了 count 变量所在内存区域。count 属性在堆内存中的地址是由 CASIntTest 实例的起始内存地址和 count 属性相对于起始内存的偏移量决定的。其中对象属性在对象中的偏移量通过 objectFieldOffset 函数获得，函数原型如下所示。该函数接受一个 Filed 类型的参数，返回该 Filed 属性在对象中的偏移量。 1234567891011121314151617/** * Report the location of a given static field, in conjunction with &#123;@link * #staticFieldBase&#125;. * Do not expect to perform any sort of arithmetic on this offset; * it is just a cookie which is passed to the unsafe heap memory accessors. * * Any given field will always have the same offset, and no two distinct * fields of the same class will ever have the same offset. * * As of 1.4.1, offsets for fields are represented as long values, * although the Sun JVM does not use the most significant 32 bits. * It is hard to imagine a JVM technology which needs more than * a few bits to encode an offset within a non-array object, * However, for consistency with other methods in this class, * this method reports its result as a long value. */public native long objectFieldOffset(Field f); 下面我们再看一下 compareAndSwapInt 的函数原型。我们知道 CAS 操作需要知道 3 个信息：内存中的值，期望的旧值以及要修改的新值。通过前面的分析，我们知道通过 o 和 offset 我们可以确定属性在内存中的地址，也就是知道了属性在内存中的值。expected 对应期望的旧址，而 x 就是要修改的新值。 1public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x); compareAndSwapInt 函数首先比较一下 expected 是否和内存中的值相同，如果不同证明其他线程修改了属性值，那么就不会执行更新操作，但是程序如果就此返回了，似乎不太符合我们的期望，我们是希望程序可以执行更新操作的，如果其他线程先进行了更新，那么就在更新后的值的基础上进行修改，所以我们一般使用循环配合 CAS 函数，使程序在更新操作完成之后再返回，如下所示：1234long before = counter;while (!unsafe.compareAndSwapLong(this, offset, before, before + 1)) &#123; before = counter;&#125; 下面是使用 CAS 函数实现计数器的一个实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import sun.misc.Unsafe;import java.lang.reflect.Field;/** * Created by Jikai Zhang on 2017/4/8. */public class CASCounter &#123; // 通过反射的方式获得 Unsafe 类 public static Unsafe getUnsafe() &#123; Unsafe unsafe = null; try &#123; Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe"); theUnsafe.setAccessible(true); unsafe = (Unsafe) theUnsafe.get(null); &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; return unsafe; &#125; private volatile long counter = 0; private static final long offset; private static final Unsafe unsafe = getUnsafe(); static &#123; try &#123; offset = unsafe.objectFieldOffset(CASCounter.class.getDeclaredField("counter")); &#125; catch (NoSuchFieldException e) &#123; throw new Error(e); &#125; &#125; public void increment() &#123; long before = counter; while (!unsafe.compareAndSwapLong(this, offset, before, before + 1)) &#123; before = counter; &#125; &#125; public long getCounter() &#123; return counter; &#125; private static long intCounter = 0; public static void main(String[] args) throws InterruptedException &#123; int threadCount = 10; Thread threads[] = new Thread[threadCount]; final CASCounter casCounter = new CASCounter(); for (int i = 0; i &lt; threadCount; i++) &#123; threads[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; casCounter.increment(); intCounter++; &#125; &#125; &#125;); threads[i].start(); &#125; for(int i = 0; i &lt; threadCount; i++) &#123; threads[i].join(); &#125; System.out.printf("CASCounter is %d \nintCounter is %d\n", casCounter.getCounter(), intCounter); &#125;&#125; 在 AQS 中，对原始的 CAS 函数封装了一下，省去了获得变量地址的步骤，如下面的形式：12345678910111213private static final long waitStatusOffset;static &#123; try &#123; waitStatusOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField("waitStatus")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;&#125;private static final boolean compareAndSetWaitStatus(Node node, int expect, int update) &#123; return unsafe.compareAndSwapInt(node, waitStatusOffset, expect, update);&#125; 同步队列AQS 依赖内部的同步队列（一个 FIFO的双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把队列中第一个等待节点线程唤醒（下图中的 Node1），使其再次尝试获取同步状态。同步队列的结构如下所示： 图片来自 http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer Head 节点本身不保存等待线程的信息，它通过 next 变量指向第一个保存线程等待信息的节点（Node1）。当线程被唤醒之后，会删除 Head 节点，而唤醒线程所在的节点会设置为 Head 节点（Node1 被唤醒之后，Node1会被置为 Head 节点）。下面我们看下 JDK 中同步队列的实现。 Node 类首先看在节点所对应的 Node 类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static final class Node &#123; /** * 标志是独占式模式还是共享模式 */ static final Node SHARED = new Node(); static final Node EXCLUSIVE = null; /** * 线程等待状态的有效值 */ static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; /** * 线程状态，合法值为上面 4 个值中的一个 */ volatile int waitStatus; /** * 当前节点的前置节点 */ volatile Node prev; /** * 当前节点的后置节点 */ volatile Node next; /** * 当前节点所关联的线程 */ volatile Thread thread; /** * 指向下一个在某个条件上等待的节点，或者指向 SHARE 节点，表明当前处于共享模式 */ Node nextWaiter; final boolean isShared() &#123; return nextWaiter == SHARED; &#125; final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; // Used to establish initial head or SHARED marker &#125; Node(Thread thread, Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125;&#125; 在 Node 类中定义了四种等待状态： CANCELED： 1，因为等待超时 （timeout）或者中断（interrupt），节点会被置为取消状态。处于取消状态的节点不会再去竞争锁，也就是说不会再被阻塞。节点会一直保持取消状态，而不会转换为其他状态。处于 CANCELED 的节点会被移出队列，被 GC 回收。 SIGNAL： -1，表明当前的后继结点正在或者将要被阻塞（通过使用 LockSupport.pack 方法），因此当前的节点被释放（release）或者被取消时（cancel）时，要唤醒它的后继结点（通过 LockSupport.unpark 方法）。 CONDITION： -2，表明当前节点在条件队列中，因为等待某个条件而被阻塞。 PROPAGATE： -3，在共享模式下，可以认为资源有多个，因此当前线程被唤醒之后，可能还有剩余的资源可以唤醒其他线程。该状态用来表明后续节点会传播唤醒的操作。需要注意的是只有头节点才可以设置为该状态（This is set (for head node only) in doReleaseShared to ensure propagation continues, even if other operations have since intervened.）。 0：新创建的节点会处于这种状态 独占锁的获取和释放我们首先看下独占锁的获取和释放过程 独占锁获取 下面是获取独占锁的流程图： 我们通过 acquire 方法来获取独占锁，下面是方法定义123456789public final void acquire(int arg) &#123; // 首先尝试获取锁，如果获取失败，会先调用 addWaiter 方法创建节点并追加到队列尾部 // 然后调用 acquireQueued 阻塞或者循环尝试获取锁 if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))&#123; // 在 acquireQueued 中，如果线程是因为中断而退出的阻塞状态会返回 true // 这里的 selfInterrupt 主要是为了恢复线程的中断状态 selfInterrupt(); &#125;&#125; acquire 会首先调用 tryAcquire 方法来获得锁，该方法需要我们来实现，这个在前面已经提过了。如果没有获取锁，会调用 addWaiter 方法创建一个和当前线程关联的节点追加到同步队列的尾部，我们调用 addWaiter 时传入的是 Node.EXCLUSIVE，表明当前是独占模式。下面是 addWaiter 的具体实现123456789101112131415private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // tail 指向同步队列的尾节点 Node pred = tail; // Try the fast path of enq; backup to full enq on failure if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node;&#125; addWaiter 方法会首先调用 if 方法，来判断能否成功将节点添加到队列尾部，如果添加失败，再调用 enq 方法（使用循环不断重试）进行添加，下面是 enq 方法的实现：123456789101112131415161718private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; // 同步队列采用的懒初始化（lazily initialized）的方式， // 初始时 head 和 tail 都会被设置为 null，当一次被访问时 // 才会创建 head 对象，并把尾指针指向 head。 if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; addWaiter 仅仅是将节点加到了同步队列的末尾，并没有阻塞线程，线程阻塞的操作是在 acquireQueued 方法中完成的，下面是 acquireQueued 的实现：12345678910111213141516171819202122232425262728final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); // 如果当前节点的前继节点是 head，就使用自旋（循环）的方式不断请求锁 if (p == head &amp;&amp; tryAcquire(arg)) &#123; // 成功获得锁，将当前节点置为 head 节点，同时删除原 head 节点 setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; // shouldParkAfterFailedAcquire 检查是否可以挂起线程， // 如果可以挂起进程，会调用 parkAndCheckInterrupt 挂起线程， // 如果 parkAndCheckInterrupt 返回 true，表明当前线程是因为中断而退出挂起状态的， // 所以要将 interrupted 设为 true，表明当前线程被中断过 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; acquireQueued 会首先检查当前节点的前继节点是否为 head，如果为 head，将使用自旋的方式不断的请求锁，如果不是 head，则调用 shouldParkAfterFailedAcquire 查看是否应该挂起当前节点关联的线程，下面是 shouldParkAfterFailedAcquire 的实现：123456789101112131415161718192021222324private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; // 当前节点的前继节点的等待状态 int ws = pred.waitStatus; // 如果前继节点的等待状态为 SIGNAL 我们就可以将当前节点对应的线程挂起 if (ws == Node.SIGNAL) return true; if (ws &gt; 0) &#123; // ws 大于 0，表明当前线程的前继节点处于 CANCELED 的状态， // 所以我们需要从当前节点开始往前查找，直到找到第一个不为 // CAECELED 状态的节点 do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125; shouldParkAfterFailedAcquire 会检查前继节点的等待状态，如果前继节点状态为 SIGNAL，则可以将当前节点关联的线程挂起，如果不是 SIGNAL，会做一些其他的操作，在当前循环中不会挂起线程。如果确定了可以挂起线程，就调用 parkAndCheckInterrupt 方法对线程进行阻塞：12345678910private final boolean parkAndCheckInterrupt() &#123; // 挂起当前线程 LockSupport.park(this); // 可以通过调用 interrupt 方法使线程退出 park 状态， // 为了使线程在后面的循环中还可以响应中断，会重置线程的中断状态。 // 这里使用 interrupted 会先返回线程当前的中断状态，然后将中断状态重置为 false， // 线程的中断状态会返回给上层调用函数，在线程获得锁后， // 如果发现线程曾被中断过，会将中断状态重新设为 true return Thread.interrupted();&#125; 独占锁释放 下面是释放独占锁的流程： 通过 release 方法，我们可以释放互斥锁。下面是 release 方法的实现：12345678910public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; // waitStatus 为 0，证明是初始化的空队列或者后继结点已经被唤醒了 if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 在独占模式下释放锁时，是没有其他线程竞争的，所以处理会简单一些。首先尝试释放锁，如果失败就直接返回（失败不是因为多线程竞争，而是线程本身就不拥有锁）。如果成功的话，会检查 h 的状态，然后调用 unparkSuccessor 方法来唤醒后续线程。下面是 unparkSuccessor 的实现：123456789101112131415161718192021222324private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; // 将 head 节点的状态置为 0，表明当前节点的后续节点已经被唤醒了， // 不需要再次唤醒，修改 ws 状态主要作用于 release 的判断 if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);&#125; 在 unparkSuccessor 方法中，如果发现头节点的后继结点为 null 或者处于 CANCELED 状态，会从尾部往前找（在节点存在的前提下，这样一定能找到）离头节点最近的需要唤醒的节点，然后唤醒该节点。 共享锁获取和释放独占锁的流程和原理比较容易理解，因为只有一个锁，但是共享锁的处理就相对复杂一些了。在独占锁中，只有在释放锁之后，才能唤醒等待的线程，而在共享模式中，获取锁和释放锁之后，都有可能唤醒等待的线程。如果想要理清共享锁的工作过程，必须将共享锁的获取和释放结合起来看。这里我们先看一下共享锁的释放过程，只有明白了释放过程做了哪些工作，才能更好的理解获取锁的过程。 共享锁释放 下面是释放共享锁的流程： 通过 releaseShared 方法会释放共享锁，下面是具体的实现：1234567public final boolean releaseShared(int releases) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; releases 是要释放的共享资源数量，其中 tryReleaseShared 的方法由我们自己重写，该方法的主要功能就是修改共享资源的数量（state + releases），因为可能会有多个线程同时释放资源，所以实现的时候，一般采用循环加 CAS 操作的方式，如下面的形式：12345678910protected boolean tryReleaseShared(int releases) &#123; // 释放共享资源，因为可能有多个线程同时执行，所以需要使用 CAS 操作来修改资源总数。 for (;;) &#123; int lastCount = getState(); int newCount = lastCount + releases; if (compareAndSetState(lastCount, newCount)) &#123; return true; &#125; &#125;&#125; 当共享资源数量修改了之后，会调用 doReleaseShared 方法，该方法主要唤醒同步队列中的第一个等待节点（head.next），下面是具体实现：12345678910111213141516171819202122232425262728293031323334353637383940414243private void doReleaseShared() &#123; /* * Ensure that a release propagates, even if there are other * in-progress acquires/releases. This proceeds in the usual * way of trying to unparkSuccessor of head if it needs * signal. But if it does not, status is set to PROPAGATE to * ensure that upon release, propagation continues. * Additionally, we must loop in case a new node is added * while we are doing this. Also, unlike other uses of * unparkSuccessor, we need to know if CAS to reset status * fails, if so rechecking. */ for (;;) &#123; Node h = head; // head = null 说明没有初始化，head = tail 说明同步队列中没有等待节点 if (h != null &amp;&amp; h != tail) &#123; // 查看当前节点的等待状态 int ws = h.waitStatus; // 我们在前面说过，SIGNAL说明有后续节点需要唤醒 if (ws == Node.SIGNAL) &#123; /* * 将当前节点的值设为 0，表明已经唤醒了后继节点 * 可能会有多个线程同时执行到这一步，所以使用 CAS 保证只有一个线程能修改成功， * 从而执行 unparkSuccessor，其他的线程会执行 continue 操作 */ if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) &#123; /* * ws 等于 0，说明无需唤醒后继结点（后续节点已经被唤醒或者当前节点没有被阻塞的后继结点）， * 也就是这一次的调用其实并没有执行唤醒后继结点的操作。就类似于我只需要一张优惠券， * 但是我的两个朋友，他们分别给我了一张，因此我就剩余了一张。然后我就将这张剩余的优惠券 * 送（传播）给其他人使用，因此这里将节点置为可传播的状态（PROPAGATE） */ continue; // loop on failed CAS &#125; &#125; if (h == head) // loop if head changed break; &#125;&#125; 从上面的实现中，doReleaseShared 的主要作用是用来唤醒阻塞的节点并且一次只唤醒一个，让该节点关联的线程去重新竞争锁，它既不修改同步队列，也不修改共享资源。 当多个线程同时释放资源时，可以确保两件事： 共享资源的数量能正确的累加 至少有一个线程被唤醒，其实只要确保有一个线程被唤醒就可以了，即便唤醒了多个线程，在同一时刻，也只能有一个线程能得到竞争锁的资格，在下面我们会看到。 所以释放锁做的主要工作还是修改共享资源的数量。而有了多个共享资源后，如何确保同步队列中的多个节点可以获取锁，是由获取锁的逻辑完成的。下面看下共享锁的获取。 共享锁的获取 下面是获取共享锁的流程 通过 acquireShared 方法，我们可以申请共享锁，下面是具体的实现：12345public final void acquireShared(int arg) &#123; // 如果返回结果小于 0，证明没有获取到共享资源 if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; 如果没有获取到共享资源，就会执行 doAcquireShared 方法，下面是该方法的具体实现：123456789101112131415161718192021222324252627private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 从上面的代码中可以看到，只有前置节点为 head 的节点才有可能去竞争锁，这点和独占模式的处理是一样的，所以即便唤醒了多个线程，也只有一个线程能进入竞争锁的逻辑，其余线程会再次进入 park 状态，当线程获取到共享锁之后，会执行 setHeadAndPropagate 方法，下面是具体的实现：12345678910111213141516171819202122232425262728293031323334353637383940private void setHeadAndPropagate(Node node, long propagate) &#123; // 备份一下头节点 Node h = head; // Record old head for check below /* * 移除头节点，并将当前节点置为头节点 * 当执行完这一步之后，其实队列的头节点已经发生改变， * 其他被唤醒的线程就有机会去获取锁，从而并发的执行该方法， * 所以上面备份头节点，以便下面的代码可以正确运行 */ setHead(node); /* * Try to signal next queued node if: * Propagation was indicated by caller, * or was recorded (as h.waitStatus either before * or after setHead) by a previous operation * (note: this uses sign-check of waitStatus because * PROPAGATE status may transition to SIGNAL.) * and * The next node is waiting in shared mode, * or we don't know, because it appears null * * The conservatism in both of these checks may cause * unnecessary wake-ups, but only when there are multiple * racing acquires/releases, so most need signals now or soon * anyway. */ /* * 判断是否需要唤醒后继结点，propagate &gt; 0 说明共享资源有剩余， * h.waitStatus &lt; 0，表明当前节点状态可能为 SIGNAL，CONDITION，PROPAGATE */ if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; // 只有 s 不处于独占模式时，才去唤醒后继结点 if (s == null || s.isShared()) doReleaseShared(); &#125;&#125; 判断后继结点是否需要唤醒的条件是十分宽松的，也就是一定包含必要的唤醒，但是也有可能会包含不必要的唤醒。从前面我们可以知道 doReleaseShared 函数的主要作用是唤醒后继结点，它既不修改共享资源，也不修改同步队列，所以即便有不必要的唤醒也是不影响程序正确性的。如果没有共享资源，节点会再次进入等待状态。 到了这里，脉络就比较清晰了，当一个节点获取到共享锁之后，它除了将自身设为 head 节点之外，还会判断一下是否满足唤醒后继结点的条件，如果满足，就唤醒后继结点，后继结点获取到锁之后，会重复这个过程，直到判断条件不成立。就类似于考试时从第一排往最后一排传卷子，第一排先留下一份，然后将剩余的传给后一排，后一排会重复这个过程。如果传到某一排卷子没了，那么位于这排的人就要等待，直到老师又给了他新的卷子。 中断在获取锁时还可以设置响应中断，独占锁和共享锁的处理逻辑类似，这里我们以独占锁为例。使用 acquireInterruptibly 方法，在获取独占锁时可以响应中断，下面是具体的实现：1234567891011121314151617181920212223242526272829public final void acquireInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) doAcquireInterruptibly(arg);&#125;private void doAcquireInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) &#123; // 这里会抛出异常 throw new InterruptedException(); &#125; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 从上面的代码中我们可以看出，acquireInterruptibly 和 acquire 的逻辑类似，只是在下面的代码处有所不同：当线程因为中断而退出阻塞状态时，会直接抛出 InterruptedException 异常。1234if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) &#123; // 这里会抛出异常 throw new InterruptedException();&#125; 我们知道，不管是抛出异常还是方法返回，程序都会执行 finally 代码，而 failed 肯定为 true，所以抛出异常之后会执行 cancelAcquire 方法，cancelAcquire 方法主要将节点从同步队列中移除。下面是具体的实现：12345678910111213141516171819202122232425262728293031323334353637383940414243private void cancelAcquire(Node node) &#123; // Ignore if node doesn't exist if (node == null) return; node.thread = null; // 跳过前面的已经取消的节点 Node pred = node.prev; while (pred.waitStatus &gt; 0) node.prev = pred = pred.prev; // 保存下 pred 的后继结点，以便 CAS 操作使用 // 因为可能存在已经取消的节点，所以 pred.next 不一等于 node Node predNext = pred.next; // Can use unconditional write instead of CAS here. // After this atomic step, other Nodes can skip past us. // Before, we are free of interference from other threads. // 将节点状态设为 CANCELED node.waitStatus = Node.CANCELLED; // If we are the tail, remove ourselves. if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; compareAndSetNext(pred, predNext, null); &#125; else &#123; // If successor needs signal, try to set pred's next-link // so it will get one. Otherwise wake it up to propagate. int ws; if (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != null) &#123; Node next = node.next; if (next != null &amp;&amp; next.waitStatus &lt;= 0) compareAndSetNext(pred, predNext, next); &#125; else &#123; unparkSuccessor(node); &#125; node.next = node; // help GC &#125;&#125; 从上面的代码可以看出，节点的删除分为三种情况： 删除节点为尾节点，直接将该节点的第一个有效前置节点置为尾节点 删除节点的前置节点为头节点，则对该节点执行 unparkSuccessor 操作 删除节点为中间节点，结果如下图所示。下图中（1）表示同步队列的初始状态，假设删除 node2， node1 是正常节点（非 CANCELED），（2）就是删除 node2 后同步队列的状态，此时 node1 节点的后继已经变为 node3，也就是说当 node1 变为 head 之后，会直接唤醒 node3。当另外的一个节点中断之后再次执行 cancelAcquire，在执行下面的代码时，会使同步队列的状态由（2）变为（3），此时 node2 已经没有外界指针了，可以被回收了。如果一直没有另外一个节点中断，也就是同步队列一直处于（2）状态，那么需要等 node3 被回收之后，node2 才可以被回收。123Node pred = node.prev;while (pred.waitStatus &gt; 0) node.prev = pred = pred.prev; 超时超时是在中断的基础上加了一层时间的判断，这里我们还是以独占锁为例。 tryAcquireNanos 支持获取锁的超时处理，下面是具体实现：12345public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);&#125; 当获取锁失败之后，会执行 doAcquireNanos 方法，下面是具体实现：1234567891011121314151617181920212223242526272829303132333435private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (nanosTimeout &lt;= 0 L) return false; // 线程最晚结束时间 final long deadline = System.nanoTime() + nanosTimeout; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return true; &#125; // 判断是否超时，如果超时就返回 nanosTimeout = deadline - System.nanoTime(); if (nanosTimeout &lt;= 0 L) return false; // 这里如果设定了一个阈值，如果超时的时间比阈值小，就认为 // 当前线程没必要阻塞，再执行几次 for 循环估计就超时了 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); if (Thread.interrupted()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 当线程超时返回时，还是会执行 cancelAcquire 方法，cancelAcquire 的逻辑已经在前面说过了，这里不再赘述。 参考文章 Java 并发编程的艺术 Java Magic. Part 4: sun.misc.Unsafe Java里的CompareAndSet(CAS) ReentrantLock的lock-unlock流程详解 深入JVM锁机制2-Lock 深度解析Java 8：JDK1.8 AbstractQueuedSynchronizer的实现分析（上） AbstractQueuedSynchronizer源码分析 聊聊并发（十二）—AQS分析 AbstractQueuedSynchronizer (AQS) 并发编程实践二：AbstractQueuedSynchronizer]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java 并发】详解 ThreadLocal]]></title>
    <url>%2F2017%2F03%2F29%2F%E3%80%90Java-%E5%B9%B6%E5%8F%91%E3%80%91%E8%AF%A6%E8%A7%A3-ThreadLocal%2F</url>
    <content type="text"><![CDATA[前言ThreadLocal 主要用来提供线程局部变量，也就是变量只对当前线程可见，本文主要记录一下对于 ThreadLocal 的理解。更多关于 Java 多线程的文章可以转到 这里。 线程局部变量在多线程环境下，之所以会有并发问题，就是因为不同的线程会同时访问同一个共享变量，例如下面的形式12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MultiThreadDemo &#123; public static class Number &#123; private int value = 0; public void increase() throws InterruptedException &#123; value = 10; Thread.sleep(10); System.out.println("increase value: " + value); &#125; public void decrease() throws InterruptedException &#123; value = -10; Thread.sleep(10); System.out.println("decrease value: " + value); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; final Number number = new Number(); Thread increaseThread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; number.increase(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); Thread decreaseThread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; number.decrease(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); increaseThread.start(); decreaseThread.start(); &#125;&#125; 在上面的代码中，increase 线程和 decrease 线程会操作同一个 number 中 value，那么输出的结果是不可预测的，因为当前线程修改变量之后但是还没输出的时候，变量有可能被另外一个线程修改，下面是一种可能的情况：12increase value: 10decrease value: 10 一种解决方法是在 increase() 和 decrease() 方法上加上 synchronized 关键字进行同步，这种做法其实是将 value 的 赋值 和 打印 包装成了一个原子操作，也就是说两者要么同时进行，要不都不进行，中间不会有额外的操作。我们换个角度考虑问题，如果 value 只属于 increase 线程或者 decrease 线程，而不是被两个线程共享，那么也不会出现竞争问题。一种比较常见的形式就是局部（local）变量（这里排除局部变量引用指向共享对象的情况），如下所示：12345public void increase() throws InterruptedException &#123; int value = 10; Thread.sleep(10); System.out.println("increase value: " + value);&#125; 不论 value 值如何改变，都不会影响到其他线程，因为在每次调用 increase 方法时，都会创建一个 value 变量，该变量只对当前调用 increase 方法的线程可见。借助于这种思想，我们可以对每个线程创建一个共享变量的副本，该副本只对当前线程可见（可以认为是线程私有的变量），那么修改该副本变量时就不会影响到其他的线程。一个简单的思路是使用 Map 存储每个变量的副本，将当前线程的 id 作为 key，副本变量作为 value 值，下面是一个实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class SimpleImpl &#123; public static class CustomThreadLocal &#123; private Map&lt;Long, Integer&gt; cacheMap = new HashMap&lt;&gt;(); private int defaultValue ; public CustomThreadLocal(int value) &#123; defaultValue = value; &#125; public Integer get() &#123; long id = Thread.currentThread().getId(); if (cacheMap.containsKey(id)) &#123; return cacheMap.get(id); &#125; return defaultValue; &#125; public void set(int value) &#123; long id = Thread.currentThread().getId(); cacheMap.put(id, value); &#125; &#125; public static class Number &#123; private CustomThreadLocal value = new CustomThreadLocal(0); public void increase() throws InterruptedException &#123; value.set(10); Thread.sleep(10); System.out.println("increase value: " + value.get()); &#125; public void decrease() throws InterruptedException &#123; value.set(-10); Thread.sleep(10); System.out.println("decrease value: " + value.get()); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; final Number number = new Number(); Thread increaseThread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; number.increase(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); Thread decreaseThread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; number.decrease(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); increaseThread.start(); decreaseThread.start(); &#125;&#125; 但是上面的实现会存在下面的问题： 每个线程对应的副本变量的生命周期不是由线程决定的，而是由共享变量的生命周期决定的。在上面的例子中，即便线程执行完，只要 number 变量存在，线程的副本变量依然会存在（存放在 number 的 cacheMap 中）。但是作为特定线程的副本变量，该变量的生命周期应该由线程决定，线程消亡之后，该变量也应该被回收。 多个线程有可能会同时操作 cacheMap，需要对 cacheMap 进行同步处理。 为了解决上面的问题，我们换种思路，每个线程创建一个 Map，存放当前线程中副本变量，用 CustomThreadLocal 的实例作为 key 值，下面是一个示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class SimpleImpl2 &#123; public static class CommonThread extends Thread &#123; Map&lt;Integer, Integer&gt; cacheMap = new HashMap&lt;&gt;(); &#125; public static class CustomThreadLocal &#123; private int defaultValue; public CustomThreadLocal(int value) &#123; defaultValue = value; &#125; public Integer get() &#123; Integer id = this.hashCode(); Map&lt;Integer, Integer&gt; cacheMap = getMap(); if (cacheMap.containsKey(id)) &#123; return cacheMap.get(id); &#125; return defaultValue; &#125; public void set(int value) &#123; Integer id = this.hashCode(); Map&lt;Integer, Integer&gt; cacheMap = getMap(); cacheMap.put(id, value); &#125; public Map&lt;Integer, Integer&gt; getMap() &#123; CommonThread thread = (CommonThread) Thread.currentThread(); return thread.cacheMap; &#125; &#125; public static class Number &#123; private CustomThreadLocal value = new CustomThreadLocal(0); public void increase() throws InterruptedException &#123; value.set(10); Thread.sleep(10); System.out.println("increase value: " + value.get()); &#125; public void decrease() throws InterruptedException &#123; value.set(-10); Thread.sleep(10); System.out.println("decrease value: " + value.get()); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; final Number number = new Number(); Thread increaseThread = new CommonThread() &#123; @Override public void run() &#123; try &#123; number.increase(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; Thread decreaseThread = new CommonThread() &#123; @Override public void run() &#123; try &#123; number.decrease(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; increaseThread.start(); decreaseThread.start(); &#125;&#125; 在上面的实现中，当线程消亡之后，线程中 cacheMap 也会被回收，它当中存放的副本变量也会被全部回收，并且 cacheMap 是线程私有的，不会出现多个线程同时访问一个 cacheMap 的情况。在 Java 中，ThreadLocal 类的实现就是采用的这种思想，注意只是思想，实际的实现和上面的并不一样。 使用示例Java 使用 ThreadLocal 类来实现线程局部变量模式，ThreadLocal 使用 set 和 get 方法设置和获取变量，下面是函数原型：12public void set(T value);public T get(); 下面是使用 ThreadLocal 的一个完整示例：123456789101112131415161718192021222324252627public class ThreadLocalDemo &#123; private static ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;&gt;(); private static int value = 0; public static class ThreadLocalThread implements Runnable &#123; @Override public void run() &#123; threadLocal.set((int)(Math.random() * 100)); value = (int) (Math.random() * 100); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.printf(Thread.currentThread().getName() + ": threadLocal=%d, value=%d\n", threadLocal.get(), value); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(new ThreadLocalThread()); Thread thread2 = new Thread(new ThreadLocalThread()); thread.start(); thread2.start(); thread.join(); thread2.join(); &#125;&#125; 下面是一种可能的输出：12Thread-0: threadLocal=87, value=15Thread-1: threadLocal=69, value=15 我们看到虽然 threadLocal 是静态变量，但是每个线程都有自己的值，不会受到其他线程的影响。 具体实现ThreadLocal 的实现思想，我们在前面已经说了，每个线程维护一个 ThreadLocalMap 的映射表，映射表的 key 是 ThreadLocal 实例本身，value 是要存储的副本变量。ThreadLocal 实例本身并不存储值，它只是提供一个在当前线程中找到副本值的 key。 如下图所示： 图片来自 http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/ 我们从下面三个方面看下 ThreadLocal 的实现： 存储线程副本变量的数据结构 如何存取线程副本变量 如何对 ThreadLocal 的实例进行 Hash ThreadLocalMap线程使用 ThreadLocalMap 来存储每个线程副本变量，它是 ThreadLocal 里的一个静态内部类。ThreadLocalMap 也是采用的散列表（Hash）思想来实现的，但是实现方式和 HashMap 不太一样。我们首先看下散列表的相关知识： 散列表理想状态下，散列表就是一个包含关键字的固定大小的数组，通过使用散列函数，将关键字映射到数组的不同位置。下面是理想散列表的一个示意图： 图片来自 数据结构与算法分析: C语法描述 在理想状态下，哈希函数可以将关键字均匀的分散到数组的不同位置，不会出现两个关键字散列值相同（假设关键字数量小于数组的大小）的情况。但是在实际使用中，经常会出现多个关键字散列值相同的情况（被映射到数组的同一个位置），我们将这种情况称为散列冲突。为了解决散列冲突，主要采用下面两种方式： 分离链表法（separate chaining） 开放定址法（open addressing） 分离链表法分散链表法使用链表解决冲突，将散列值相同的元素都保存到一个链表中。当查询的时候，首先找到元素所在的链表，然后遍历链表查找对应的元素。下面是一个示意图： 图片来自 http://faculty.cs.niu.edu/~freedman/340/340notes/340hash.htm 开放定址法开放定址法不会创建链表，当关键字散列到的数组单元已经被另外一个关键字占用的时候，就会尝试在数组中寻找其他的单元，直到找到一个空的单元。探测数组空单元的方式有很多，这里介绍一种最简单的 – 线性探测法。线性探测法就是从冲突的数组单元开始，依次往后搜索空单元，如果到数组尾部，再从头开始搜索（环形查找）。如下图所示： 图片来自 http://alexyyek.github.io/2014/12/14/hashCollapse/ 关于两种方式的比较，可以参考 这篇文章。ThreadLocalMap 中使用开放地址法来处理散列冲突，而 HashMap 中使用的分离链表法。之所以采用不同的方式主要是因为：在 ThreadLocalMap 中的散列值分散的十分均匀，很少会出现冲突。并且 ThreadLocalMap 经常需要清除无用的对象，使用纯数组更加方便。 实现我们知道 Map 是一种 key-value 形式的数据结构，所以在散列数组中存储的元素也是 key-value 的形式。ThreadLocalMap 使用 Entry 类来存储数据，下面是该类的定义：123456789static class Entry extends WeakReference &lt;ThreadLocal &lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal &lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; Entry 将 ThreadLocal 实例作为 key，副本变量作为 value 存储起来。注意 Entry 中对于 ThreadLocal 实例的引用是一个弱引用，该引用定义在 Reference 类（WeakReference的父类）中，下面是 super(k) 最终调用的代码：12345678Reference(T referent) &#123; this(referent, null);&#125;Reference(T referent, ReferenceQueue &lt;? super T&gt; queue) &#123; this.referent = referent; this.queue = (queue == null) ? ReferenceQueue.NULL : queue;&#125; 关于弱引用和为什么使用弱引用可以参考 Java 理论与实践: 用弱引用堵住内存泄漏 和 深入分析 ThreadLocal 内存泄漏问题。下面看一下 ThreadLocalMap 的 set 函数12345678910111213141516171819202122232425262728293031323334private void set(ThreadLocal &lt;?&gt; key, Object value) &#123; // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; // 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置 int i = key.threadLocalHashCode &amp; (len - 1); // 使用线性探测法查找元素 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal &lt;?&gt; k = e.get(); // ThreadLocal 对应的 key 存在，直接覆盖之前的值 if (k == key) &#123; e.value = value; return; &#125; // key为 null，但是值不为 null，说明之前的 ThreadLocal 对象已经被回收了，当前数组中的 Entry 是一个陈旧（stale）的元素 if (k == null) &#123; // 用新元素替换陈旧的元素，这个方法进行了不少的垃圾清理动作，防止内存泄漏，具体可以看源代码，没看太懂 replaceStaleEntry(key, value, i); return; &#125; &#125; // ThreadLocal 对应的 key 不存在并且没有找到陈旧的元素，则在空元素的位置创建一个新的 Entry。 tab[i] = new Entry(key, value); int sz = ++size; // cleanSomeSlot 清理陈旧的 Entry（key == null），具体的参考源码。如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash。 if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; 关于 set 方法，有几点需要地方： int i = key.threadLocalHashCode &amp; (len - 1);，这里实际上是对 len-1 进行了取余操作。之所以能这样取余是因为 len 的值比较特殊，是 2 的 n 次方，减 1 之后低位变为全 1，高位变为全 0。例如 16，减 1 之后对应的二进制为: 00001111，这样其他数字中大于 16 的部分就会被 0 与掉，小于 16 的部分就会保留下来，就相当于取余了。 在 replaceStaleEntry 和 cleanSomeSlots 方法中都会清理一些陈旧的 Entry，防止内存泄漏 threshold 的值大小为 threshold = len * 2 / 3; rehash 方法中首先会清理陈旧的 Entry，如果清理完之后元素数量仍然大于 threshold 的 3/4，则进行扩容操作（数组大小变为原来的 2倍）123456private void rehash() &#123; expungeStaleEntries(); // Use lower threshold for doubling to avoid hysteresis if (size &gt;= threshold - threshold / 4) resize();&#125; 我们再看一下 getEntry （没有 get 方法，就叫 getEntry）方法：12345678private Entry getEntry(ThreadLocal &lt;?&gt; key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e);&#125; 因为 ThreadLocalMap 中采用开放定址法，所以当前 key 的散列值和元素在数组中的索引并不一定完全对应。所以在 get 的时候，首先会看 key 的散列值对应的数组元素是否为要查找的元素，如果不是，再调用 getEntryAfterMiss 方法查找后面的元素。12345678910111213141516private Entry getEntryAfterMiss(ThreadLocal &lt;?&gt; key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal &lt; ? &gt; k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; &#125; return null;&#125; 最后看一下删除操作。删除其实就是将 Entry 的键值设为 null，变为陈旧的 Entry。然后调用 expungeStaleEntry 清理陈旧的 Entry。123456789101112private void remove(ThreadLocal &lt;?&gt; key) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len - 1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; if (e.get() == key) &#123; e.clear(); expungeStaleEntry(i); return; &#125; &#125;&#125; 副本变量存取前面说完了 ThreadLocalMap，副本变量的存取操作就很好理解了。下面是 ThreadLocal 中的 set 和 get 方法的实现：12345678910111213141516171819202122public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T) e.value; return result; &#125; &#125; return setInitialValue();&#125; 存取的基本流程就是首先获得当前线程的 ThreadLocalMap，将 ThreadLocal 实例作为键值传入 Map，然后就是进行相关的变量存取工作了。线程中的 ThreadLocalMap 是懒加载的，只有真正的要存变量时才会调用 createMap 创建，下面是 createMap 的实现：123void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 如果想要给 ThreadLocal 的副本变量设置初始值，需要重写 initialValue 方法，如下面的形式：12345ThreadLocal &lt;Integer&gt; threadLocal = new ThreadLocal() &#123; protected Integer initialValue() &#123; return 0; &#125;&#125;; ThreadLocal 散列值当创建了一个 ThreadLocal 的实例后，它的散列值就已经确定了，下面是 ThreadLocal 中的实现：1234567891011121314151617181920212223242526272829303132/** * ThreadLocals rely on per-thread linear-probe hash maps attached * to each thread (Thread.threadLocals and * inheritableThreadLocals). The ThreadLocal objects act as keys, * searched via threadLocalHashCode. This is a custom hash code * (useful only within ThreadLocalMaps) that eliminates collisions * in the common case where consecutively constructed ThreadLocals * are used by the same threads, while remaining well-behaved in * less common cases. */private final int threadLocalHashCode = nextHashCode();/** * The next hash code to be given out. Updated atomically. Starts at * zero. */private static AtomicInteger nextHashCode = new AtomicInteger();/** * The difference between successively generated hash codes - turns * implicit sequential thread-local IDs into near-optimally spread * multiplicative hash values for power-of-two-sized tables. */private static final int HASH_INCREMENT = 0x61c88647;/** * Returns the next hash code. */private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT);&#125; 我们看到 threadLocalHashCode 是一个常量，它通过 nextHashCode() 函数产生。nextHashCode() 函数其实就是在一个 AtomicInteger 变量（初始值为0）的基础上每次累加 0x61c88647，使用 AtomicInteger 为了保证每次的加法是原子操作。而 0x61c88647 这个就比较神奇了，它可以使 hashcode 均匀的分布在大小为 2 的 N 次方的数组里。下面写个程序测试一下:123456789101112public static void main(String[] args) &#123; AtomicInteger hashCode = new AtomicInteger(); int hash_increment = 0x61c88647; int size = 16; List &lt;Integer&gt; list = new ArrayList &lt;&gt; (); for (int i = 0; i &lt; size; i++) &#123; list.add(hashCode.getAndAdd(hash_increment) &amp; (size - 1)); &#125; System.out.println("original:" + list); Collections.sort(list); System.out.println("sort: " + list);&#125; 我们将 size 设为 16，32 和 64 分别测试一下：1234567891011// size=16original:[0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9]sort: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]// size=32original:[0, 7, 14, 21, 28, 3, 10, 17, 24, 31, 6, 13, 20, 27, 2, 9, 16, 23, 30, 5, 12, 19, 26, 1, 8, 15, 22, 29, 4, 11, 18, 25]sort: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]// size=64original:[0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 6, 13, 20, 27, 34, 41, 48, 55, 62, 5, 12, 19, 26, 33, 40, 47, 54, 61, 4, 11, 18, 25, 32, 39, 46, 53, 60, 3, 10, 17, 24, 31, 38, 45, 52, 59, 2, 9, 16, 23, 30, 37, 44, 51, 58, 1, 8, 15, 22, 29, 36, 43, 50, 57]sort: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63] 可以看到随着 size 的变化，hashcode 总能均匀的分布。其实这就是 Fibonacci Hashing，具体可以参考 这篇文章。所以虽然 ThreadLocal 的 hashcode 是固定的，当 ThreadLocalMap 中的散列表调整大小（变为原来的 2 倍）之后重新散列，hashcode 仍能均匀的分布在散列表中。 应用场景 摘自 Java并发编程：深入剖析ThreadLocal 最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。如123456789private static ThreadLocal &lt; Connection &gt; connectionHolder = new ThreadLocal &lt; Connection &gt; () &#123; public Connection initialValue() &#123; return DriverManager.getConnection(DB_URL); &#125;&#125;;public static Connection getConnection() &#123; return connectionHolder.get();&#125; 1234567891011121314private static final ThreadLocal threadSession = new ThreadLocal();public static Session getSession() throws InfrastructureException &#123; Session s = (Session) threadSession.get(); try &#123; if (s == null) &#123; s = getSessionFactory().openSession(); threadSession.set(s); &#125; &#125; catch (HibernateException ex) &#123; throw new InfrastructureException(ex); &#125; return s;&#125; 参考文章 http://www.iteye.com/topic/103804 http://www.jianshu.com/p/529c03d9b67e http://stackoverflow.com/questions/38994306/what-is-the-meaning-of-0x61c88647-constant-in-threadlocal-java http://jerrypeng.me/2013/06/thread-local-and-magical-0x61c88647/ ThreadLocal是否会引发内存泄露的分析（转） [Java并发包学习七]解密ThreadLocal 数据结构与算法分析: C语法描述]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【应用】Markdown 在线阅读器]]></title>
    <url>%2F2017%2F01%2F09%2F%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91Markdown-%E5%9C%A8%E7%BA%BF%E9%98%85%E8%AF%BB%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言一款在线的 Markdown 阅读器，主要用来展示 Markdown 内容。支持 HTML 导出，同时可以方便的添加扩展功能。在这个阅读器的基础又做了一款在线 Github Pages 页面生成器，可以方便的生成不同主题风格的 GitHub Page 页面。 功能阅读器 支持文件拖拽 兼容移动端 Prism.js / Highlight.js 代码高亮 自动生成目录 本地图片显示 导出 Html （包含样式） 扩展功能 Toto 列表 MathJax 时序图 (Js sequence diagrams) Emoji (Emojify.js) 图表 (ECharts) Github Page 生成器在上面的基础上加上了下面的功能 支持多种页面主题 Architect Cayman Minimal Modernist Slate Time machine 评论 多说 Disqus 地址阅读器在线地址 效果预览 源码 生成器在线地址 效果预览 源码 效果阅读器 生成器 实现文件解析程序使用 marked 将 markdown 格式转为 html 格式，这是一个 js 的库，可以直接在浏览器端使用。下面是一个基本的示例12var htmlContent = marked(mdContent);$("#content").html(htmlContent); 同时 marked 提供了一些接口，让我们可以方便的定制自己的功能。具体的可以参考它的 说明文件 。在下面我们会介绍我们是如何利用这些接口来实现扩展功能。 文件上传自定义上传按钮样式原始的上传按钮太丑了，所以我们需要自定义自己的样式。这里使用的方式是使用在 input 上面覆盖一个 button，用 button 来显示样式。同时我们将 button 的 pointer-events 设为 none，就可以阻止 button 的事件响应（具体可以参考这里）。下面是具体的实现代码：html:1234&lt;div class="upload-area" id="upload-area"&gt; &lt;input type="file" id="select-file" class="select-file"&gt; &lt;button class="select-file-style" id="drop"&gt;选择或者拖拽 Markdown 文件到此&lt;/button&gt; &lt;/div&gt; css123456789101112131415161718192021222324252627282930.upload-area &#123; width: auto; height: 200px; margin: 0 2.6em 0 0.4em; padding: 0; position: relative; cursor: pointer; transition: height 0.5s;&#125;.upload-area .select-file &#123; border-width: 0px; width: 100%; height: 200px; margin: 0; cursor: pointer;&#125;.upload-area .select-file-style &#123; background: #F5F7FA; position: absolute; top: 0; left: 0; width: 100%; height: 200px; border: 0px; pointer-events: none; color: #AAB2BD; font-size: 2em; line-height: 2em; font-family: "Microsoft YaHei", "Tahoma", arial;&#125; 下面是效果图 读取文件内容因为程序完全是运行在浏览器端，所以我们使用 html5 的 FileReader 来读取本地文件。FileReader 提供 4 种读取文件的方式 readAsBinaryString(Blob|File) readAsText(Blob|File, opt_encoding) readAsDataURL(Blob|File) readAsArrayBuffer(Blob|File) 其中 readAsText 用来读取文本文件，readAsDataUrl 可以用来读取图片。具体的介绍可以参考 这里 。FileReader 一般结合文件选择事件或者拖拽事件使用，因为通过这两个事件可以获得源文件。另外 FileReader 是异步读取的，通过 onload 事件可以监听文件是否读取完毕。下面是一个示例, 通过点击 &lt;input type= &quot;file&quot;&gt; 选择文件，然后读取文件内容。12345678910document.getElementById("file-select").addEventListener("change", function(e) &#123; e.stopPropagation(); e.preventDefault(); var reader = new FileReader(); reader.readAsText(this.files[0]); reader.onload = function (e) &#123; var content = e.target.result; //...... &#125;;&#125;, false); 拖拽文件为了方便用户操作，我们提供了点击和拖拽两种方式来上传文件。现在的主流浏览器都支持文件拖拽功能，下面是拖拽过程中触发的事件 事件 描述 dragstart 用户开始拖动对象时触发。 dragenter 鼠标初次移到目标元素并且正在进行拖动时触发。这个事件的监听器应该之指出这个位置是否允许放置元素。如果没有监听器或者监听器不执行任何操作，默认情况下不允许放置。 dragover 拖动时鼠标移到某个元素上的时候触发。 dragleave 拖动时鼠标离开某个元素的时候触发。 drag 对象被拖拽时每次鼠标移动都会触发。 drop 拖动操作结束，放置元素时触发。 dragend 拖动对象时用户释放鼠标按键的时候触发。 另外在拖拽过程中是不触发鼠标事件的。文件读取完后文件信息会保存在 DataTransfer 对象中。详细的介绍可以参考 这里 。下面是添加事件的示例123fileSelect.addEventListener("dragenter", dragMdEnter, false);fileSelect.addEventListener("dragleave", dragMdLeave, false);fileSelect.addEventListener('drop', dropMdFile, false); 读取拖拽的文件1234567891011function dropMdFile(e) &#123; // 取消浏览器默认行为 e.stopPropagation(); e.preventDefault(); var reader = new FileReader(); reader.readAsText(e.dataTransfer.files[0]); reader.onload = function (e) &#123; var content = e.target.result; //...... &#125;;&#125; 本地图片显示因为没有服务器，所以为了显示本地图片，使用了替换图片 src 的方式。首先读取本地文件，然后将 &lt;img&gt; 的 src 路径替换为图片内容 。如下所示：123&lt;img src="path"&gt;// 替换为&lt;img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgI..."&gt; 下面是具体的代码实现：12345678910111213141516171819202122232425262728293031// 读取选择或者拖拽的文件（多个文件）function processImages(imgFiles) &#123; var index = 0; for (i = 0; i &lt; imgFiles.length; i++) &#123; var file = imgFiles[i]; var reader = new FileReader(); reader.readAsDataURL(file); (function (reader, file) &#123; reader.onload = function (e) &#123; cacheImages[file.name] = e.target.result; index++; if (index == length) &#123; replaceImage(); &#125; &#125; &#125;)(reader, file); &#125;&#125;// 将路径替换为图片内容function replaceImage() &#123; var images = $("img"); var i; for (i = 0; i &lt; images.length; i++) &#123; var imgSrc = images[i].src; var imgName = getImgName(imgSrc); if (cacheImages.hasOwnProperty(imgName)) &#123; images[i].src = cacheImages[imgName]; &#125; &#125;&#125; 如果图片过大，我们可以将图片压缩一下，具体方法就是创建一个 canvas 元素，将图片绘制到 canvas 上，然后将 canvas 转为图片。这种方式对 jpg 文件压缩效果较好，对 png 文件压缩效果不太好。下面是代码实现：12345678910111213141516171819202122function compressImage(img, format) &#123; var max_width = 862; var canvas = document.createElement('canvas'); var width = img.width; var height = img.height; if (format == null || format == "") &#123; format = "image/png"; &#125; if (width &gt; max_width) &#123; height = Math.round(height *= max_width / width); width = max_width; &#125; // resize the canvas and draw the image data into it canvas.width = width; canvas.height = height; var ctx = canvas.getContext("2d"); ctx.drawImage(img, 0, 0, width, height); return canvas.toDataURL(format);&#125; 循环中使用异步回调函数为了方便使用，我们可以同时上传多个图片，我们使用 for 循环来读取多个文件，但是有个问题是文件的读取是异步的，也就是说在 for 循环执行完之后，图片可能仍在读取中，当图片读取完后，再调用 onload 回调函数进行处理。简单一点就是说如何在 for 循环中正确使用延迟调用的回调函数。看下面的例子：1234567891011function print(value, callback) &#123; console.log("value in print", value); setTimeout(callback, 1000);&#125;for(var i = 0; i &lt; 4; i++) &#123; var value = i; print(value, function() &#123; console.log("value in callback", value); &#125;);&#125; 上面打的代码和我们读取图片文件的逻辑类似，callback 函数会在调用 print 函数1秒后执行，下面是输出结果12345678value in print 0value in print 1value in print 2value in print 3value in callback 3value in callback 3value in callback 3value in callback 3 最后在 callback 中 value 值都是3，这是因为在 js 中没有块级作用域，只有函数作用域，也就是说下面的两段代码是等同的：12345678910for(var i = 0; i &lt; 4; i++) &#123; var value = i; // do someting&#125;// 等同于var value;for(var i = 0; i &lt; 4; i++) &#123; value = i; // do someting&#125; 因此，为了解决这个问题，我们只需要为循环中的回调函数添加一个单独的作用域即可，我们使用闭包来实现：12345678for(var i = 0; i &lt; 4; i++) &#123; var value = i; (function(value) &#123; print(value, function() &#123; console.log("value in callback", value); &#125;); &#125;(value));&#125; 代码高亮我们使用两款代码高亮插件 – highlight.js 和 prism.js，根据喜好可以自由切换。这两款插件对代码块的 html 格式有不同的要求，我们重写了 marked 中解析代码块的方法，根据高亮方式来生成不同的 html 代码：123456renderer.code = function (code, lang) &#123; if (Setting.highlight == Constants.highlight) &#123; return "&lt;pre&gt;&lt;code class='" + lang + "'&gt;" + code + "&lt;/code&gt;&lt;/pre&gt;"; &#125; return "&lt;pre&gt;&lt;code class='language-" + lang + "'&gt;" + code + "&lt;/code&gt;&lt;/pre&gt;";&#125;; 然后调用 highlight.js 和 prism.js 的代码高亮方法即可123456789if (Setting.highlight == Constants.highlight) &#123; $('pre code').each(function (i, block) &#123; hljs.highlightBlock(block); &#125;);&#125; else &#123; // 添加行号支持 $("pre").addClass("line-numbers"); Prism.highlightAll();&#125; 目录为了生成文件的目录，我们需要首先获得目录信息，因此我们重写 marked 的 heading 方法， 将目录信息保存起来，同时为每个标题添加链接图标（仿照 github），下面是代码:123456789101112131415161718renderer.heading = function (text, level) &#123; var slug = text.toLowerCase().replace(/[\s]+/g, '-'); if (tocStr.indexOf(slug) != -1) &#123; slug += "-" + tocDumpIndex; tocDumpIndex++; &#125; tocStr += slug; toc.push(&#123; level: level, slug: slug, title: text &#125;); return "&lt;h" + level + " id=\"" + slug + "\"&gt;&lt;a href=\"#" + slug + "\" class=\"anchor\"&gt;" + '' + '&lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;' + '' + "&lt;/a&gt;" + text + "&lt;/h" + level + "&gt;";&#125;; 同时需要加入下面的 css，以是标题的链接图片正常显示：1234567891011121314151617181920h1:hover .anchor, h2:hover .anchor, h3:hover .anchor, h4:hover .anchor, h5:hover .anchor, h6:hover .anchor &#123; text-decoration: none&#125;h1:hover .anchor .octicon-link, h2:hover .anchor .octicon-link, h3:hover .anchor .octicon-link, h4:hover .anchor .octicon-link, h5:hover .anchor .octicon-link, h6:hover .anchor .octicon-link &#123; visibility: visible&#125;.octicon &#123; display: inline-block; vertical-align: text-top; fill: currentColor;&#125;.anchor &#123; float: left; padding-right: 4px; margin-left: -20px; line-height: 1;&#125; 为了生成目录，我们只需按照保存的目录信息，生成 &lt;ul&gt; 和 &lt;li&gt; 标签即可，具体的可以参考源码中的实现。 配置页面锚链接目录使用的是页内锚链接的方式进行跳转，如下面所示：1234&lt;a href="#h1"&gt;跳转到 H1&lt;/a&gt;...&lt;h1 id="h1"&gt;我是 H1&lt;/h1&gt;... 默认情况下，页内锚链接跳转之后，目标标签（上面代码中的 &lt;h1&gt; ）会移动到页面的最顶部，但是在我们的程序中有一个固定的 header，如果跳转到最顶部，目标标签会被 header 遮挡住，所以我们希望目标标签移动到距离页面顶部 header-height 的地方。为了实现我们的需要，只要加入下面的 css 代码即可。123456:target:before &#123; content:""; display:block; height:50px; /* fixed header height*/ margin:-50px 0 0; /* negative fixed header height */&#125; Todo 列表Todo 列表实际上就是 checkbox 的列表，完成的工作用选中的 checkbox 表示，未完成的工作用喂选中的列表表示，如下图所示： 一般来说，会将下面形式的 markdown 代码解析为 todo 列表123- [x] 完成- [ ] 未完成- [ ] 未完成 为了实现这个功能，我们重写 marked 中解析列表的方法，加入对 todo 列表的支持。12345678910renderer.listitem = function (text) &#123; if (/^\s*\[[x ]\]\s*/.test(text)) &#123; text = text .replace(/^\s*\[ \]\s*/, '&lt;input type="checkbox" class="task-list-item-checkbox" disabled&gt; ') .replace(/^\s*\[x\]\s*/, '&lt;input type="checkbox" class="task-list-item-checkbox" disabled checked&gt; '); return '&lt;li style="list-style: none"&gt;' + text + '&lt;/li&gt;'; &#125; else &#123; return '&lt;li&gt;' + text + '&lt;/li&gt;'; &#125;&#125;; 同时加入下面的样式：123456789.task-list-item-checkbox &#123; margin: 0 0.2em 0.25em -2.3em; vertical-align: middle;&#125;[type="checkbox"], [type="radio"] &#123; box-sizing: border-box; padding: 0;&#125; 缓存现在的浏览器都已经支持 localStorage，可以方便的存储数据。localStorage 就是一个对象。我们存储数据就是直接给它添加一个属性，可以通过 localStoage[&quot;a&quot;]=1 或者 localStorage.a = 1 的方式来存储数据，但是看起来总觉的不太优雅，因为一般使用下面的方式来操作 localStorage：123localStorage.setItem(key, vlaue);localStorage.getItem(key);localStorage.removeItem(key); 另外 localStorage 也有一些局限，使用时需要注意： 存储空间有限制，一般是 5M 左右，和浏览器有关 用户清除浏览器缓存之后有可能丢失本地缓存的数据 不能直接存对象，要先使用 JSON.stringfy 方法将对象进行序列化处理之后再保存。使用时需要使用 JSON.parse 方法将字符串转为对象。 导出文件通过使用 FileSaver.js，我们可以方便的在浏览器端生成文件，并提供给用户下载。使用方法也很简单：12var blob = new Blob([htmlContent], &#123;type: "text/html;charset=utf-8"&#125;);saveAs(blob, name); 扩展我们提供了一些扩展功能，用来更好的展示 markdown 内容。在现在的程序中我们可以很方便的添加扩展功能，下面会具体介绍。 自定义扩展为了添加扩展，我们首先需要确定哪些内容需要作为扩展处理。因为在将 markdown 文件转为 html 的过程中，一般是不处理代码块中的内容的，所以我们使用代码块来存放扩展内容，通过代码块的语言来确定是哪种扩展。以添加序列图扩展为例： 确定时序图的代码标记 修改 marked 中对于代码块的解析函数，添加对于时序图标记的支持 1234567891011121314151617var renderer = new marked.Renderer();var originalCodeFun = function (code, lang) &#123; if (Setting.highlight == Constants.highlight) &#123; return "&lt;pre&gt;&lt;code class='" + lang + "'&gt;" + code + "&lt;/code&gt;&lt;/pre&gt;"; &#125; return "&lt;pre&gt;&lt;code class='language-" + lang + "'&gt;" + code + "&lt;/code&gt;&lt;/pre&gt;";&#125;;renderer.code = function (code, language) &#123; if (language == "seq") &#123; return "&lt;div class='diagram' id='diagram'&gt;" + code + "&lt;/div&gt;" &#125; else &#123; return originalCodeFun.call(this, code, language); &#125;&#125;;marked.setOptions(&#123; renderer: renderer&#125;); 引入 js-sequence-diagrams 相关文件 12345&lt;link href="&#123;&#123; bower directory &#125;&#125;/js-sequence-diagrams/dist/sequence-diagram-min.css" rel="stylesheet" /&gt;&lt;script src="&#123;&#123; bower directory &#125;&#125;/bower-webfontloader/webfont.js" /&gt;&lt;script src="&#123;&#123; bower directory &#125;&#125;/snap.svg/dist/snap.svg-min.js" /&gt;&lt;script src="&#123;&#123; bower directory &#125;&#125;/underscore/underscore-min.js" /&gt;&lt;script src="&#123;&#123; bower directory &#125;&#125;/js-sequence-diagrams/dist/sequence-diagram-min.js" /&gt; 渲染 Markdown 文件时，调用相关函数 1$(".diagram").sequenceDiagram(&#123;theme: 'simple'&#125;); 添加扩展会影响文件的渲染速度，如果不需要某个扩展可以手动关闭。 Mathjax使用Mathjax 对数学公式进行支持。关于Mathjax 语法，请参考这里。下面是添加扩展的流程： 引入文件并配置 123456789101112131415161718192021&lt;script type="text/x-mathjax-config"&gt; MathJax.Hub.Config(&#123;tex2jax: &#123;inlineMath: [['$','$'], ['\\(','\\)']]&#125;, TeX: &#123; equationNumbers: &#123; autoNumber: ["AMS"], useLabelIds: true &#125; &#125;, "HTML-CSS": &#123; linebreaks: &#123; automatic: true &#125; &#125;, SVG: &#123; linebreaks: &#123; automatic: true &#125; &#125; &#125;);&lt;/script&gt;&lt;script type="text/javascript" src="http://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"&gt;&lt;/script&gt; 将 markdown 文件转为 html 之后，调用 Mathjax 中的方法将对应标记转为数学公式。 12// content 是需要处理的 html 标签的 idMathJax.Hub.Queue(["Typeset", MathJax.Hub, "content"]); Emoji使用 emojify.js 来提供对 Emoji 标签的支持。Emoji表情参见 EMOJI CHEAT SHEET。下面是添加扩展的流程 引用文件并配置 123456789101112131415&lt;script src="http://cdn.bootcss.com/emojify.js/1.1.0/js/emojify.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;trueemojify.setConfig(&#123; emojify_tag_type: 'div', // Only run emojify.js on this element only_crawl_id: null, // Use to restrict where emojify.js applies img_dir: 'http://cdn.bootcss.com/emojify.js/1.0/images/basic', // Directory for emoji images ignored_tags: &#123; // Ignore the following tags 'SCRIPT': 1, 'TEXTAREA': 1, 'A': 1, 'PRE': 1, 'CODE': 1 &#125; &#125;);&lt;/script&gt; 将 markdown 文件转为 html 之后，调用 emojify 中的方法将对应标记转换 emoji 表情。 1emojify.run(document.getElementById('content')) 图表 （ECharts）使用 ECharts 来提供对图表的支持。ECharts 的语法可以参考 官网的示例。下面是使用方法： 确定 ECharts 在 markdown 中的语法标签 在 code 方法解析中添加对 echarts 的支持 12345678910111213141516171819202122232425262728293031323334renderer.code = function (code, language) &#123; switch (language) &#123; ... case "echarts": if (Setting.echarts) &#123; return loadEcharts(code); &#125; return originalCodeFun.call(this, code, language); ... &#125;&#125;;function loadEcharts(text) &#123; var width = "100%"; var height = "400px"; try &#123; var options = eval("(" + text + ")"); if (options.hasOwnProperty("width")) &#123; width = options["width"]; &#125; if (options.hasOwnProperty("height")) &#123; height = options["height"]; &#125; echartIndex++; echartData.push(&#123; id: echartIndex, option: options, previousOption: text &#125;); return '&lt;div id="echarts-' + echartIndex + '" style="width: ' + width + ';height:' + height + ';"&gt;&lt;/div&gt;' &#125; catch (e) &#123; console.log(e); return ""; &#125;&#125; 将 markdown 文件转为 html 之后，调用 echarts 中的方法，将对应的 div 转为图表： 123456789var chart;echartData.forEach(function (data) &#123; if (data.option.theme) &#123; chart = echarts.init(document.getElementById('echarts-' + data.id), data.option.theme); &#125; else &#123; chart = echarts.init(document.getElementById('echarts-' + data.id)); &#125; chart.setOption(data.option);&#125;); 评论在生成Github Page页面时，我们可以选择添加 多说 或者 Disqus 评论，其中多说就是在导出的页面中加入下面的代码1234567891011121314&lt;div class="ds-thread" data-thread-key="" data-title="" data-url=""&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var duoshuoQuery = &#123; short_name: "" &#125;; (function() &#123; var ds = document.createElement("script"); ds.type = "text/javascript"; ds.async = true; ds.src = (document.location.protocol == "https:" ? "https:" : "http:") + "//static.duoshuo.com/embed.js"; ds.charset = "UTF-8"; (document.getElementsByTagName("head")[0] || document.getElementsByTagName("body")[0]).appendChild(ds); &#125;)();&lt;/script&gt; 其中 data-thread-key, data-title, data-url 和 short_name 是需要我们自定义的东西。而Disqus 需要在导出时插入下面的代码：12345678910111213141516&lt;div id="disqus_thread"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var disqus_shortname = ''; var prefix = document.location.protocol == "https:" ? "https:" : "http:" var disqus_config = function() &#123; this.page.url = ""; this.page.identifier = "" &#125;; (function() &#123; var d = document, s = d.createElement('script'); s.src = prefix + '//' + disqus_shortname + '.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); &#125;)();&lt;/script&gt; 其中 disqus_shortname, page.url 和 page.indertifier 是需要我们自定义的东西。这里需要注意的是 page.url 要使用绝对路径。 具体的插入逻辑可参考源码的实现，这里不再赘述。]]></content>
      <categories>
        <category>应用</category>
      </categories>
      <tags>
        <tag>应用</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HTML5】Canvas 内部元素添加事件处理]]></title>
    <url>%2F2016%2F12%2F06%2F%E3%80%90HTML5%E3%80%91Canvas%E5%85%83%E7%B4%A0%E6%B7%BB%E5%8A%A0%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言canvas 没有提供为其内部元素添加事件监听的方法，因此如果要使 canvas 内的元素能够响应事件，需要自己动手实现。实现方法也很简单，首先获得鼠标在 canvas 上的坐标，计算当前坐标在哪些元素内部，然后对元素进行相应的操作。配合自定义事件，我们就可以实现为 canvas 内的元素添加事件监听的效果。 源码 &nbsp;&nbsp;&nbsp;演示 自定义事件为了实现javascript对象的自定义事件，我们可以创建一个管理事件的对象，该对象中包含一个内部对象（当作map使用，事件名作为属性名，事件处理函数作为属性值，因为可能有个多个事件处理函数，所以使用数组存储事件处理函数），存储相关的事件。然后提供一个激发事件的函数，通过使用 call 方法来调用之前绑定的函数。下面是代码示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667(function () &#123; cce.EventTarget = function () &#123; this._listeners = &#123;&#125;; this.inBounds = false; &#125;; cce.EventTarget.prototype = &#123; constructor: cce.EventTarget, // 查看某个事件是否有监听 hasListener: function (type) &#123; if (this._listeners.hasOwnProperty(type)) &#123; return true; &#125; else &#123; return false; &#125; &#125;, // 为事件添加监听函数 addListener: function (type, listener) &#123; if (!this._listeners.hasOwnProperty(type)) &#123; this._listeners[type] = []; &#125; this._listeners[type].push(listener); cce.EventManager.addTarget(type, this); &#125;, // 触发事件 fire: function (type, event) &#123; if (event == null || event.type == null) &#123; return; &#125; if (this._listeners[event.type] instanceof Array) &#123; var listeners = this._listeners[event.type]; for (var i = 0, len = listeners.length; i &lt; len; i++) &#123; listeners[i].call(this, event); &#125; &#125; &#125;, // 如果listener 为null，则清除当前事件下的全部事件监听 removeListener: function (type, listener) &#123; if (listener == null) &#123; if (this._listeners.hasOwnProperty(type)) &#123; this._listeners[type] = []; cce.EventManager.removeTarget(type, this); &#125; &#125; if (this._listeners[type] instanceof Array) &#123; var listeners = this._listeners[type]; for (var i = 0, len = listeners.length; i &lt; len; i++) &#123; if (listeners[i] === listener) &#123; listeners.splice(i, 1); if (listeners.length == 0) cce.EventManager.removeTarget(type, this); break; &#125; &#125; &#125; &#125; &#125;;&#125;()); 在上面的代码中，EventManager 用来存储所有绑定了事件监听的对象，便于后面判断鼠标是否位于某个对象内部。如果一个自定义对象需要添加事件监听，只需要继承 EventTarget。 有序数组在判断触发某个事件的元素时，需要遍历所有绑定了该事件的元素，判断鼠标位置是否位于元素内部。为了减少不必要的比较，这里使用了一个有序数组，使用元素区域的最小 x 值作为比较值，按照升序排列。如果一个元素区域的最小 x 值大于鼠标的 x 值，那么就无需比较数组中该元素后面的元素。具体实现可以看 SortArray.js 元素父类这里设计了一个抽象类，来作为所有元素对象的父类，该类继承了 EventTarget，并且定义了三个函数，所有子类都应该实现这三个函数。 具体代码如下所示：12345678910111213141516171819202122232425262728293031(function () &#123; // 抽象类，该类继承了事件处理类，所有元素对象应该继承这个类 // 为了实现对象比较，继承该类时应该同时实现compareTo, comparePointX 以及 hasPoint 方法。 cce.DisplayObject = function () &#123; cce.EventTarget.call(this); this.canvas = null; this.context = null; &#125;; cce.DisplayObject.prototype = Object.create(cce.EventTarget.prototype); cce.DisplayObject.prototype.constructor = cce.DisplayObject; // 在有序数组中会根据这个方法的返回结果将对象排序 cce.DisplayObject.prototype.compareTo = function (target) &#123; return null; &#125;; // 比较目标点的x值与当前区域的最小 x 值，结合有序数组使用，如果 point 的 x 小于当前区域的最小 x 值，那么有序数组中剩余 // 元素的最小 x 值也会大于目标点的 x 值，就可以停止比较。在事件判断时首先使用该函数过滤一下。 cce.DisplayObject.prototype.comparePointX = function (point) &#123; return null; &#125;; // 判断目标点是否在当前区域内 cce.DisplayObject.prototype.hasPoint = function (point) &#123; return false; &#125;;&#125;()); 事件判断以鼠标事件为例，这里我们实现了 mouseover, mousemove, mouseout 三种鼠标事件。首先对 canvas 添加 mouseover事件，当鼠标在 canvas 上移动时，会时时对比当前鼠标位置与绑定了上述三种事件的元素的位置，如果满足了触发条件就调用元素的 fire 方法触发对应的事件。下面是示例代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344_handleMouseMove: function (event, container) &#123; // 这里传入container 主要是为了使用 _windowToCanvas函数 var point = container._windowToCanvas(event.clientX, event.clientY); // 获得绑定了 mouseover, mousemove, mouseout 事件的元素对象 var array = cce.EventManager.getTargets("mouse"); if (array != null) &#123; array.search(point); // 鼠标所在的元素 var selectedElements = array.selectedElements; // 鼠标不在的元素 var unSelectedElements = array.unSelectedElements; selectedElements.forEach(function (ele) &#123; if (ele.hasListener("mousemove")) &#123; var event = new cce.Event(point.x, point.y, "mousemove", ele); ele.fire("mousemove", event); &#125; // 之前不在区域内，现在在了，说明鼠标进入了 if (!ele.inBounds) &#123; ele.inBounds = true; if (ele.hasListener("mouseover")) &#123; var event = new cce.Event(point.x, point.y, "mouseover", ele); ele.fire("mouseover", event); &#125; &#125; &#125;); unSelectedElements.forEach(function (ele) &#123; // 之前在区域内，现在不在了，说明鼠标离开了 if (ele.inBounds) &#123; ele.inBounds = false; if (ele.hasListener("mouseout")) &#123; var event = new cce.Event(point.x, point.y, "mouseout", ele); ele.fire("mouseout", event); &#125; &#125; &#125;); &#125;&#125; 其他立即执行函数诸如下面形式的函数称之为立即执行函数。123(function() &#123; // code&#125;()); 使用立即执行函数的好处就是它限定了变量的作用域，使在立即执行函数中定义变量不会污染其他作用域，更加详细的讲解请看这里 apply, call, bind这三个函数的使用类似于java 反射中的 Method.invoke，方法作为一个主体，将执行方法的对象作为参数传入到方法里。其中 apply 和 call 作用一样，调用后都会立即执行，只是接受参数的形式不同。12func.call(this, arg1, arg2);func.apply(this, [arg1, arg2]) 而 bind 会返回对应函数，不会立即执行，便于以后调用。 看下面的例子：1234567function aa() &#123; console.log(111); console.log(this);&#125;var bb = aa.bind(Math);bb(); 更加详细的讲解请看这里 addEventListener 传参如果给某个元素添加事件监听时需要传递参数，可以使用下面的方法1234var i = 1;aa.addEventListener("click", function() &#123; bb(i);&#125;, false); 调用父类的构造函数使用 call 即可123Child = function() &#123; Parent.call(this);&#125; 对象检测 判断对象为 null 或者 undefined 1234// `null == undefined` 为trueif (variable == null) &#123; // code&#125; 判断对象是否有某个属性 1234567if(myObj.hasOwnProperty("&lt;property name&gt;"))&#123; alert("yes, i have that property");&#125;// 或者if("&lt;property name&gt;" in myObj) &#123; alert("yes, i have that property");&#125; isPointInPathcanvas中判断点是否在某个路径内部，可以用于多边形的检测。不过 isPointInPath 使用路径是最后一次绘制的图形，如果有多个图形需要判断，需要将前面的图形路径保存下来，判断时需要重新构造路径，不过不需要绘制，如下面123456789101112131415this.context.save();this.context.beginPath();//console.log(this.points);this.context.moveTo(this.points[0].x, this.points[0].y);for (var i = 1; i &lt; this.points.length; i++) &#123; this.context.lineTo(this.points[i].x, this.points[i].y);&#125;if (this.context.isPointInPath(target.x, target.y)) &#123; isIn = true;&#125;this.context.closePath();this.context.restore(); 参考文章： Custom events in JavaScript javascript中constructor的作用 【优雅代码】深入浅出 妙用Javascript中apply、call、bind 深入理解JavaScript系列（4）：立即调用的函数表达式 Using Super Constructors Is Critical In Prototypal Inheritance In Javascript]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSS 学习笔记】CSS元素和布局]]></title>
    <url>%2F2016%2F11%2F29%2F%E3%80%90CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91CSS%E5%85%83%E7%B4%A0%E5%92%8C%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[前言本文绝大部分摘自 CSS 权威指南 第三版 基本概念 正常流 (Normal Flow)： 有时会被翻译为 文档流 或者 普通流，指文档从左至右、从上至下的显示内容，是传统的 HTML 文档布局。如果使元素不在正常流中，可以使用浮动（float）或者定位（absolute, fixed）。 块级元素 (Block-level)： 块级元素在普通流中会独占一行，即在其框之前和之后生成“换行”，因此处于普通流中的块级元素会按照从上到下的顺序垂直（vertically）排列。常见的 block 元素有 div, p, h1-h6, ul, li, canvas, table 等。完整的元素可以参考这里。通过使用 display:block，可以将元素生成块级框。 内联元素 (Inline)： 或者称为 行内元素。在普通流中的内联元素之间不会生成“行分割符”，因此处于普通流中的内联元素会首先按照从左至右的顺序水平（horizontally）排列，当父容器水平方向上的剩余宽度不足以放下新的内联元素时，会往下换行，在新行的中继续按照水平顺序排列元素。常见的 inline 元素有：a, img, button, br, input, label, select, textarea。完整的可以参考这里通过使用 display:inline 可以让元素变成内联元素。 非替换元素 (non-replaced)： 如果元素的内容包含在文档中，就成为非替换元素。 例如段落 &lt;p&gt;。 替换元素 (replaced)： 可以理解为嵌入元素，相当于一个占位符，解析时会被其他内容替换。例如 &lt;img&gt; 和大部分表单元素 &lt;input type=&quot;radio&quot;&gt;。 em: 1em等于 font-size 的设置值 盒模型 (Box-Model) 在盒子模型中，水平和垂直方向上各有7个属性: 水平方向 - margin-left, border-left, padding-left, width, padding-right, border-right, margin-right 垂直方向 - margin-top, border-top, padding-top, height, padding-bottom, border-bottom, margin-bottom 其中 margin 称为外边距，在计算元素整体宽高的时候一般不包括它。CSS3 中新增了一个属性 box-sizing，可以用来指定使用的盒模型计算方式。下面是 CSS3 中支持的盒模型计算方式（CSS2种只支持默认的） content-box（默认值）: width 和 height 属性只作用到 Content Area 的长宽，在 Content Area 外面绘制内边距和边框，见图 (1)。 Width = width + padding-left + padding-right + border-left + border-right Height = height + padding-top + padding-bottom + border-top + border-bottom border-box: width 和 height 属性设置的值就为元素整体的宽高，内边距和边框在已设定的宽度和高度内进行绘制，见图 (2)。 Width = width Height = height inherit: 继承父类的属性 块级元素 auto在上面提到的几个属性中，只有margin, width, height 可以设为 auto，padding 和 border 必须设定为特定值或者使用默认值。 水平属性在上面提到的7个水平属性中，只有3个值可以设置为 auto：width, margin-left, margin-right。其余属性必须设置为特定的值或者使用默认值。下面是使用 auto 的几种情形： 没有一个属性设为 auto： 如果 width, margin-left, margin-right 这三个属性都设为非 auto 的特定值，那么会将 margin-right 强制为 auto。 有且只有一个属性设为 auto： 如果三个属性中某个值设为 auto，而余下的两个属性设为特定的值，那么设置为 auto 的属性值会自动确定所需长度，从而使元素框的总宽度（上面提到的7种属性相加）等于父容器的 width。 两个外边距都设为 auto，width 设为特定值： 元素会居中（常用的居中方式），margin-left 和 margin-right 会设为相等的长度 width 设为 auto，外边距有一个或者两个均设为 auto： 设为 auto 的外边距会变成0，如果两个外边距都设为 auto，会都变为0。 垂直属性 如果 margin-top 和 margin-bottom 都设为 auto（对于定位元素会有不同），会将它们计算为0。 height 设为 auto，一般等于其包含的子元素的总高度。 外边距合并针对垂直外边距（margin-top 和 margin-bottom），两个相邻的垂直外边距会合并成一个外边距，两个外边距中较小的一个会被较大的一个合并。详细内容可以参考 这里 。 如果外边距中有负值： 如果相邻的垂直外边距都设为负值，会取外边距中绝对值较大的那个外边距。例如一个外边距为：margin-bottom:-10px，和它相邻的另外一个为：margin-top:-20px，会保留 margin-top:-20px。 如果一个正外边距和一个负外边距，会从正外边距减去负外边距的绝对值。例如一个外边距为: margin-bottom:20px，另外一个为: margin-top:-10px，最终的效果相当于 margin-bottom:10px。 负外边距外边距可以是负的，即 margin 可以设为负值，此时子元素的 width 或者 height 就有可能大于父元素的 width。只有外边距能小于0，内边距、边框和内容的宽高都不能设为负值。 内联元素东西比较多，先附一些文章链接： CSS 中的line-height CSS 行高line-height的一些深入理解及应用 CSS line-height 中文版 视觉格式化模型中的各种框 CSS权威指南 行内框（inline-box）http://meyerweb.com/eric/css/inline-format.htmlhttps://www.w3.org/TR/CSS21/visuren.html#inline-box 行内框通过向内容区（context-area）增加行间距（leading）来描述。对于非替换元素来说，元素行内框的高度刚好等于 line-height 的值。对于替换元素来说，元素行内框的高度等于元素的 height + margin-top + margin-bottom + padding-top + padding-bottom + border-top + border-bottom。浏览器会根据行内元素行内框的大小来对元素布局。假设行内元素的内容区高 20px，但是 line-height 只有 14px，那么为该元素分配的高度只有 14px，就会出现内容去溢出的情况（覆盖其他的行元素）。 非替换元素 margin, border, padding 不影响行内框的高度，但是会影响行内框的宽度。 width 和 height 属性不会作用于行内非替换元素，即不能设置宽高。 替换元素 替换元素的 margin, border. padding 会影响行内框的宽度和高度 可以对替换元素设置 width 和 height。如果不设置宽高，会使用元素本来的宽度和高度。 设置line-height的几种方式line-height 只作用于内联元素或者其他的内联内容。 normal - 默认值，设置合理的行间距（1.2） 具体的长度 - 12px 、1em 等等 纯数字 - 和当前 font-size 的比值 百分比 - 和当前 font-size 的百分比 inherit - 从父类中继承 注意点 内联非替换元素的 width 和 height 是不起作用的 padding 和 border 不改变 line-height margin-top 和 margin-bottom 不作用于行内非替换元素，比如 span 修改显示类别使用 display:value 可以修改元素的类别。有效值如下： 值 描述 none 此元素不会被显示。 block 此元素将显示为块级元素，此元素前后会带有换行符。 inline 默认。此元素会被显示为内联元素，元素前后没有换行符。 inline-block 行内块元素。（CSS2.1 新增的值） list-item 此元素会作为列表显示。 run-in 此元素会根据上下文作为块级元素或内联元素显示。 compact CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 marker CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 table 此元素会作为块级表格来显示（类似 table），表格前后带有换行符。 inline-table 此元素会作为内联表格来显示（类似 table），表格前后没有换行符。 table-row-group 此元素会作为一个或多个行的分组来显示（类似 tbody）。 table-header-group 此元素会作为一个或多个行的分组来显示（类似 thead）。 table-footer-group 此元素会作为一个或多个行的分组来显示（类似 tfoot）。 table-row 此元素会作为一个表格行显示（类似 tr）。 table-column-group 此元素会作为一个或多个列的分组来显示（类似 colgroup）。 table-column 此元素会作为一个单元格列显示（类似 col） table-cell 此元素会作为一个表格单元格显示（类似 td 和 th） table-caption 此元素会作为一个表格标题显示（类似 caption） inherit 规定应该从父元素继承 display 属性的值。 inline-block：会使元素表现的像行内非替换元素一样，是行内元素，但是可以设置宽高，margin, border, padding 会影响行内框的高度 run-in：使某些块级元素成为下一个元素的行内元素(chrome不支持)。 浮动(float)MDN floatw3 float 定义下面是MDN上关于 float 的定义 The float CSS property specifies that an element should be taken from the normal flow and placed along the left or right side of its container, where text and inline elements will wrap around it. 根据定义需要注意的有下面三点： 浮动元素会脱离正常流。 浮动元素会被放置在所在容器的左侧或者右侧。 文字和行内元素会环绕浮动元素，所以会影响布局。 其他注意点 浮动元素会生成一个块级框，即便元素本身是行内元素，也会生成块级框。所以不需要为浮动元素声明 display:block。 浮动元素的外边距不会合并。 浮动元素之间一般不会重叠（外边距设为负值就可能会重叠），会按照顺序排序，如果当前行剩余的宽度不足以放下新的元素，会另起一行。 浮动元素会延伸，从而包含其所有的代浮动元素。 重叠如果浮动元素和正常流中的内容发生重叠（浮动元素的外边距为负值），会按照以下规则显示内容： 行内框和一个浮动元素重叠时，其边框、背景和内容都会在该浮动元素 之上 显示 框框与一个浮动元素重叠时，其边框和背景在该浮动元素 之下 显示，内容在浮动元素 之上 显示 清除浮动清除浮动就是让元素的左边或者右边或者两边不会有浮动元素出现。清除浮动的一个主要的原因就是增加父容器的高度，当子元素浮动时，会脱离正常流，因此父元素计算高度时不会加上浮动子元素的高度，就会造成父元素的高度小于浮动子元素。当清除浮动之后，父容器就可以正确高度。下面是清除浮动的几种方式，更多方式可以参考 这里 ： 使用带clear元素的空属性 1234.clear&#123; clear:both;&#125;&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; 使用 :after 伪元素 12345678.clearfix:after &#123; clear:both; content:'\20'; display:block; height: 0; visibility:hidden&#125;&lt;div class="clearfix"&gt;&lt;/div&gt; 在父容器里添加 overflow:auto 或者 overflow:hidden 定位CSS 有三种基本的定位机制: 正常流、浮动和绝对定位。使用 position 可以设置不同类型的定位方式。下面是 position 属性值的定义: static：默认值，元素框正常生成，不会被特殊的定位。块级元素生成块级块，行内元素生成一个或者多个行框，置于其父元素中。 relative: 元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。relative 的表现和 static 十分类似，不同的是相对于定位参考的是它应该在的位置(或者说它自身的位置)，通过使用偏移属性 top, bottom, left 和 right 属性会使元素相对于 它的起点进行移动。其他元素的位置不会受到影响。 absolute: 元素会脱离正常流，相对于其最近的非 static 定位的祖先元素定位，如果没有满足条件的祖先元素，则会相对于文档的 body 元素。元素在正常流中的所占的位置会被清除，就好像该元素不存在一样。absolute 元素会生成一个块级框。 fixed: 和 absolute 类似，不过其定位的参考元素是视窗，当页面滚动时还是会停留在原先的位置。 absolute 会跟随父元素滚动。 其他注意点 一般称 relative, absolute 以及 fixed 为定位元素 (positioned) 除了 static，其他三种定位都可以使用偏移属性 top, bottom, left, right。 absolute 定位里 left, right, width，有一个值设为 auto，会自动调整其大小，使总长度相加等于父容器宽度。如果有没有auto，会重置 right。top 和 bottom 类似。 z-index利用 z-index 可以修改元素相互的覆盖顺序。所有数都可以作为 z-index 的值，包括负数。需要注意的是 z-index 只能作用于定位元素，static 元素会失效 子元素会继承父元素的 z-index，子元素设置的 z-index 是相对于父元素的局部 z-index。比如下面的代码：1234567891011121314.p1 &#123; position:absolute; z-index:2;&#125;.p2 &#123; position:absolute; z-index:1;&#125;.p1 .c &#123; z-index: 10;&#125;.p2 .c&#123; z-index:100;&#125; .p2 .c 会在 .p1 .c 的下面]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HTML5】Canvas 实现放大镜效果]]></title>
    <url>%2F2016%2F10%2F09%2F%E3%80%90HTML5%E3%80%91Canvas-%E6%94%BE%E5%A4%A7%E9%95%9C%2F</url>
    <content type="text"><![CDATA[图片放大镜效果在线演示 &nbsp;&nbsp; 源码 原理首先选择图片的一块区域，然后将这块区域放大，然后再绘制到原先的图片上，保证两块区域的中心点一致, 如下图所示: 初始化1234&lt;canvas id="canvas" width="500" height="500"&gt;&lt;/canvas&gt;&lt;img src="image.png" style="display: none" id="img"&gt; 获得 canvas 和 image 对象，这里使用 &lt;img&gt; 标签预加载图片, 关于图片预加载可以看这里123var canvas = document.getElementById("canvas");var context = canvas.getContext("2d");var img = document.getElementById("img"); 设置相关变量12345678910// 图片被放大区域的中心点，也是放大镜的中心点var centerPoint = &#123;&#125;;// 图片被放大区域的半径var originalRadius = 100;// 图片被放大区域var originalRectangle = &#123;&#125;;// 放大倍数var scale = 2;// 放大后区域var scaleGlassRectangle 画背景图片123function drawBackGround() &#123; context.drawImage(img, 0, 0);&#125; 计算图片被放大的区域的范围这里我们使用鼠标的位置作为被放大区域的中心点(放大镜随着鼠标移动而移动)，因为 canvas 在画图片的时候，需要知道左上角的坐标以及区域的宽高，所以这里我们计算区域的范围123456function calOriginalRectangle(point) &#123; originalRectangle.x = point.x - originalRadius; originalRectangle.y = point.y - originalRadius; originalRectangle.width = originalRadius * 2; originalRectangle.height = originalRadius * 2;&#125; 绘制放大镜区域裁剪区域放大镜一般是圆形的，这里我们使用 clip 函数裁剪出一个圆形区域，然后在该区域中绘制放大后的图。一旦裁减了某个区域，以后所有的绘图都会被限制的这个区域里，这里我们使用 save 和 restore 方法清除裁剪区域的影响。save 保存当前画布的一次状态，包含 canvas 的上下文属性，例如 style，lineWidth 等，然后会将这个状态压入一个堆栈。restore 用来恢复上一次 save 的状态，从堆栈里弹出最顶层的状态。123456context.save();context.beginPath();context.arc(centerPoint.x, centerPoint.y, originalRadius, 0, Math.PI * 2, false);context.clip();......context.restore(); 计算放大镜区域通过中心点、被放大区域的宽高以及放大倍数，获得区域的左上角坐标以及区域的宽高。123456scaleGlassRectangle = &#123; x: centerPoint.x - originalRectangle.width * scale / 2, y: centerPoint.y - originalRectangle.height * scale / 2, width: originalRectangle.width * scale, height: originalRectangle.height * scale&#125; 绘制图片在这里我们使用 context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height); 方法，将 canvas 自身作为一副图片，然后取被放大区域的图像，将其绘制到放大镜区域里。123456context.drawImage(canvas, originalRectangle.x, originalRectangle.y, originalRectangle.width, originalRectangle.height, scaleGlassRectangle.x, scaleGlassRectangle.y, scaleGlassRectangle.width, scaleGlassRectangle.height); 绘制放大边缘createRadialGradient 用来绘制渐变图像12345678910111213context.beginPath();var gradient = context.createRadialGradient( centerPoint.x, centerPoint.y, originalRadius - 5, centerPoint.x, centerPoint.y, originalRadius);gradient.addColorStop(0, 'rgba(0,0,0,0.2)');gradient.addColorStop(0.80, 'silver');gradient.addColorStop(0.90, 'silver');gradient.addColorStop(1.0, 'rgba(150,150,150,0.9)');context.strokeStyle = gradient;context.lineWidth = 5;context.arc(centerPoint.x, centerPoint.y, originalRadius, 0, Math.PI * 2, false);context.stroke(); 添加鼠标事件为 canvas 添加鼠标移动事件123canvas.onmousemove = function (e) &#123; ......&#125; 转换坐标鼠标事件获得坐标一般为屏幕的或者 window 的坐标，我们需要将其装换为 canvas 的坐标。getBoundingClientRect 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置。1234function windowToCanvas(x, y) &#123; var bbox = canvas.getBoundingClientRect(); return &#123;x: x - bbox.left, y: y - bbox.top&#125;&#125; 修改鼠标样式我们可以通过 css 来修改鼠标样式123456#canvas &#123; display: block; border: 1px solid red; margin: 0 auto; cursor: crosshair;&#125; 图表放大镜我们可能基于 canvas 绘制一些图表或者图像，如果两个元素的坐标离得比较近，就会给元素的选择带来一些影响，例如我们画两条线，一个线的坐标是(200.5, 400) -&gt; (200.5, 200)，另一个线的坐标为 (201.5, 400) -&gt; (201.5, 20)，那么这两条线几乎就会重叠在一起，如下图所示：使用图表放大镜的效果 在线演示 &nbsp;&nbsp; 源码 原理类似于地图中的图例，放大镜使用较为精确的图例，如下图所示： 在放大镜坐标系统中，原始的区域会变大，如下图所示 绘制原始线段首先创建一个线段对象1234567891011121314function Line(xStart, yStart, xEnd, yEnd, index, color) &#123; // 起点x坐标 this.xStart = xStart; // 起点y坐标 this.yStart = yStart; // 终点x坐标 this.xEnd = xEnd; // 终点y坐标 this.yEnd = yEnd; // 用来标记是哪条线段 this.index = index; // 线段颜色 this.color = color;&#125; 初始化线段12345678910111213141516171819202122232425262728293031// 原始线段var chartLines = new Array();// 处于放大镜中的原始线段var glassLines;// 放大后的线段var scaleGlassLines;// 位于放大镜中的线段数量var glassLineSize;function initLines() &#123; var line; line = new Line(200.5, 400, 200.5, 200, 0, "#888"); chartLines.push(line); line = new Line(201.5, 400, 201.5, 20, 1, "#888"); chartLines.push(line); glassLineSize = chartLines.length; glassLines = new Array(glassLineSize); for (var i = 0; i &lt; glassLineSize; i++) &#123; line = new Line(0, 0, 0, 0, i); glassLines[i] = line; &#125; scaleGlassLines = new Array(glassLineSize); for (var i = 0; i &lt; glassLineSize; i++) &#123; line = new Line(0, 0, 0, 0, i); scaleGlassLines[i] = line; &#125;&#125; 绘制线段12345678910111213function drawLines() &#123; var line; context.lineWidth = 1; for (var i = 0; i &lt; chartLines.length; i++) &#123; line = chartLines[i]; context.beginPath(); context.strokeStyle = line.color; context.moveTo(line.xStart, line.yStart); context.lineTo(line.xEnd, line.yEnd); context.stroke(); &#125;&#125; 计算原始区域和放大镜区域1234567891011121314151617function calGlassRectangle(point) &#123; originalRectangle.x = point.x - originalRadius; originalRectangle.y = point.y - originalRadius; originalRectangle.width = originalRadius * 2; originalRectangle.height = originalRadius * 2; scaleGlassRectangle.width = originalRectangle.width * scale; scaleGlassRectangle.height = originalRectangle.height * scale; scaleGlassRectangle.x = originalRectangle.x + originalRectangle.width / 2 - scaleGlassRectangle.width / 2; scaleGlassRectangle.y = originalRectangle.y + originalRectangle.height / 2 - scaleGlassRectangle.height / 2; // 将值装换为整数 scaleGlassRectangle.width = parseInt(scaleGlassRectangle.width); scaleGlassRectangle.height = parseInt(scaleGlassRectangle.height); scaleGlassRectangle.x = parseInt(scaleGlassRectangle.x); scaleGlassRectangle.y = parseInt(scaleGlassRectangle.y);&#125; 计算线段在新坐标系统的位置由原理图我们知道，放大镜中使用坐标系的图例要比原始坐标系更加精确，比如原始坐标系使用 1:100，那么放大镜坐标系使用 1:10，因此我们需要重新计算线段在放大镜坐标系中的位置。同时为了简便，我们将线段的原始坐标进行了转化，减去原始区域起始的x值和y值，即将原始区域左上角的点看做为(0,0)。1234567891011121314151617181920212223242526272829303132333435363738394041function calScaleLines() &#123; var xStart = originalRectangle.x; var xEnd = originalRectangle.x + originalRectangle.width; var yStart = originalRectangle.y; var yEnd = originalRectangle.y + originalRectangle.height; var line, gLine, sgLine; var glassLineIndex = 0; for (var i = 0; i &lt; chartLines.length; i++) &#123; line = chartLines[i]; // 判断线段是否在放大镜中 if (line.xStart &lt; xStart || line.xEnd &gt; xEnd) &#123; continue; &#125; if (line.yEnd &gt; yEnd || line.yStart &lt; yStart) &#123; continue; &#125; gLine = glassLines[glassLineIndex]; sgLine = scaleGlassLines[glassLineIndex]; if (line.yEnd &gt; yEnd) &#123; gLine.yEnd = yEnd; &#125; if (line.yStart &lt; yStart) &#123; gLine.yStart = yStart; &#125; gLine.xStart = line.xStart - xStart; gLine.yStart = line.yStart - yStart; gLine.xEnd = line.xEnd - xStart; gLine.yEnd = line.yEnd - yStart; sgLine.xStart = parseInt(gLine.xStart * scale); sgLine.yStart = parseInt(gLine.yStart * scale); sgLine.xEnd = parseInt(gLine.xEnd * scale); sgLine.yEnd = parseInt(gLine.yEnd * scale); sgLine.color = line.color; glassLineIndex++; &#125; glassLineSize = glassLineIndex;&#125; 绘制放大镜中心点绘制放大镜中心的瞄准器123456789101112131415function drawAnchor() &#123; context.beginPath(); context.lineWidth = 2; context.fillStyle = "#fff"; context.strokeStyle = "#000"; context.arc(parseInt(centerPoint.x), parseInt(centerPoint.y), 10, 0, Math.PI * 2, false); var radius = 15; context.moveTo(parseInt(centerPoint.x - radius), parseInt(centerPoint.y)); context.lineTo(parseInt(centerPoint.x + radius), parseInt(centerPoint.y)); context.moveTo(parseInt(centerPoint.x), parseInt(centerPoint.y - radius)); context.lineTo(parseInt(centerPoint.x), parseInt(centerPoint.y + radius)); //context.fill(); context.stroke();&#125; 绘制放大镜123456789101112131415161718192021222324252627282930313233343536373839function drawMagnifyingGlass() &#123; calScaleLines(); context.save(); context.beginPath(); context.arc(centerPoint.x, centerPoint.y, originalRadius, 0, Math.PI * 2, false); context.clip(); context.beginPath(); context.fillStyle = "#fff"; context.arc(centerPoint.x, centerPoint.y, originalRadius, 0, Math.PI * 2, false); context.fill(); context.lineWidth = 4; for (var i = 0; i &lt; glassLineSize; i++) &#123; context.beginPath(); context.strokeStyle = scaleGlassLines[i].color; context.moveTo(scaleGlassRectangle.x + scaleGlassLines[i].xStart, scaleGlassRectangle.y + scaleGlassLines[i].yStart); context.lineTo(scaleGlassRectangle.x + scaleGlassLines[i].xEnd, scaleGlassRectangle.y + scaleGlassLines[i].yEnd); context.stroke(); &#125; context.restore(); context.beginPath(); var gradient = context.createRadialGradient( parseInt(centerPoint.x), parseInt(centerPoint.y), originalRadius - 5, parseInt(centerPoint.x), parseInt(centerPoint.y), originalRadius); gradient.addColorStop(0.50, 'silver'); gradient.addColorStop(0.90, 'silver'); gradient.addColorStop(1, 'black'); context.strokeStyle = gradient; context.lineWidth = 5; context.arc(parseInt(centerPoint.x), parseInt(centerPoint.y), originalRadius, 0, Math.PI * 2, false); context.stroke(); drawAnchor();&#125; 添加事件鼠标拖动鼠标移动到放大镜上，然后按下鼠标左键，可以拖动放大镜，不按鼠标左键或者不在放大镜区域都不可以拖动放大镜。为了实现上面的效果，我们要实现3种事件 mousedown, mousemove, ‘mouseup’, 当鼠标按下时，检测是否在放大镜区域，如果在，设置放大镜可以移动。鼠标移动时更新放大镜中兴点的坐标。鼠标松开时，设置放大镜不可以被移动。123456789101112131415161718192021222324252627282930313233canvas.onmousedown = function (e) &#123; var point = windowToCanvas(e.clientX, e.clientY); var x1, x2, y1, y2, dis; x1 = point.x; y1 = point.y; x2 = centerPoint.x; y2 = centerPoint.y; dis = Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2); if (dis &lt; Math.pow(originalRadius, 2)) &#123; lastPoint.x = point.x; lastPoint.y = point.y; moveGlass = true; &#125;&#125;canvas.onmousemove = function (e) &#123; if (moveGlass) &#123; var xDis, yDis; var point = windowToCanvas(e.clientX, e.clientY); xDis = point.x - lastPoint.x; yDis = point.y - lastPoint.y; centerPoint.x += xDis; centerPoint.y += yDis; lastPoint.x = point.x; lastPoint.y = point.y; draw(); &#125;&#125;canvas.onmouseup = function (e) &#123; moveGlass = false;&#125; 鼠标双击当移动到对应的线段上时，鼠标双击可以选择该线段，将该线段的颜色变为红色。123456789101112131415161718192021222324252627282930313233canvas.ondblclick = function (e) &#123; var xStart, xEnd, yStart, yEnd; var clickPoint = &#123;&#125;; clickPoint.x = scaleGlassRectangle.x + scaleGlassRectangle.width / 2; clickPoint.y = scaleGlassRectangle.y + scaleGlassRectangle.height / 2; var index = -1; for (var i = 0; i &lt; scaleGlassLines.length; i++) &#123; var scaleLine = scaleGlassLines[i]; xStart = scaleGlassRectangle.x + scaleLine.xStart - 3; xEnd = scaleGlassRectangle.x + scaleLine.xStart + 3; yStart = scaleGlassRectangle.y + scaleLine.yStart; yEnd = scaleGlassRectangle.y + scaleLine.yEnd; if (clickPoint.x &gt; xStart &amp;&amp; clickPoint.x &lt; xEnd &amp;&amp; clickPoint.y &lt; yStart &amp;&amp; clickPoint.y &gt; yEnd) &#123; scaleLine.color = "#f00"; index = scaleLine.index; break; &#125; &#125; for (var i = 0; i &lt; chartLines.length; i++) &#123; var line = chartLines[i]; if (line.index == index) &#123; line.color = "#f00"; &#125; else &#123; line.color = "#888"; &#125; &#125; draw();&#125; 键盘事件因为线段离得比较近，所以使用鼠标移动很难精确的选中线段，这里使用键盘的w, a, s, d 来进行精确移动123456789101112131415document.onkeyup = function (e) &#123; if (e.key == 'w') &#123; centerPoint.y = intAdd(centerPoint.y, -0.2); &#125; if (e.key == 'a') &#123; centerPoint.x = intAdd(centerPoint.x, -0.2); &#125; if (e.key == 's') &#123; centerPoint.y = intAdd(centerPoint.y, 0.2); &#125; if (e.key == 'd') &#123; centerPoint.x = intAdd(centerPoint.x, 0.2); &#125; draw();&#125; 参考资料 HTML5-MagnifyingGlass]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【软件】解决 win8/win10 中Windows Media Player 无法播放ipv6直播(MMS串流)]]></title>
    <url>%2F2016%2F09%2F13%2F%E3%80%90%E8%BD%AF%E4%BB%B6%E3%80%91%E8%A7%A3%E5%86%B3-win8-win10-%E4%B8%ADWindows-Meida-Player-%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BEipv6%E7%9B%B4%E6%92%AD-MMS%E4%B8%B2%E6%B5%81%2F</url>
    <content type="text"><![CDATA[打开控制面板，选择 程序 默认程序 -&gt; 设置默认程序 左侧选中 Windows Media Player，右侧选择 选择此程序的默认值 在 协议 下勾选上 MMS 参考文章: Solution to Windows Media Player 11 (WMP11) Cannot Stream and Play MMS Media Protocol in Vista]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>IPV6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Pthreads】Pipeline Model(Assembly Line)示例]]></title>
    <url>%2F2016%2F04%2F26%2F%E3%80%90Pthreads%E3%80%91Pipeline-Model-Assembly-Line-%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[前言Pthreads 有几种工作模型，例如 Boss/Workder Model、Pileline Model(Assembly Line)、Background Task Model、Interface/Implementation Model，详细介绍可以参考 pthread Tutorial，这里给出一个流水线模型(Pipeline Model)的简单示例。在该示例中，主线程开启了两个子线程，一个子线程用来读取文件，一个子线程用于将结果写入文件，而主线程自身用来计算。 模型说明很多时候，一个程序可以分为几个阶段，比如说读取数据、计算、将结果写入文件，当然我们可以使用每个线程依次执行这些操作，但是一个更好的选择是一个线程处理一个阶段，因为对于文件操作来说，硬盘的读写速率是一定的(IO很多时候会成为性能的瓶颈)，即使多个线程读取文件，其读写速率也不会变快(IO操作无法使用线程并行)。所以我们可以用一个线程来处理IO，另外的线程全部用于计算上，如果计算量较大，IO的耗时是可以掩盖过去的。比如读取一个 2G 的文件，然后进行计算。使用流水线模型，我们可以这样做，用一个线程专门读取文件，我们将其成为IO线程。IO线程一次读取 50M 数据，之后交给计算线程来处理这些数据，在计算线程处理数据的同时，IO线程再去读文件，假设处理 50M 数据的时间大于读取50M数据的时间， 当计算线程处理完上一份数据之后，要处理的下一份数据读取完毕，那么计算线程又可以紧接着处理这部分数据，这样循环操作，除了第一次读取数据的时候计算线程处于空闲状态，其余读取的时候计算线程都在进行计算，这样就掩盖掉了IO的时间 实现执行流程主线程在程序开始时创建两个子线程，一个用于读，一个用于写，读线程每次只读取一部分文件内容，写线程将这部分数据处理完之后的结果写入文件。创建完线程之后，主线程和写线程就处于等待状态，而读线程就开始读取文件，当读线程读取完第一部分数据之后，读线程进入阻塞状态，主线程开始计算，主线程计算完毕后，写线程开始写入计算结果，同时读线程开始下一部分数据的读取。按照这个流程循环取算存，直到程序结束。 线程等待和唤醒在执行中，3个线程都会进行等待操作，并且处理完自己的任务之后，还要再次进入等待状态。这里使用条件变量来控制线程的挂起和唤醒，使用while循环控制线程的状态的多次切换。下面是示例代码12345678while(1) &#123; pthread_mutex_lock(&amp;read_lock); while(read_count == 0 ) &#123; pthread_cond_wait(&amp;read_cond, &amp;read_lock); &#125; read_count--; pthread_mutex_unlock(&amp;read_lock);&#125; 上面的代码中，while循环会一直执行，所以我们还要加一个是否可以跳出 while 循环的判断，以便在任务结束后可以终止线程, 如下面的代码：123456789101112while(1) &#123; pthread_mutex_lock(&amp;read_lock); while(read_count == 0 &amp;&amp; !read_shutdown ) &#123; pthread_cond_wait(&amp;read_cond, &amp;read_lock); &#125; if(read_shutdown) &#123; break; &#125; read_flag = 1 - read_flag; pthread_mutex_unlock(&amp;read_lock);&#125; 我们看到在判断线程是否挂起的 while 循环中也加入了!read_shutdown的判断，即如果马上就要跳出while循环，标明线程已经执行完了它的任务，则无需再进行挂起操作。唤醒该线程的代码如下所示：1234567pthread_mutex_lock(&amp;read_lock);if(loop_index == loop_nums - 1) &#123; read_shutdown = 1;&#125;read_count = 1;pthread_cond_signal(&amp;read_cond);pthread_mutex_unlock(&amp;read_lock); 下面分析一下条件变量，首先读线程和写线程都要对应一个条件变量，暂称为 read_cond 和 write_cond, 主线程用read_cond来告诉读线程自己已经开始计算，读线程可以继续读取下一部分数据了，用write_cond告诉写线程，计算已经完毕，可以将结果写入文件了 。而主线程需要两个条件变量，暂称为 cal_cond 和 cal_cond2 , 读线程使用 cal_cond 告诉主线程自己已经读完这部分数据了，主线程可以开始计算了。而写线程用 cal_cond2 告诉主线程自己已经写完了上次计算结果，可以再次分配写入的任务了。如果读线程没有读完或者写线程没有写完，主线程都要进入等待状态。 我们知道每个条件变量都会对应一个条件以及一个互斥锁，下面分析一下各个条件的初始值，程序开始时读线程开始工作，主线程要等待读线程读完才能进行计算，所以 read_cond 对应的条件为 true， cal_cond 对应的条件的为 false，写线程必须要等待主线程计算完才可以写，并且在第一次的时候写线程肯定是空闲的， 所以 write_cond 对应的条件为 false，cal_cond2 对应的的条件为 ture。 数据缓冲区当读线程读完数据，将数据存到一个缓冲区中(比如一个数组)，主线程开始计算，此时读线程又去进行读取操作。如果读线程还是将数据读到上一次读取的缓冲区中（这个缓冲区此时正在被主线程使用），那么就会出现数据竞争。为了解决这个情况，我们可以使用两个缓冲区，读线程填满一个之后再去填另外一个，使用一个变量判断当前该使用哪个缓冲区，即如下面的形式：12345678910111213int read_buffer_a[BUFFER_SIZE], read_buffer_b[BUFFER_SIZE];int read_flag;if(read_flag) &#123; for(i = 0; i &lt; BUFFER_SIZE; i++) &#123; fscanf(read_arg-&gt;fp, "%d", read_buffer_a+i); &#125; &#125; else &#123; for(i = 0; i &lt; BUFFER_SIZE; i++) &#123; fscanf(read_arg-&gt;fp, "%d", read_buffer_b + i); &#125;&#125;read_flag = 1 -read_flag; 完整代码下面是完整的代码, 这里是github地址，可以下载下来运行一下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdint.h&gt;#include &lt;pthread.h&gt;#include &lt;stdarg.h&gt;#define BUFFER_SIZE 10uint32_t microseconds = 100;// 线程信息typedef struct _thread_info&#123; pthread_t thread_id; pthread_mutex_t lock; pthread_cond_t cond; int run_flag; int buffer_flag; int shutdown;&#125; thread_info;// 线程函数参数typedef struct _thread_arg &#123; FILE *fp;&#125; thread_arg;thread_info input_info, output_info, cal_input_info, cal_output_info;int read_buffer_a[BUFFER_SIZE], read_buffer_b[BUFFER_SIZE];int write_buffer_a[BUFFER_SIZE], write_buffer_b[BUFFER_SIZE];void init_resources(int n, ...) &#123; va_list arg_ptr ; int i; va_start(arg_ptr, n); thread_info * tmp_info = NULL; for(i = 0; i &lt; n; i++) &#123; tmp_info = va_arg(arg_ptr, thread_info *); pthread_mutex_init(&amp;(tmp_info-&gt;lock), NULL); pthread_cond_init(&amp;(tmp_info-&gt;cond), NULL); &#125; va_end(arg_ptr);&#125;void free_resources(int n, ...) &#123; va_list arg_ptr; int i; va_start(arg_ptr, n); thread_info * tmp_info = NULL; for(i = 0; i &lt; n; i++) &#123; tmp_info = va_arg(arg_ptr, thread_info *); pthread_mutex_destroy(&amp;(tmp_info-&gt;lock)); pthread_cond_destroy(&amp;(tmp_info-&gt;cond)); &#125; va_end(arg_ptr);&#125;void * input_task(void * args)&#123; thread_arg * input_arg = (thread_arg *) args; int i; while(1) &#123; pthread_mutex_lock(&amp;(input_info.lock)); while(input_info.run_flag == 0 &amp;&amp; !input_info.shutdown) &#123; pthread_cond_wait(&amp;(input_info.cond), &amp;(input_info.lock)); &#125; if(input_info.shutdown) &#123; break; &#125; input_info.run_flag = 0; input_info.buffer_flag = 1 - input_info.buffer_flag; pthread_mutex_unlock(&amp;(input_info.lock)); if(input_info.buffer_flag) &#123; for(i = 0; i &lt; BUFFER_SIZE; i++) &#123; fscanf(input_arg-&gt;fp, "%d", read_buffer_a + i); &#125; &#125; else &#123; for(i = 0; i &lt; BUFFER_SIZE; i++) &#123; fscanf(input_arg-&gt;fp, "%d", read_buffer_b + i); &#125; &#125; pthread_mutex_lock(&amp;(cal_input_info.lock)); cal_input_info.run_flag = 1; pthread_cond_signal(&amp;(cal_input_info.cond)); pthread_mutex_unlock(&amp;(cal_input_info.lock)); &#125; return NULL;&#125;void * output_task(void * args)&#123; thread_arg * output_arg = (thread_arg *) args; int i; while(1) &#123; pthread_mutex_lock(&amp;(output_info.lock)); while(output_info.run_flag == 0 &amp;&amp; !output_info.shutdown) &#123; pthread_cond_wait(&amp;(output_info.cond), &amp;(output_info.lock)); &#125; if(output_info.shutdown) &#123; break; &#125; output_info.run_flag = 0; output_info.buffer_flag = 1 - output_info.buffer_flag; pthread_mutex_unlock(&amp;(output_info.lock)); if(output_info.buffer_flag) &#123; for(i = 0; i &lt; BUFFER_SIZE; i++) &#123; fprintf(output_arg-&gt;fp, "%d\n", write_buffer_a[i]); usleep(microseconds); &#125; &#125; else &#123; for(i = 0; i &lt; BUFFER_SIZE; i++) &#123; fprintf(output_arg-&gt;fp, "%d\n", write_buffer_b[i]); usleep(microseconds); &#125; &#125; pthread_mutex_lock(&amp;(cal_output_info.lock)); cal_output_info.run_flag = 1; pthread_cond_signal(&amp;(cal_output_info.cond)); pthread_mutex_unlock(&amp;(cal_output_info.lock)); &#125; return NULL;&#125;int main()&#123; FILE *fp_input, *fp_output; char *input_name = "input.txt"; char *output_name = "output.txt"; int total_nums = 100; int loop_nums = total_nums / BUFFER_SIZE; int loop_index = 0; int i; thread_arg input_arg, output_arg; if((fp_input = fopen(input_name, "r")) == NULL) &#123; printf("can't load input file\n"); exit(1); &#125; if((fp_output = fopen(output_name, "w+")) == NULL) &#123; printf("can't load output file\n"); exit(1); &#125; input_arg.fp = fp_input; output_arg.fp = fp_output; init_resources(4, &amp;input_info, &amp;output_info, &amp;cal_input_info, &amp;cal_output_info); input_info.buffer_flag = output_info.buffer_flag = cal_input_info.buffer_flag = 0; input_info.run_flag = cal_output_info.run_flag = 1; output_info.run_flag = cal_input_info.run_flag = 0; input_info.shutdown = output_info.shutdown = 0; pthread_create(&amp;(input_info.thread_id), NULL, input_task, &amp;input_arg); pthread_create(&amp;(output_info.thread_id), NULL, output_task, &amp;output_arg); while(1) &#123; pthread_mutex_lock(&amp;(cal_input_info.lock)); while(cal_input_info.run_flag == 0) &#123; pthread_cond_wait(&amp;(cal_input_info.cond), &amp;(cal_input_info.lock)); &#125; cal_input_info.buffer_flag = 1 - cal_input_info.buffer_flag; cal_input_info.run_flag = 0; pthread_mutex_unlock(&amp;(cal_input_info.lock)); pthread_mutex_lock(&amp;(input_info.lock)); if(loop_index == loop_nums - 1) &#123; input_info.shutdown = 1; &#125; input_info.run_flag = 1; pthread_cond_signal(&amp;(input_info.cond)); pthread_mutex_unlock(&amp;(input_info.lock)); // 这里可以使用OpenMp if(cal_input_info.buffer_flag) &#123; for(i = 0; i &lt; BUFFER_SIZE; i++) &#123; write_buffer_a[i] = read_buffer_a[i] + 1; &#125; &#125; else &#123; for(i = 0; i &lt; BUFFER_SIZE; i++) &#123; write_buffer_b[i] = read_buffer_b[i] + 1; &#125; &#125; pthread_mutex_lock(&amp;(cal_output_info.lock)); while(cal_output_info.run_flag == 0) &#123; pthread_cond_wait(&amp;(cal_output_info.cond), &amp;(cal_output_info.lock)); &#125; cal_output_info.run_flag = 0; pthread_mutex_unlock(&amp;(cal_output_info.lock)); pthread_mutex_lock(&amp;(output_info.lock)); output_info.run_flag = 1; pthread_cond_signal(&amp;(output_info.cond)); pthread_mutex_unlock(&amp;(output_info.lock)); if(loop_index == loop_nums - 1) &#123; break; &#125; loop_index++; &#125; pthread_mutex_lock(&amp;(cal_output_info.lock)); while(cal_output_info.run_flag == 0) &#123; pthread_cond_wait(&amp;(cal_output_info.cond), &amp;(cal_output_info.lock)); &#125; cal_output_info.run_flag = 0; pthread_mutex_unlock(&amp;(cal_output_info.lock)); pthread_mutex_lock(&amp;(output_info.lock)); output_info.run_flag = 1; output_info.shutdown = 1; pthread_cond_signal(&amp;(output_info.cond)); pthread_mutex_unlock(&amp;(output_info.lock)); pthread_join(input_info.thread_id, NULL); pthread_join(output_info.thread_id, NULL); free_resources(4, &amp;input_info, &amp;output_info, &amp;cal_input_info, &amp;cal_output_info); fclose(fp_input); fclose(fp_output); return 0; &#125; 参考本文主要参考了这个Pthreads线程池]]></content>
      <categories>
        <category>Pthreads</category>
      </categories>
      <tags>
        <tag>Pthreads</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Pthreads学习笔记】基本使用]]></title>
    <url>%2F2016%2F04%2F25%2F%E3%80%90Pthreads%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言与OpenMP相比，Pthreads的使用相对要复杂一些，需要我们显式的创建、管理、销毁线程，但也正因为如此，我们对于线程有更强的控制，可以更加灵活的使用线程。这里主要记录一下Pthreads的基本使用方法，如果不是十分复杂的使用环境，这些知识应该可以了。本文大部分内容都是参考自这里，有兴趣的可以看一下原文。 HelloWorld12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;void * hello(void * args) &#123; long rank = (long) args; printf("Hello form sub thread %ld\n", rank); return NULL;&#125;int main() &#123; int thread_num = 4; long thread_index; pthread_t * thread_handles; thread_handles =(pthread_t *) malloc(sizeof(pthread_t ) * thread_num); for(thread_index = 0; thread_index &lt; thread_num; thread_index++) &#123; pthread_create(&amp;thread_handles[thread_index], NULL, hello, (void *)thread_index); &#125; printf("hello from main thread\n"); for(thread_index = 0; thread_index &lt; thread_num; thread_index++) &#123; pthread_join(thread_handles[thread_index], NULL); &#125; free(thread_handles); return 0;&#125; 编译程序, 需要加上 ‘-lpthread’1gcc -o helloworld helloworld.c -lpthread 一种可能的输出结果12345hello from main threadHello form sub thread 2Hello form sub thread 3Hello form sub thread 1Hello form sub thread 0 创建线程Pthreads使用 pthread_create 函数来创建线程, 函数原型如下:12345int pthread_create( pthread_t * thread, const pthread_attr_t * attr, void * (*start_routine) (void *), void * arg); 参数说明:thread 指向执行线程标识符的指针, 通过该变量来控制线程attr 设置线程属性, 如果为NULL, 则使用默认的属性start_routine 线程运行函数的起始地址arg 运行函数的参数, 这里使用 void*来作为参数类型, 以便可以向运行函数中传递任意类型的参数, 当然需要在运行函数中将参数转换为其原来的类型.返回值 如果创建线程成功会返回0, 否则返回错误码. 下面是一个使用示例:12345678910111213void * thread_function(void *arg) &#123; int * incoming = (int *)arg; printf("this is in pthread and arg is %d\n", *incoming); return NULL;&#125;void hello_world() &#123; pthread_t thread_id ; int value = 63; pthread_create(&amp;thread_id, NULL, thread_function, &amp;value); // 等待线程执行完 pthread_join(thread_id, NULL);&#125; 在上面的代码中, 在程序最后加上了 pthread_join 函数, 用来完成线程间的同步, 即主线程等待指定的线程(在上面的代码中是 thread_id 对应的线程)执行完再往下执行. 在下面会详细介绍该函数. Join 和 DetachJoin(合并)pthread_join 可以用于线程之间的同步, 当一个线程对另一个线程调用了join操作之后, 该线程会处于阻塞状态, 直到另外一个线程执行完毕. 下面是一个示意图: 下面是 pthread_join的函数原型:123int pthread_join( pthread_t thread, void ** retval); 参数说明:thread 线程标识符, 用来指定等待哪个线程retaval 用来存储等待线程的返回值 下面是通过获取函数返回值的一个示例:1234567891011121314151617void * p_result(void * arg) &#123; char * m = malloc(sizeof(char) * 3); m[0] = 'A'; m[1] = 'B'; m[2] = 'C'; return m;&#125;void test_get_result() &#123; pthread_t thread_id; void * exit_status ; pthread_create(&amp;thread_id, NULL, p_result, NULL); pthread_join(thread_id, &amp; exit_status); char * m = (char* ) exit_status; printf("m is %s\n", m); free(m);&#125; 在 p_result 函数中为了使线程执行完, 我们还可以访问到变量 m 中的数据, m 的内存采用动态分配的方式, 如果静态分配, 即如 char m[3] 的形式, 那么在函数执行完就会清空 m 的值, 我们就无法获得想要的结果. 对于一个线程来说, 其终止方式有两种: 执行完线程函数或者自身调用 pthread_exit(void *), 如果线程通过执行完线程函数而终止的, 那么其他线程通过pthread_join获得的线程返回值就是线程函数的返回值(如上面的例子), 如果线程是通过 pthread_exit(void *) 方式结束的线程, 其线程返回值就是 pthread_exit 传入的参数, 下面是一个示例:123456789101112131415void * p_exit_result(void * arg) &#123; printf("print before pthread_exit\n"); pthread_exit((void *)10L); printf("print after pthread_exit\n"); return NULL;&#125;void test_exit_result() &#123; pthread_t thread_id; void * exit_status ; pthread_create(&amp;thread_id, NULL, p_exit_result, NULL); pthread_join(thread_id, &amp; exit_status); long m = (long ) exit_status; printf("m is %ld\n", m);&#125; 下面是输出结果12print before pthread_exitm is 10 一般来说, 使用 Pthreads 创建的线程默认应该是可 join 的, 但是并不是所有实现都会这样, 所以必要情况下, 我们可以在创建线程时, 显式的指定线程是可 join 的1234567pthread_t thread_id;pthread_attr_t attr;pthread_attr_init(&amp;attr);pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);pthread_create(&amp;thread_id, &amp;attr, work, (void *)arg);pthread_attr_destroy(&amp;attr);pthread_join(thread_id, NULL); Detach(分离)对于可 join 的线程, 只有当其他线程对其调用了 pthread_join 之后, 该线程才会释放所占用的资源(例如线程所对应的标识符pthread_t, 线程的返回值信息), 如果想要系统回收线程的资源, 而不是通过调用pthread_join回收资源(会阻塞线程), 我们可以将线程设置为 DETACHED (分离的), 有三种方式将线程设为 detached的 创建线程时指定线程的 detach 属性: pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); 通过在子线程中调用 pthread_detach(pthread_self()); 在主线程中调用 pthread_detach(thread_id);(非阻塞, 执行完会立即会返回), 通过上面的方式将线程设为 detached, 线程运行结束后会自动释放所有资源. Mutex(互斥锁)互斥锁用来保护共享变量, 它可以保证某个时间内只有一个线程访问共享变量, 下面是使用互斥锁的具体步骤 声明 pthread_mutex_t (互斥锁类型) 类型的变量 调用 pthread_mutex_init() 来初始化变量 在访问共享变量之前, 调用 pthread_mutex_lock() 获得互斥锁, 如果互斥锁被其他线程占用, 该线程会处于等待状态 访问完共享变量之后, 调用 pthread_mutex_unlock() 释放互斥锁, 以便其他线程使用 程序执行完后调用 pthread_mutex_destroy()释放资源. 创建互斥锁有两种方式: 静态方式和动态方式. 静态方式是使用宏 PTHREAD_MUTEX_INITIALIZER 来初始化锁, 如下所示:1pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; 动态方式是调用 pthread_mutex_init 函数动态初始锁, 下面是该函数原型1int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t * attr) 下面是使用互斥锁的一个示例(使用动态方式):12345678910111213141516171819202122232425262728pthread_mutex_t lock;int share_data;void * p_lock(void * arg) &#123; int i; for(i = 0; i &lt; 1024 * 1024; i++) &#123; pthread_mutex_lock(&amp;lock); share_data++; pthread_mutex_unlock(&amp;lock); &#125; return NULL;&#125;void test_lock() &#123; pthread_t thread_id; void *exit_status; int i; pthread_mutex_init(&amp;lock, NULL); pthread_create(&amp;thread_id, NULL, p_lock, NULL); for(i = 0; i &lt; 10; i++) &#123; //sleep(1); pthread_mutex_lock(&amp;lock); printf("Shared integer's value = %d\n", share_data); pthread_mutex_unlock(&amp;lock); &#125; printf("\n"); pthread_join(thread_id, &amp; exit_status); pthread_mutex_destroy(&amp;lock);&#125; 下是使用互斥量的几个注意点: 使用 lock 和 unlock 一个互斥锁时, 一定要先初始化该互斥锁 释放互斥锁的线程必须是获得互斥锁的那个线程 当 destroy 互斥锁的时候, 不该有线程还在使用这个互斥锁 属性在动态创建互斥锁时, 我们可以传入一个锁属性变量 pthread_mutexattr_t 来初始化锁的属性, 通过下面两个函数来初始化和销毁该属性对象12int pthread_mutexattr_init(pthread_mutexattr_t *attr); int pthread_mutexattr_destroy(pthread_mutexattr_t *attr); 然后可以调用下面的方法对属性进行设置 范围可以指定互斥锁是进程之间的同步还是进程内的同步, 下面是对应的两个锁的范围(scope) PTHREAD_PROCESS_SHARE: 进程间同步 PTHREAD_PROCESS_PRIVATE: 进程内同步, 默认值 通过调用下面的函数可以设置和获取锁的范围12int pthread_mutexattr_getpshared(const pthread_mutexattr_t * restrict attr, int *restrict pshared);int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, int pshared); 类型互斥锁的类型有以下几种取值方式(为了兼容性, 一个类型可能有多个名称): PTHREAD_MUTEX_TIMED_NP / PTHREAD_MUTEX_NORMAL / PTHREAD_MUTEX_DEFAULT : 缺省值, 也就是普通锁. 当一个线程获得锁之后, 其余请求锁的线程将形成一个等待队列, 并在加锁线程解锁后按照优先级获得锁. 这种策略保证了资源分配的公正性. PTHREAD_MUTEX_RECURSIVE_NP / PTHREAD_MUTEX_RECURSIVE : 嵌套锁, 允许一个线程对同一个锁成功获得多次, 并通过多次 unlock 来解锁. 如果是不同线程请求, 则在加锁线程解锁后重新竞争. PTHREAD_MUTEX_ERRORCHECK_NP / PTHREAD_MUTEX_ERRORCHECK: 如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁 PTHREAD_MUTEX_ADAPTIVE_NP: 适应锁，动作最简单的锁类型，仅等待解锁后重新竞争 可以使用下面的函数获取和设置锁的类型12int pthread_mutexattr_gettype(const pthread_mutexattr_t *attr, int *type);int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type); Condition Variables(条件变量)条件变量对应的数据类型为 pthread_cond_t, 通过使用条件变量, 可以使线程在某个 特定条件 或者 事件 发生之前处于挂起状态. 当事件或者条件发生之后, 另一个线程可以通过信号来唤起挂起的线程. 条件变量主要使用下面几个函数 初始化(init)和互斥锁一样, 条件变量也有两种初始化方式: 静态方式和动态方式1234// 静态pthread_cond_t cond = PTHREAD_COND_INITIALIZER; // 动态, 成功返回0int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); 销毁(destroy)1int pthread_cond_destroy(pthread_cond_t *cond); 等待函数(wait)123456int pthread_cond_wait( pthread_cond_t * restrict cond, pthread_mutex_t * restrict mutex ); int pthread_cond_timedwait( pthread_cond_t * restrict cond, pthread_mutex_t * restrict mutex, const struct timespec * restrict abstime ); 通过调用 wait 函数, 线程会处于挂起状态. 其中 pthread_cond_timedwait 的含义为: 如果在 abstime 时间内(系统时间小于abstime), 线程没有被唤醒, 那么线程就会结束等待, 同时返回 ETIMEDOUT 错误. 唤醒函数(signal)12int pthread_cond_broadcast(pthread_cond_t *cond);int pthread_cond_signal(pthread_cond_t *cond); singal 函数一次只能唤醒一个线程, 而 broadcast 会唤醒所有在当前条件变量下等待的线程. 下面是条件变量的具体使用, 首先一个线程会根据条件来确实是否需要处于挂起状态, 即如下面的形式123if(flag == 0)&#123; pthread_cond_wait(...);&#125; 如果flag不为0, 那么线程就不进入等待状态, 否则就挂起线程, 等待flag不为0(满足条件了, 可以往下执行)时被唤醒. 唤醒该线程的代码如下所示:12flag = 1;pthread_cond_signal(...); 下面考虑一下这种情况, 首先 flag = 0, 当线程1执行到 if(flag == 0) 时, 发现不满足继续往下执行的条件, 即将进入挂起状态, 就在其刚要挂起的时候(还没挂起), 线程2执行了唤醒线程1的代码(修改flag的值, 唤醒线程1), 假设线程2执行完上述操作之后, 线程1仍然还没有挂起, 所以 pthread_cond_signal 并没有起到作用. 此后线程1终于进入了挂起状态, 等待线程2的唤醒, 而线程2则认为它已经唤醒了线程1, 让其往下执行了. 此时问题就来了, 如果线程2不再执行唤醒线程1的操作, 那么线程1就会永远处于挂起状态. 为了解决这种情况, 需要满足从判断 flag==0 到 pthread_cond_wait() 执行, flag 的值不能发生变化,并且不能提前执行唤醒操作. 为了实现这种需求, 我们需要加一个锁操作,等待代码:12345pthread_mutex_lock(&amp;mutex);if(flag == 0)&#123; pthread_cond_wait(...);&#125; pthread_mutex_unlock(&amp;mutex); 唤醒代码1234pthread_mutex_lock(&amp;mutex);flag = 1;pthread_mutex_unlock(&amp;mutex);pthread_cond_signal(&amp;condition); 我们看到 pthread_cond_wait 的函数原型中第一个参数为条件变量, 第二个参数为互斥锁, 之所以需要传入互斥锁, 是因为如果不传入互斥锁, 当线程进入挂起状态时, 就无法释放掉该互斥锁, 而其他线程就无法获得该互斥锁,就没办法更新flag的值, 也无法唤醒线程1. 线程1就会永远处于挂起状态, 线程2就会永远处于请求互斥锁的状态. 所以当线程1进入挂起状态时需要释放掉互斥锁, 被唤醒之后再重新获得互斥锁, 即 pthread_cond_wait 可以看成下面的操作:123pthread_mutex_unlock(&amp;mutex);wait_on_signal(&amp;condition);pthread_mutex_lock(&amp;mutex); 所有一个条件变量总是和一个互斥锁关联.下面再来看一下等待代码, 在某些特定情况下, 即使没有线程调用 pthread_cond_signal函数, ‘pthread_cond_wait’ 函数也有可能返回(具体解释可以看看 spurious wakeup), 但是此时条件并不满足, 如果程序往下执行, 那么就可能会出错. 所以为了避免这种情况, 即使线程被唤醒了, 也应该再检查一下条件是否满足, 即使用 while 循环代替 if 判断 12345pthread_mutex_lock(&amp;mutex);while(flag == 0)&#123; pthread_cond_wait(...);&#125; pthread_mutex_unlock(&amp;mutex); 下面是一个使用示例:1234567891011121314151617181920212223242526272829pthread_cond_t is_zero;pthread_mutex_t mutex;int con_share_data = 32767;void * p_condition(void * arg) &#123; while(con_share_data &gt; 0) &#123; pthread_mutex_lock(&amp;mutex); con_share_data--; pthread_mutex_unlock(&amp;mutex); &#125; pthread_cond_signal(&amp;is_zero);&#125;void test_condition() &#123; pthread_t thread_id; void *exit_status; int i; pthread_cond_init(&amp;is_zero, NULL); pthread_mutex_init(&amp;mutex, NULL); pthread_create(&amp;thread_id, NULL, p_condition, NULL); pthread_mutex_lock(&amp;mutex); while(con_share_data != 0) &#123; pthread_cond_wait(&amp; is_zero, &amp;mutex); &#125; pthread_mutex_unlock(&amp;mutex); pthread_join(thread_id, &amp;exit_status); pthread_mutex_destroy(&amp;mutex); pthread_cond_destroy(&amp;is_zero);&#125; Semaphores(信号量)信号量本质上可以看做是一个计数器, 它主要有两种操作, 第一类操作为 down 或者 wait – sem_wait(...), 目的是为了减小计数器(将信号俩减1), 另一类为 up 或者 signal – sem_post(...) , 目的是为了增大计数器(将信号量加1). 当线程调用 sem_wait() 时, 如果信号量的值大于0, 那么只会把信号量减1, 线程会继续往下执行. 如果信号量的值为0, 那么线程就会进入阻塞状态, 直到另外一个线程执行了 sem_post() 操作, 对信号量进行了增操作, 该线程才会继续往下执行. 信号量主要用于对一些稀缺资源的同步, 什么叫做稀缺资源, 就是说这个资源只有有限的几个, 但是又多于一个, 在某一个时刻, 可以供有限的几个线程使用, 但又不是全部线程使用. 如果将信号量初始化为1, 那么该信号量就等同于互斥锁了, 因此一次只能有一个线程获得信号量的资源, 如果其他线程想要获得, 必须等该线程对信号量进行增操作. 举个例子说: 有10个人去银行办理业务, 但是银行只有4个窗口(信号量初始化为4), 所以前4个人到了银行就可以办理业务, 但是第5个人之后就必须要等待, 等前面的某个人办理完业务(增加信号量), 空出窗口来. 而当第5个人去办理业务时, 空出的窗口又被占用了(减小信号量), 剩下的人还是要等待. 信号量在执行过程中和上述例子不同的一点是, 当有空余的资源出现时, 线程并不一定按照 FIFO(先进先出) 的顺序来获取资源, 而有可能是随机一个线程获得资源. 下面是信号量相关的函数类型信号量的类型是 sem_t, 需要引入头文件 #include &lt;semaphore.h&gt; 初始化和销毁12int sem_init(sem_t *sem, int pshared, unsigned int value);int sem_destroy(sem_t *sem); init 函数的第二个参数用来标识信号量的范围: 0 表示一个进程中线程间共享, 非0 表示进程间共享. 第三个参数就是信号量的可用数量. wait和signal12int sem_wait(sem_t *sem);int sem_post(sem_t *sem); 下面是一个使用示例12345678910111213141516171819int sem_share_data = 0;// use like a mutexsem_t binary_sem; void * p_sem(void * arg) &#123; sem_wait(&amp;binary_sem); // 减少信号量 // 在这里使用共享数据; sem_post(&amp;binary_sem); // 增加信号量&#125;void test_sem() &#123; sem_init(&amp;binary_sem, 0, 1); // 信号量初始化为1, 当初互斥锁使用 // 在这里创建线程 sem_wait(&amp;binary_sem); // 在这里使用共享变量 sem_post(&amp;binary_sem); // 在这里join线程 sem_destroy(&amp;binary_sem);&#125; Reader/Writer Locks 读写锁对于读写锁来说, 多个线程可以同时获得读锁, 但某一个时间内, 只有一个线程可以获得写锁. 如果已经有线程获得了读锁, 则任何请求写锁的线程将被阻塞在写锁函数的调用上, 同时如果线程已经获得了写锁, 那么任何请求读锁或者写锁 的线程都会被阻塞. 下面是读写锁的基本函数: 锁类型1pthread_rwlock_t 初始化/销毁12int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); 读锁1int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); 写锁1int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); 释放锁1int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); 下面是一个使用示例:123456789101112131415161718pthread_rwlock_t rw_lock;void * p_rwlock(void * arg) &#123; pthread_rwlock_rdlock(&amp;rw_lock); // 读取共享变量 pthread_rwlock_unlock(&amp;rw_lock); &#125; void test_rwlock() &#123; pthread_rwlock_init(&amp;rw_lock, NULL); // 创建线程 pthread_rwlock_wrlock(&amp;rw_lock); // 修改共享变量 pthread_rwlock_unlock(&amp;rw_lock); // join线程 pthread_rwlock_destroy(&amp;rw_lock);&#125; 参考文章pthread Tutoriaed TutorialPOSIX Threads ProgrammingLinux线程-互斥锁pthread_mutex_tPthread：POSIX 多线程程序设计 下面列出一些学习资料，如果想深入学习Pthreads可以看下这些资料(摘自POSIX 多线程程序设计)：Pthreads多线程编程指南Programing with POSIX threadPthread Primer]]></content>
      <categories>
        <category>Pthreads</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Pthreads</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C】解析命令行参数--getopt和getopt_long]]></title>
    <url>%2F2016%2F03%2F05%2F%E3%80%90C%E3%80%91%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0--getopt%E5%92%8Cgetopt_long%2F</url>
    <content type="text"><![CDATA[前言在程序中一般都会用到命令行选项, 我们可以使用getopt 和getopt_long函数来解析命令行参数 getoptgetopt主要用来处理短命令行选项, 例如./test -v中-v就是一个短选项. 使用该函数需要引入头文件&lt;unistd.h&gt;, 下面是该函数的定义1int getopt(int argc, char * const argv[], const char * optstring); 其中 argc 和 argv 是main函数中的传递的参数个数和内容, optstring用来指定可以处理哪些选项, 下面是optstring的一个示例:1"a:bc" 该示例表明程序可以接受3个选项: -a -b -c, 其中 a 后面的 :表示该选项后面要跟一个参数, 即如 -a text的形式, 选项后面跟的参数会被保存到 optarg 变量中. 下面是一个使用示例:123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main(int argc, char **argv) &#123; int ch; while((ch = getopt(argc, argv, "a:b")) != -1) &#123; switch(ch) &#123; case 'a': printf("option a: %s\n", optarg); break; case 'b': printf("option b \n"); break; case '?': // 输入未定义的选项, 都会将该选项的值变为 ? printf("unknown option \n"); break; default: printf("default \n"); &#125; &#125;&#125; 执行 ./test -a aa -b -c 输出结果如下:123option a: aaoption b unknown option getopt_longgetopt_long支持长选项的命令行解析, 所为长选项就是诸如--help的形式, 使用该函数, 需要引入&lt;getopt.h&gt;下面是函数原型:12345678910111213#include &lt;getopt.h&gt;int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex);int getopt_long_only(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex); 其中 argc , argv , optstring 和getopt中的含义一样, 下面解释一下longopts 和longindex longopts longopts 指向一个struct option 的数组, 下面是option的定义:123456struct option &#123; const char *name; int has_arg; int *flag; int val;&#125;; 下面是各字段的含义 name - 长选项的名称, 例如 help has_arg - 是否带参数, 0 不带参数, 1 必须带参数, 2 参数可选 flag - 指定长选项如何返回结果, 如果flag为NULL, getopt_long() 会返回val. 如果flag不为NULL, getopt_long会返回0, 并且将val的值存储到flag中 val - 将要被getopt_long返回或者存储到flag指向的变量中的值 下面是longopts的一个示例12345struct option opts[] = &#123; &#123;"version", 0, NULL, 'v'&#125;, &#123;"name", 1, NULL, 'n'&#125;, &#123;"help", 0, NULL, 'h'&#125; &#125;; 我们来看{&quot;version&quot;, 0, NULL, &#39;v&#39;}, version 即为长选项的名称, 即按如下形式--version, 0 表示该选项后面不带参数, NULL 表示直接将v返回(字符v在ascii码中对应的数值), 即在使用getopt_long遍历到该条选项时, getopt_long 返回值为字符v对应的ascii码值. longindex longindex表示长选项在longopts中的位置, 例如在上面的示例中, version 对应的 longindex 为0, name 对应的 longindex 为1, help对应的 longindex 为2, 该项主要用于调试, 一般设为 NULL 即可. 下面是一个使用示例:1234567891011121314151617181920212223242526272829303132void use_getpot_long(int argc, char *argv[]) &#123; const char *optstring = "vn:h"; int c; struct option opts[] = &#123; &#123;"version", 0, NULL, 'v'&#125;, &#123;"name", 1, NULL, 'n'&#125;, &#123;"help", 0, NULL, 'h'&#125; &#125;; while((c = getopt_long(argc, argv, optstring, opts, NULL)) != -1) &#123; switch(c) &#123; case 'n': printf("username is %s\n", optarg); break; case 'v': printf("version is 0.0.1\n"); break; case 'h': printf("this is help\n"); break; case '?': printf("unknown option\n"); break; case 0 : printf("the return val is 0\n"); break; default: printf("------\n"); &#125; &#125;&#125; 然后我们运行程序 ./test --name zhangjikai --version --help --haha, 下面是运行结果:12345username is zhangjikaiversion is 0.0.1this is help./test: unrecognized option '--haha'unknown option 当然我们也可以使用短选项 ./test -n zhangjikai -v -h下面我们对程序做一下修改, 这一次将 struct option 中的 flag 和 longindex 设为具体的值123456789101112131415161718192021222324252627282930313233343536void use_getpot_long2(int argc, char *argv[]) &#123; const char *optstring = "vn:h"; int c; int f_v = -1, f_n = -1, f_h = -1, opt_index = -1; struct option opts[] = &#123; &#123;"version", 0, &amp;f_v, 'v'&#125;, &#123;"name", 1, &amp;f_n, 'n'&#125;, &#123;"help", 0, &amp;f_h, 'h'&#125; &#125;; while((c = getopt_long(argc, argv, optstring, opts, &amp;opt_index)) != -1) &#123; switch(c) &#123; case 'n': printf("username is %s\n", optarg); break; case 'v': printf("version is 0.0.1\n"); break; case 'h': printf("this is help\n"); break; case '?': printf("unknown option\n"); break; case 0 : printf("f_v is %d \n", f_v); printf("f_n is %d \n", f_n); printf("f_h is %d \n", f_h); break; default: printf("------\n"); &#125; printf("opt_index is %d\n\n", opt_index); &#125;&#125; 运行程序: ./test --name zhangjikai --version --help , 下面是运行结果:1234567891011121314f_v is -1 f_n is 110 f_h is -1 opt_index is 1f_v is 118 f_n is 110 f_h is -1 opt_index is 0f_v is 118 f_n is 110 f_h is 104 opt_index is 2 我们可以看到当给 flag 指定具体的指针之后, getopt_long 会返回0, 因此会去执行case 0, 并且 val 的值赋给了 flag 指向的变量. 下面我们用短选项执行一下程序 ./test -n zhangjikai -v -h, 下面是运行结果12345678username is zhangjikaiopt_index is -1version is 0.0.1opt_index is -1this is helpopt_index is -1 我们看到使用短选项的时候 getopt_long 就相当于 getopt , flag 和 longindex都不起作用了. getopt_long 和 getopt_long_only下面解释一下 getopt_long 和 getopt_long_only的区别, 首先用下列选项运行一下 use_getopt_long ./test -name zhangjkai -version -help , 下面是输出结果:12345678910111213username is ameversion is 0.0.1./test: invalid option -- 'e'unknown option./test: invalid option -- 'r'unknown option./test: invalid option -- 's'unknown option./test: invalid option -- 'i'unknown option./test: invalid option -- 'o'unknown optionusername is -help 我们看到使用短选项标识符 - 指向长选项时, 程序还是会按短选项来处理, 即一个字符一个字符的解析. 下面我们将 use_getopt_long 做一下更改, 即将 getopt_long 改为 getopt_long_only , 如下所示: 1234567891011121314151617181920212223242526272829303132void use_getpot_long3(int argc, char *argv[]) &#123; const char *optstring = "vn:h"; int c; struct option opts[] = &#123; &#123;"version", 0, NULL, 'v'&#125;, &#123;"name", 1, NULL, 'n'&#125;, &#123;"help", 0, NULL, 'h'&#125; &#125;; while((c = getopt_long_only(argc, argv, optstring, opts, NULL)) != -1) &#123; switch(c) &#123; case 'n': printf("username is %s\n", optarg); break; case 'v': printf("version is 0.0.1\n"); break; case 'h': printf("this is help\n"); break; case '?': printf("unknown option\n"); break; case 0 : printf("the return val is 0\n"); break; default: printf("------\n"); &#125; &#125;&#125; 下面再运行程序 ./test -name zhangjikai -version -help , 下面是运行结果:123username is zhangjikaiversion is 0.0.1this is help 即使用 getopt_long_only 时, - 和 --都可以作用于长选项, 而使用 getopt_only 时, 只有 --可以作用于长选项.]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C】文件操作(二)]]></title>
    <url>%2F2016%2F03%2F04%2F%E3%80%90C%E3%80%91%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[前言这里主要记录一下C对二进制的读写操作, 包括随机读取文件和写入文件 fseek 和 ftellfseekfseek主要用来移动文件指针, 它允许用户像对待数组那样对待一个文件, 可以直接将文件指针移动到任意字节处, 下面是它的函数原型:1int fseek ( FILE * stream, long int offset, int origin ); 下面是个参数的含义 stream - 打开的文件指针 offset - 偏移量, 表示从起始点开始要移动的距离(起始点的选择由origin指定), 可以为正(向前移)、负(往回移), 也可以为零(保持不动). origin - 用来指定起始点的模式, 可以使用下面定义的几个模式常量: SEEK_SET : 以文件开始位置作为起始点 SEEK_CUR : 以文件指针当前所在的位置作为起始点 SEEK_END : 以文件结尾作为起始点 下面是一些使用示例, 其中fp是一个文件指针12345fseek(fp, 0L, SEEK_SET) // 移动到文件开头fseek(fp, 10L, SEEK_SET) // 移动到文件的第10个字节fseek(fp, 2L, SEEK_CUR) // 从文件的当前位置向前移动两个字节fssek(fp, 0L, SEEK_END) // 移动到文件的结尾处fseek(fp, -10L, SEEK_END) // 从文件结尾处退回10个字节 如果函数执行正常, 那么返回值为0, 如果有错误, 则返回值为-1.ftellftell函数用来获得当前文件指针的位置, 它返回当前文件指针距离文件开始处的字节数目, 函数原型如下1long int ftell ( FILE * stream ); 如果函数执行失败会返回-1, 下面是一个使用示例, 接合fseek和ftell用来获得文件的大小12345678910111213141516long file_size(char *fileName) &#123; long size; FILE *fp; if((fp = fopen(fileName, "rb")) == NULL) &#123; printf("can't open file %s\n", fileName); exit(EXIT_FAILURE); &#125; fseek (fp, 0 , SEEK_END); size = ftell(fp); double mb; mb = size * 1.0 / 1024 / 1024; printf("file size is %ldB and %.2fMB \n", size, mb); fclose(fp); return size;&#125; fwrite Writes an array of count elements, each one with a size of size bytes, from the block of memory pointed by ptr to the current position in the stream. 以二进制的形式将数据块写入文件, 函数原型为:1size_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream ); 下面是参数意义: ptr - 要写入的内存数据地址 size - 单个数据块的大小 count - 写入的数据块的数量 stream - 写入的目标文件 如果写入成功, 会返回写入的数据块的数量, 即count, 如果返回值不等于count, 说明程序运行出现了错误.下面是一个使用示例:123456789101112131415161718192021void file_fwrite(char *fileName) &#123; FILE *fp; if((fp = fopen(fileName, "w+b")) == NULL) &#123; printf("can't open file %s\n", fileName); exit(EXIT_FAILURE); &#125; int count = 20, i; int *buffer; buffer = malloc(sizeof(int) * count); for(i = 0; i &lt; count; i++) &#123; buffer[i] = i; &#125; long success_num = 0; success_num = fwrite(buffer, sizeof(int) , count, fp); printf("success_num is %ld\n", success_num); fclose(fp); free(buffer);&#125; 下面是写入的内容123450000 0000 0100 0000 0200 0000 0300 00000400 0000 0500 0000 0600 0000 0700 00000800 0000 0900 0000 0a00 0000 0b00 00000c00 0000 0d00 0000 0e00 0000 0f00 00001000 0000 1100 0000 1200 0000 1300 0000 上面是以16进制的形式进行显示, 即一个数字为4位, 一个int值占32位(4个字节), 在上面的内容中, 8个数字为1个int, 如 0000 0000为第一个int值, 即0, 0100 0000为第二个int值, 即1. 这里需要说明的是在写入时是字节作为一个基本单位的, 并且低位字节是先写入的, 如0100 0000, 其中01就是int的最低位的字节. 我们来看这个例子, 如果写入文件之后的值为1234 5678, 那么其原先的值就是0x78563412 fread Reads an array of count elements, each one with a size of size bytes, from the stream and stores them in the block of memory specified by ptr. 以二进制的形式将数据块读入内存, 下面是函数原型:1size_t fread ( void * ptr, size_t size, size_t count, FILE * stream ); 下面是参数含义 ptr - 读入文件数据的内存地址 size - 单个数据块的大小 count - 数据块的数量 stream - 读取的文件 如果读入成功, 会返回读入的数据块的数量. 下面是一个使用示例:12345678910111213141516171819202122void file_fread(char *fileName) &#123; long count; int *buffer; FILE *fp; if((fp = fopen(fileName, "rb")) == NULL) &#123; printf("can't open file %s\n", fileName); exit(EXIT_FAILURE); &#125; fseek (fp, 0 , SEEK_END); count = ftell(fp); rewind(fp); buffer =(int *) malloc(sizeof(int) * count); fread(buffer, sizeof(int), count / sizeof(int), fp); int i; for(i = 0; i &lt; count/ sizeof(int); i++) &#123; printf("%d\n", buffer[i]); &#125; fclose(fp); free(buffer);&#125; rewind Sets the position indicator associated with stream to the beginning of the file. 重置文件指针到文件开头位置, 下面是函数原型:1void rewind ( FILE * stream ); setbuf 和 setvbuf当打开一个文件后, 系统会自动为该文件流分配一个缓冲区, 其大小为BUFSIZ, 我们可以通过打印BUFSIZ来获得默认的缓冲区大小. 如果想自定义缓冲区, 可以使用setbuf和setvbuf函数1printf("%d", BUFSIZ); setbuf Specifies the buffer to be used by the stream for I/O operations, which becomes a fully buffered stream. Or, alternatively, if buffer is a null pointer, buffering is disabled for the stream, which becomes an unbuffered stream. 为文件流指定一个缓冲区, 函数原型为1void setbuf ( FILE * stream, char * buffer ); buffer表示指定的缓冲区, 需要注意的一点是, 这里缓冲区的大小仍然为BUFSIZ, 只不过是缓冲区的位置发生了改变, 因此buffer的大小应该大于或者等于BUFSIZ. 该函数应该在文件刚被打开时调用, 不能在进行了读写操作之后再调用. 如果buffer的为NULL, 就表示禁用缓冲区. 下面是一个使用示例:12345678910111213141516171819202122#include &lt;stdio.h&gt;int main ()&#123; char buffer[BUFSIZ]; FILE *pFile1, *pFile2; pFile1=fopen ("myfile1.txt","w"); pFile2=fopen ("myfile2.txt","a"); setbuf ( pFile1 , buffer ); fputs ("This is sent to a buffered stream",pFile1); fflush (pFile1); setbuf ( pFile2 , NULL ); fputs ("This is sent to an unbuffered stream",pFile2); fclose (pFile1); fclose (pFile2); return 0;&#125; setvbuf Specifies a buffer for stream. The function allows to specify the mode and size of the buffer (in bytes). 为文件指定一个缓冲区, 同时可以指定缓冲区的类型和大小, 下面是函数原型:1int setvbuf ( FILE * stream, char * buffer, int mode, size_t size ); 其中 stream表示操作的文件, buffer为指定的缓冲区首地址, 如果缓冲区为NULL, 系统会自动创建一个大小为size的缓冲区, mode为缓冲区的类别, size为缓冲区的大小, 其中mode的值可以为下面几个: _IOFBF - 全缓冲(Full buffering), 当缓冲区满时才执行真正的I/O操作, 例如对磁盘文件的读写. On output, data is written once the buffer is full (or flushed). On Input, the buffer is filled when an input operation is requested and the buffer is empty. _IOLBF - 行缓冲(Line buffering), 在输入和输出时遇到换行符时才进行真正的I/O操作, 例如标准输入(stdin)和标准输出(stdout). On output, data is written when a newline character is inserted into the stream or when the buffer is full (or flushed), whatever happens first. On Input, the buffer is filled up to the next newline character when an input operation is requested and the buffer is empty. _IONBF - 无缓冲(No buffering), 在这种情况下buffer和size参数会被忽略. 其实setbuf将相当于调用了setvbuf1setvbuf(stream, buf, buf ? _IOFBF : _IONBF, BUFSIZE) 下面是一个使用示例:123456789101112#include &lt;stdio.h&gt;int main ()&#123; FILE *pFile; pFile=fopen ("myfile.txt","w"); setvbuf ( pFile , NULL , _IOFBF , 1024 ); // File operations here fclose (pFile); return 0;&#125; fflush对于输入输出流, 下列情况会自动刷新缓冲区 当进行输出(output)操作时, 输出缓冲区满了 当流(stream)被关闭 当程序调用exit方法终止 当缓冲区为行缓冲区时, 一个换行符(newline)被写入 Whenever an input operation on any stream actually reads data from its file. 对于一个输出流, 可以调用fflush进行显示的刷新缓冲区, 即将缓冲区的内容写入到文件中, 但是对于一个输入流使用fflush函数的效果没有定义. 下面是函数原型:1int fflush ( FILE * stream ); 如果stream为NULL, 那么所有的缓冲区都将被刷新. statstat函数主要用于获取文件状态, 函数原型为1int stat (const char *filename, struct stat *buf) 下面是struct stat的定义:12345678910111213141516171819202122232425262728struct stat &#123; //device 文件的设备编号 dev_t st_dev; //inode 文件的i-node ino_t st_ino; //protection 文件的类型和存取的权限 mode_t st_mode; //number of hard links 连到该文件的硬连接数目, 刚建立的文件值为1. nlink_t st_nlink; //user ID of owner 文件所有者的用户识别码 uid_t st_uid; //group ID of owner 文件所有者的组识别码 gid_t st_gid; //device type 若此文件为装置设备文件, 则为其设备编号 dev_t st_rdev; //total size, in bytes 文件大小, 以字节计算 off_t st_size; //blocksize for filesystem I/O 文件系统的I/O 缓冲区大小. unsigned long st_blksize; //number of blocks allocated 占用文件区块的个数, 每一区块大小为512 个字节. unsigned long st_blocks; //time of lastaccess 文件最近一次被存取或被执行的时间, 一般只有在用mknod、utime、read、write 与tructate 时改变. time_t st_atime; //time of last modification 文件最后一次被修改的时间, 一般只有在用mknod、utime 和write 时才会改变 time_t st_mtime; //time of last change i-node 最近一次被更改的时间, 此参数会在文件所有者、组、权限被更改时更新 time_t st_ctime; &#125;; 其中st_mode定义了以下数种情况 S_IFMT - 0170000 文件类型的位遮罩 S_IFSOCK - 0140000 scoket S_IFLNK - 0120000 符号连接 S_IFREG - 0100000 一般文件 S_IFBLK - 0060000 区块装置 S_IFDIR - 0040000 目录 S_IFCHR - 0020000 字符装置 S_IFIFO - 0010000 先进先出 S_ISUID - 04000 文件的 (set user-id on execution)位 S_ISGID - 02000 文件的 (set group-id on execution)位 S_ISVTX - 01000 文件的sticky 位 S_IRUSR (S_IREAD) - 00400 文件所有者具可读取权限 S_IWUSR (S_IWRITE) - 00200 文件所有者具可写入权限 S_IXUSR (S_IEXEC) - 00100 文件所有者具可执行权限 S_IRGRP - 00040 用户组具可读取权限 S_IWGRP - 00020 用户组具可写入权限 S_IXGRP - 00010 用户组具可执行权限 S_IROTH - 00004 其他用户具可读取权限 S_IWOTH - 00002 其他用户具可写入权限 S_IXOTH - 00001 其他用户具可执行权限上述的文件类型在 POSIX 中定义了检查这些类型的宏定义 S_ISLNK (st_mode) - 判断是否为符号连接 S_ISREG (st_mode) - 是否为一般文件 S_ISDIR (st_mode) - 是否为目录 S_ISCHR (st_mode) - 是否为字符装置文件 S_ISBLK (s3e) - 是否为先进先出 S_ISSOCK (st_mode) - 是否为socket 若一目录具有sticky 位 (S_ISVTX), 则表示在此目录下的文件只能被该文件所有者、此目录所有者或root 来删除或改名. 下面是一个使用示例:1234567891011121314151617181920212223242526void file_stat(char * fileName) &#123; struct stat fileStat; stat(fileName, &amp;fileStat); printf("Information for %s\n", fileName); printf("---------------------------\n"); printf("File Size: \t\t%ld bytes\n",fileStat.st_size); printf("Number of Links: \t%ld\n",fileStat.st_nlink); printf("File inode: \t\t%ld\n",fileStat.st_ino); printf("File Permissions: \t"); printf( (S_ISDIR(fileStat.st_mode)) ? "d" : "-"); printf( (fileStat.st_mode &amp; S_IRUSR) ? "r" : "-"); printf( (fileStat.st_mode &amp; S_IWUSR) ? "w" : "-"); printf( (fileStat.st_mode &amp; S_IXUSR) ? "x" : "-"); printf( (fileStat.st_mode &amp; S_IRGRP) ? "r" : "-"); printf( (fileStat.st_mode &amp; S_IWGRP) ? "w" : "-"); printf( (fileStat.st_mode &amp; S_IXGRP) ? "x" : "-"); printf( (fileStat.st_mode &amp; S_IROTH) ? "r" : "-"); printf( (fileStat.st_mode &amp; S_IWOTH) ? "w" : "-"); printf( (fileStat.st_mode &amp; S_IXOTH) ? "x" : "-"); printf("\n\n"); printf("The file %s a symbolic link\n", (S_ISLNK(fileStat.st_mode)) ? "is" : "is not");&#125; 输出结果如下:12345678Information for data/test.txt---------------------------File Size: 24023896 bytesNumber of Links: 1File inode: 8261278File Permissions: -rw-rw-r--The file is not a symbolic link]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenMP学习笔记】更多指令和子句介绍]]></title>
    <url>%2F2016%2F02%2F26%2F%E3%80%90OpenMP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%9B%B4%E5%A4%9A%E6%8C%87%E4%BB%A4%E5%92%8C%E5%AD%90%E5%8F%A5%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[指令flushflush指令主要用于处理内存一致性问题. 每个处理器(processor)都有自己的本地(local)存储单元:寄存器和缓存, 当一个线程更新了共享变量之后, 新的值会首先存储到寄存器中, 然后更新到本地缓存中. 这些更新并非立刻就可以被其他线程得知, 因此在其它处理器中运行的线程不能访问这些存储单元. 如果一个线程不知道这些更新而使用共享变量的旧值就行运算, 就可能会得到错误的结果.通过使用flush指令, 可以保证线程读取到的共享变量的最新值. 下面是语法形式:1#pragma omp flush[(list)] list指定需要flush的共享变量, 如果不指定list, 将flush作用于所有的共享变量. 在下面的几个位置已经隐式的添加了不指定list的flush指令. 所有隐式和显式的路障(barrier) Entry to and exit from critical regions Entry to and exit from lock routines threadprivatethreadprivate作用于全局变量, 用来指定该全局变量被各个线程各自复制一份私有的拷贝, 即各个线程具有各自私有、线程范围内的全局对象, 语法形式如下:1#pragma omp threadprivate(list) 其与private不同的时, threadprivate变量是存储在heap或者Thread local storage当中, 可以跨并行域访问, 而private绝大多数情况是存储在stack中, 只在当前并行域中访问, 下面是一个使用示例:12345678910111213141516int counter;#pragma omp threadprivate(counter)void test_threadprivate() &#123; #pragma omp parallel &#123; counter = omp_get_thread_num(); printf("1: thread %d : counter is %d\n", omp_get_thread_num(), counter); &#125; printf("\n"); #pragma omp parallel &#123; printf("2: thread %d : counter is %d\n", omp_get_thread_num(), counter); &#125;&#125; 下面是输出结果1234567891: thread 3 : counter is 31: thread 0 : counter is 01: thread 2 : counter is 21: thread 1 : counter is 12: thread 2 : counter is 22: thread 0 : counter is 02: thread 3 : counter is 32: thread 1 : counter is 1 从输出结果我们可以看到, 在第二个并行域中, counter保存了在第一个并行域中的值. 如果要使两个并行域之间可以共享threadprivate变量的值, 需要满足以下几个条件: 任意一个并行域都不能嵌套在其他并行域中(Neither parallel region is nested inside another explicit parallel region.) 执行两个并行域的线程数量要相同(The number of threads used to execute both parallel regions is the same.) 执行两个并行域时的线程亲和度策略要相同( The thread affinity policies used to execute both parallel regions are the same.) 在进入并行域之前dyn-var变量的值必须为false(0). (The value of the dyn-var internal control variable in the enclosing task region is false at entry to both parallel regions.) 子句if用来控制并行域是串行执行还是并行执行, 只能作用于paralle指令, 下面是其语法形式:1#pragma omp parallel if(scalar-logical-expression) 如果if的判断条件为true, 则并行执行, 否则串行执行, 下面是一个使用示例12345678910111213141516171819202122void test_if() &#123; int n = 1, tid; printf("n = 1\n");#pragma omp parallel if(n&gt;5) default(none) \ private(tid) shared(n) &#123; tid = omp_get_thread_num(); printf("thread %d is running\n", tid); &#125; printf("\n"); n = 10; printf("n = 10\n");#pragma omp parallel if(n&gt;5) default(none) \ private(tid) shared(n) &#123; tid = omp_get_thread_num(); printf("thread %d is running\n", tid); &#125;&#125; 输出结果如下12345678n = 1thread 0 is runningn = 10thread 0 is runningthread 2 is runningthread 3 is runningthread 1 is running reduction如果利用循环, 将某项计算的所有结果进行求和(或者减、乘等其他操作)得出一个数值, 这在并行计算中十分常见, 通常将其称为规约. OpenMP提供了reduction子句由于规约操作, 其语法形式为1reduction(operator:list) 下面是一个使用实例:12345678910111213141516void test_reduction() &#123; int sum, i; int n = 100; int a[n]; for(i = 0; i &lt; n; i++) &#123; a[i] = i; &#125;#pragma omp parallel for default(none) \ private(i) shared(a,n) reduction(+:sum) for(i = 0; i &lt; n; i++) &#123; sum += a[i]; &#125; printf("sum is %d\n", sum);&#125; 使用规约子句之后, 无需再对sum进行保护, 下面是reduction支持的操作符以及变量的初值在使用乘法时发现其初始值同样为0, 可能和具体的实现有关. copyin将主线程中threadprivate变量的值复制到执行并行域的各个线程的threadprivate变量中, 作为各线程中threadprivate变量的初始值. 作用于parallel指令, 下面是一个使用示例:12345678910111213int counter = 10;#pragma omp threadprivate(counter)void test_copyin() &#123; printf("counter is %d\n", counter); #pragma omp parallel copyin(counter) &#123; counter = omp_get_thread_num() + counter + 1; printf(" thread %d : counter is %d\n", omp_get_thread_num(), counter); &#125; printf("counter is %d\n", counter);&#125; 下面是输出结果:123456counter is 10thread 0 : counter is 11thread 2 : counter is 13thread 3 : counter is 14thread 1 : counter is 12counter is 11 copyprivate将一个线程私有变量的值广播到执行同一并行域的其他线程. 只能作用于single指令, 下面是一个使用示例:1234567891011121314151617int counter = 10;#pragma omp threadprivate(counter)void test_copyprivate() &#123; int i;#pragma omp parallel private(i) &#123; #pragma omp single copyprivate(i, counter) &#123; i = 50; counter = 100; printf("thread %d execute single\n", omp_get_thread_num()); &#125; printf("thread %d: i is %d and counter is %d\n",omp_get_thread_num(), i, counter); &#125;&#125; 下面是程序运行结果:12345thread 3 execute singlethread 2: i is 50 and counter is 100thread 3: i is 50 and counter is 100thread 0: i is 50 and counter is 100thread 1: i is 50 and counter is 100 下面是将copyprivate(i, counter)去掉的运行结果12345thread 0 execute singlethread 2: i is 0 and counter is 10thread 0: i is 50 and counter is 100thread 3: i is 0 and counter is 10thread 1: i is 32750 and counter is 10]]></content>
      <categories>
        <category>OpenMP</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>OpenMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenMP学习笔记】与运行环境交互]]></title>
    <url>%2F2016%2F02%2F26%2F%E3%80%90OpenMP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[Internal Control VariablesOpenMP标准定义了内部控制变量(internal control variables), 这些变量可以影响程序运行时的行为, 但是它们不能被直接访问或者修改, 我们需要通过OpenMP函数或者环境变量来访问或者修改它们, 下面是被定义的内部变量 nthread-var : 存储并行域的线程数量 dyn-var : 控制在并行域执行时是否可以动态调整线程的数量 nest-var : 控制在并行域执行时是否允许嵌套并行 run-sched-var : 存储在循环域(loop regions)使用 runtime 调度子句时的调度类型 def-sched-var : 存储对于循环域默认的调度类型 nthread-var我们可以通过以下几种方式来设置线程数量 OMP_NUM_THREADS我们可以在命令行(command line)下设置OMP_NUM_THREADS环境变量的值, 而该变量的值用于初始化 nthread-var 变量. omp_set_num_threads在程序中我们可以使用omp_set_num_threads函数来设置线程数量, 语法形式为omp_set_num_threads(integer) num_threads最后我们可以在构造并行域的时候使用num_threads子句来控制线程的数量 上面的三种方式优先级依次递增, 另外在程序执行时, 我们可以使用下面几个函数获得线程的数量信息 omp_get_max_threads : 获得可以使用的最大线程数量, 数量是可以确定的, 与在串行域还是并行域调用无关. omp_get_num_threads: 获得当前运行线程的数量, 如果不在并行域内调用则返回1 omp_get_thread_num: 获得线程的编号, 从0开始 下面是一个使用示例1234567891011121314151617181920void test_numthread() &#123; printf("max thread nums is %d\n", omp_get_max_threads()); printf("omp_get_num_threads: out parallel region is %d\n", omp_get_num_threads()); omp_set_num_threads(2); printf("after omp_set_num_threads: max thread nums is %d\n", omp_get_max_threads());#pragma omp parallel &#123; #pragma omp master &#123; printf("omp_get_num_threads: in parallel region is %d\n\n", omp_get_num_threads()); &#125; printf("1: thread %d is running\n", omp_get_thread_num()); &#125; printf("\n");#pragma omp parallel num_threads(3) &#123; printf("2: thread %d is running\n", omp_get_thread_num()); &#125;&#125; 下面是程序运行结果:1234567891011max thread nums is 4omp_get_num_threads: out parallel region is 1after omp_set_num_threads: max thread nums is 2omp_get_num_threads: in parallel region is 21: thread 0 is running1: thread 1 is running2: thread 0 is running2: thread 1 is running2: thread 2 is running dyn-vardyn-var控制程序是否在运行中是都可以动态的调整线程的数量, 可以通过下面的两种方式来设置 OMP_DYNAMIC通过OMP_DYNAMIC环境变量来控制, 如果设为true, 则代表允许动态调整, 设为false则不可以 omp_set_dynamic通过omp_set_dynamic函数, omp_set_dynamic(1)表示允许, omp_set_dynamic(0)表示不可以, 注意omp_set_dynamic可以传入其他非负整数, 但是作用和输入1是相同的, 都是表示true. 可以通过omp_get_dynamic来获得dynamic的状态, 返回值为0和1, 下面是一个使用示例:12345678910111213141516171819void test_dynamic() &#123; printf("dynamic state is %d\n", omp_get_dynamic()); omp_set_num_threads(6); #pragma omp parallel &#123; printf("thread %d is running\n", omp_get_thread_num()); &#125; omp_set_dynamic(1); printf("\n"); printf("dynamic state is %d\n", omp_get_dynamic()); #pragma omp parallel &#123; printf("thread %d is running\n", omp_get_thread_num()); &#125;&#125; 下面是输出结果:12345678910111213dynamic state is 0thread 3 is runningthread 4 is runningthread 0 is runningthread 5 is runningthread 1 is runningthread 2 is runningdynamic state is 1thread 3 is runningthread 1 is runningthread 2 is runningthread 0 is running 当允许动态调整之后, 第二个for循环只打印了四次,即只有四个线程在执行. 一般来说动态调整会根据系统资源来确定线程数量, 大多数情况下会生成和CPU数目相同的线程. 还有一点, 动态调整时生成的线程不会超过当前运行环境所允许的最大线程数量, 在上面的代码中, 如果将omp_set_num_threads(6)改为omp_set_num_threads(2), 那么动态调整时最多只会生成两个线程. nest-varnest-var用来控制是否可以嵌套并行, 可以通过下面两种方式来设置 OMP_NESTED通过设置OMP_NESTED环境变量, true表示允许, false表示不允许 omp_set_nested通过omp_set_nested函数, omp_set_nested(1或其他非负整数)表示允许, omp_set_nested(0)表示不允许. 可以通过omp_get_nested来获得是否可以嵌套并行, 返回值是0或1, 下面是一个使用示例:123456789101112131415161718192021222324252627282930void test_nested() &#123; int tid; printf("nested state is %d\n", omp_get_nested()); #pragma omp parallel num_threads(2) private(tid) &#123; tid = omp_get_thread_num(); printf("In outer parallel region: thread %d is running\n", tid); #pragma omp parallel num_threads(2) firstprivate(tid) &#123; printf("In nested parallel region: thread %d is running and outer thread is %d\n", omp_get_thread_num(), tid); &#125; &#125; omp_set_nested(1); printf("\n"); printf("nested state is %d\n", omp_get_nested()); #pragma omp parallel num_threads(2) private(tid) &#123; tid = omp_get_thread_num(); printf("In outer parallel region: thread %d is running\n", tid); #pragma omp parallel num_threads(2) &#123; printf("In nested parallel region: thread %d is running and outer thread is %d\n", omp_get_thread_num(), tid); &#125; &#125;&#125; 下面是程序运行结果:12345678910111213nested state is 0In outer parallel region: thread 0 is runningIn nested parallel region: thread 0 is running and outer thread is 0In outer parallel region: thread 1 is runningIn nested parallel region: thread 0 is running and outer thread is 1nested state is 1In outer parallel region: thread 1 is runningIn outer parallel region: thread 0 is runningIn nested parallel region: thread 0 is running and outer thread is 0In nested parallel region: thread 0 is running and outer thread is 1In nested parallel region: thread 1 is running and outer thread is 1In nested parallel region: thread 1 is running and outer thread is 0 当不允许嵌套并行时, 在并行域内创建的新并行域会以单线程执行, 而允许嵌套并行之后, 会在并行域内创建新的并行域, 为其分配新的线程执行. def-sched-var通过OMP_SCHEDULE环境变量, 可以设置循环调度为runtime时的调度类型, 具体参见这里 其它函数omp_get_num_procs获得程序中可以使用的处理器数量, 是一个全局的值 omp_in_parallel判断是否在一个活跃的并行域(active parallel region)内, 返回0或1.]]></content>
      <categories>
        <category>OpenMP</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>OpenMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【应用】在线文件管理]]></title>
    <url>%2F2016%2F02%2F01%2F%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91%E5%9C%A8%E7%BA%BF%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言该应用主要目的是为了在使用linux系统的时候，实现手机和电脑之间的文件传输。前台界面使用的是angular-filemanager, 后台使用的是Spring MVC， 可以下载该应用的war包， 放到tomcat中使用。程序对angular-filemanager的原始功能进行了精简， 同时做了一些更改。下面该应用的具体功能： 文件上传下载（上传使用的是jquery-upload-file） 手机扫码快速打开网页 图片预览 文本文件在线编辑 文件/文件夹重名 文件/文件夹删除 下面是该应用的一些截图 前台前台使用的是使用angularjs + bootstrap写的一个在线文件管理系统， 这里是github地址， 后台作者已经给出了php和servlet的实现， 之所以使用Spring MVC重写后台，主要是为了熟悉一下Spring MVC， 同时精简了该管理系统的一些功能，因为主要目的是在linux系统下为手机和电脑之间的文件传输提供一个中介，当然也可以在windows系统下使用，也可以将该应用作为一个局域网中的一个文件共享系统。下面主要介绍在更改界面时的遇到的一些问题。 Jquery-upload-file进行文件上传的插件有很多，比如bootstrap-fileinput 和 jQuery-File-Upload，不过这里使用的是jquery-upload-file，因为感觉比上面两种更加简单，下面是一个使用示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;jquery-upload-file demo&lt;/title&gt; &lt;link href="http://7xqp2l.com1.z0.glb.clouddn.com/uploadfile.css" rel="stylesheet"&gt; &lt;script src="http://7xqp2l.com1.z0.glb.clouddn.com/jquery-1.11.2.min.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="http://7xqp2l.com1.z0.glb.clouddn.com/jquery.uploadfile.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; #content &#123; width: 600px; margin: 0 auto; &#125; .ajax-file-upload-filename &#123; width: 590px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="content"&gt; &lt;div id="fileuploader"&gt;Upload&lt;/div&gt; &lt;button id="extrabutton" class="ajax-file-upload-green"&gt;上传&lt;/button&gt;&lt;/div&gt;&lt;script&gt; $(document).ready(function () &#123; var extraObj = $("#fileuploader").uploadFile(&#123; url: "uploadFile", fileName: "file", showFileSize: true, showDelete: true, autoSubmit: false, statusBarWidth: 590, dragdropWidth: 590, dragdropHeight: 200, uploadStr: "选择", cancelStr: "取消", "abortStr": "终止", "deleteStr": "删除", dynamicFormData: function () &#123; var data = &#123;"param": ""&#125;; return data; &#125;, onSuccess: function (files, data, xhr, pd) &#123; var obj = eval(data); console.log(obj); &#125; &#125;); $("#extrabutton").click(function() &#123; extraObj.startUpload(); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 下面是效果 在线演示(只是界面)下面说几个选项： url - 文件上传地址，相当于&lt;form&gt;的action属性 fileName - 文件上传的name属性，相当于&lt;input type=&#39;file&#39; name=&#39;file&#39;&gt;中的name dynamicFormData - 提供动态的表单数据，格式为{&quot;key&quot;: &quot;value&quot;} onSuccess - 文件上传成功的回调函数 更多的选项和参数可以参考官方文档 Angularjs 集成 jquery-upload-file我们使用jquery-upload-file插件代替了系统中原来的上传界面，关于angularjs和jquery插件的整合可以参考Angularjs集成第三方js插件之Uploadify，下面说明如何讲angularjs和jquery-upload-file整合 在angularjs中配置jquery-upload-file的directive123456789101112131415161718192021222324252627282930313233343536app.directive("jqueryUpload", ["fileNavigator", function (fileNavigator) &#123; return &#123; require: '?ngModel', restrict: 'A', link: function ($scope, element, attrs, ngModel) &#123; extraObj = $(element).uploadFile(&#123; url: "uploadFile", fileName: "file", showFileSize: true, showDelete: true, autoSubmit: false, statusBarWidth: "auto", dragdropWidth: "auto", dragdropHeight: 200, uploadStr: "选择", cancelStr: "取消", "abortStr": "终止", "deleteStr": "删除", dynamicFormData: function () &#123; var data = &#123;"path": $scope.fileNavigator.currentPath.join('/')&#125;; return data; &#125;, onSuccess: function (files, data, xhr, pd) &#123; var obj = eval(data); if (obj.success) &#123; $scope.fileNavigator.refresh(); &#125; else &#123; pd.progressDiv.hide(); pd.statusbar.append("&lt;span class='ajax-file-upload-error'&gt;ERROR: " + obj.error + "&lt;/span&gt;"); &#125; &#125; &#125;); &#125; &#125;; &#125;]); 其中[&quot;fileNavigator&quot;, function (fileNavigator)表示将fileNavigator注入进来以便使用。extraObj是预定义的一个全局变量，因为实在没有搞清楚angularjs的全局变量如何定义使用，所以直接在index.html中定义了该变量123&lt;script type="text/javascript"&gt; var extraObj;&lt;/script&gt; 使用directive定义好了directive之后，使用十分简单，如下所示1&lt;div id=&quot;fileuploader&quot; jquery-upload=&quot;&quot; &gt;选择&lt;/div&gt; 其中jquery-upload和directive中的jqueryUpload相对应。 Bootstrap 弹出框bootstrap对弹出框进行了封装，使用起来十分方便，下面是一个使用示例：123456789101112131415161718192021222324252627282930313233343536373839&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;bootstrap modal demo&lt;/title&gt; &lt;link href="http://7xqp2l.com1.z0.glb.clouddn.com/bootstrap-v3.3.4-bootstrap.min.css" rel="stylesheet"&gt; &lt;script src="http://7xqp2l.com1.z0.glb.clouddn.com/jquery-1.11.2.min.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="http://7xqp2l.com1.z0.glb.clouddn.com/bootstrap-v3.3.4-bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button class="btn btn-primary btn-lg" data-toggle="modal" data-target="#myModal"&gt;通过data-target打开弹窗&lt;/button&gt;&lt;button class="btn btn-primary btn-lg" onclick="openDialog();"&gt;通过js打开弹窗&lt;/button&gt;&lt;div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true"&gt; &lt;div class="modal-dialog"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal" aria-hidden="true"&gt;&amp;times;&lt;/button&gt; &lt;h4 class="modal-title" id="myModalLabel"&gt;标题&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-body"&gt;这里是内容&lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;关闭&lt;/button&gt; &lt;button type="button" class="btn btn-primary"&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- /.modal-content --&gt; &lt;/div&gt;&lt;!-- /.modal --&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; function openDialog() &#123; $('#myModal').modal(); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 有两种方式可以操作弹窗 指定data-target属性 使用javascript控制 上面代码演示了这两种方式，在线演示 Jquery生成二维码二维码生成插件使用的jquery-qrcode，这里是github地址，下面是一个示例代码12345678910111213141516171819202122232425262728293031&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;jquery 二维码生成插件&lt;/title&gt; &lt;script src="http://7xqp2l.com1.z0.glb.clouddn.com/jquery-1.11.2.min.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="http://7xqp2l.com1.z0.glb.clouddn.com/jquery.qrcode.min.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; #qrcode1&#123; float: left; margin-right: 20px; &#125; #qrcode2&#123; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="qrcode1"&gt;&lt;/div&gt;&lt;div id="qrcode2"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; $('#qrcode1').qrcode("http://zhangjikai.com"); $('#qrcode2').qrcode(&#123;width: 128,height: 128,text: "http://zhangjikai.com"&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Jquery 动态操作DOM元素下面是一个示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;jquery-upload-file demo&lt;/title&gt; &lt;script src="http://7xqp2l.com1.z0.glb.clouddn.com/jquery-1.11.2.min.js" type="text/javascript"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; #content &#123; width: 600px; margin: 0 auto; &#125; .red_color&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="content"&gt;&lt;/div&gt;&lt;script&gt; var content = $("#content"); $("&lt;h1 /&gt;", &#123; "text":"Hello World", "class" : "red_color" &#125;).appendTo(content); var ulObj = $("&lt;ul /&gt;",&#123; "id" : "ulObj" &#125;).appendTo(content); for(var i = 0; i &lt; 4; i++) &#123; $("&lt;li /&gt;", &#123; "text" : "这是项目" + i &#125;).appendTo(ulObj); &#125; var btnObj = $("&lt;button /&gt;", &#123; "text" : "点我删除列表", "id" : "btnObj" &#125;).appendTo(content); $("#btnObj").click(function(e) &#123; $("#ulObj").remove(); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在线演示]]></content>
      <categories>
        <category>应用</category>
      </categories>
      <tags>
        <tag>应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenMP学习笔记】编译制导指令]]></title>
    <url>%2F2016%2F01%2F25%2F%E3%80%90OpenMP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%BC%96%E8%AF%91%E5%88%B6%E5%AF%BC%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[前言OpenMP通过在串行程序中插入编译制导指令, 来实现并行化, 支持OpenMP的编译器可以识别, 处理这些指令并实现对应的功能. 所有的编译制导指令都是以#pragma omp开始, 后面跟具体的功能指令(directive)或者命令. 一般格式如下所示:12#pragma omp directive [clause [[,] clause]...] structured block Parallel Construct(并行域结构)为了使程序可以并行执行, 我们首先要构造一个并行域(parallel region), 在这里我们使用parallel指令来实现并行域的构造, 其语法形式如下12#pragma omp parallel [clause [[,] clause]...] structured block 我们看到其实就是在omp后面加了一个parallel关键字, 该指令主要作用就是用来构造并行域, 创建线程组并且并发执行任务. 需要注意的是该指令只保证代码以并行的方式执行, 但是并不负责线程之间的任务分发. 在并行域执行结束之后, 会有一个隐式的屏障(barrier), 来同步所有的该区域内的所有线程. 下面是一个使用示例:123456void parallel_construct() &#123; #pragma omp parallel &#123; printf("Hello from thread %d\n", omp_get_thread_num()); &#125;&#125; 其中omp_get_thread_num()用来获取当前线程的编号, 该函数是定义在&lt;omp.h&gt;中的. 输出结果如下:1234Hello from thread 1Hello from thread 3Hello from thread 0Hello from thread 2 parallel指令后面可以跟一些子句(clause), 如下所示123456789101112131415if(scalar-expression)num_threads(integer-expression)private(list)firstprivate(list)shared(list)default(none | shared)copyin(list)reduction(operator:list) 在后面会介绍这些从句的用法 Work-sharing Construct(任务分担结构)任务分担指令主要用于为线程分配不同的任务, 一个任务分担域(work-sharing region)必须要和一个活跃(active)的并行域(parellel region)关联, 如果任务分担指令处于一个不活跃的并行域或者处于一个串行域中, 那么该指令就会被忽略. 在C/C++有3个任务分担指令: for、sections、single, 严格意义上讲只有for和sections是任务分担指令, 而single只是协助任务分担的指令. for用于for循环中, 将不同的循环分配给不同的线程, 语法如下所示:12#pragma omp for [clause[[,] clause]...] for-loop 下面是一个使用示例:1234567891011void parallel_for() &#123; int n = 9; int i = 0; #pragma omp parallel shared(n) private(i) &#123; #pragma omp for for(i = 0; i &lt; n; i++) &#123; printf("Thread %d executes loop iteration %d\n", omp_get_thread_num(),i); &#125; &#125;&#125; 下面是程序执行结果123456789Thread 2 executes loop iteration 5Thread 2 executes loop iteration 6Thread 3 executes loop iteration 7Thread 3 executes loop iteration 8Thread 0 executes loop iteration 0Thread 0 executes loop iteration 1Thread 0 executes loop iteration 2Thread 1 executes loop iteration 3Thread 1 executes loop iteration 4 在上面的程序中共有4个线程执行9次循环, 线程0分到了3次, 剩余的线程分到了2次, 这是一种常用的调度方式, 即假设有n次循环迭代, t个线程, 那么每个线程分配到n/t 或者 n/t + 1 次连续的迭代计算, 但是某些情况下使用这种方式并不是最好的选择, 我们可以使用schedule 来指定调度方式, 在后面会具体介绍. 下面是for 指令后面可以跟的一些子句:12345678910111213private(list)fistprivate(list)lastprivate(list)reduction(operator:list)orderedschedule(kind[,chunk_size])nowait sectionssections指令可以为不同的线程分配不同的任务, 语法如下所示:12345678#pragma omp sections [clause[[,] clause]...] &#123; [#pragma omp section] structured block [#pragma omp section] structured block ... &#125; 从上面的代码中我们可以看到, sections将代码分为多个section, 每个线程处理一个section, 下面是一个使用示例:123456789101112131415161718192021222324252627282930313233/** * 使用#pragma omp sections 和 #pragma omp section, 来使不同的线程执行不同的任务 * 如果线程数量大于section数量, 那么多余的线程会处于空闲状态(idle) * 如果线程数量少于section数量, 那么一个线程会执行多个section代码 */void funcA() &#123; printf("In funcA: this section is executed by thread %d\n", omp_get_thread_num());&#125;void funcB() &#123; printf("In funcB: this section is executed by thread %d\n", omp_get_thread_num());&#125;void parallel_section() &#123; #pragma omp parallel &#123; #pragma omp sections &#123; #pragma omp section &#123; (void)funcA(); &#125; #pragma omp section &#123; (void)funcB(); &#125; &#125; &#125; &#125; 下面是执行结果:12In funcA: this section is executed by thread 3In funcB: this section is executed by thread 0 下面是sections后面可以跟的一些子句123456789private(list)firstprivate(list)lastprivate(list)reduction(operator:list)nowait singlesingle 指令用来指定某段代码块只能被一个线程来执行, 如果没有nowait字句, 所有线程在 single 指令结束处隐市同步点同步, 如果single指令有nowait从句, 则别的线程直接往下执行. 不过single指令并不指定哪个线程来执行. 语法如下所示:12#pragma omp single [clause[[,] clause]...] structured block 下面是一个使用示例123456789101112131415161718192021222324void parallel_single() &#123; int a = 0, n = 10, i; int b[n]; #pragma omp parallel shared(a, b) private(i) &#123; // 只有一个线程会执行这段代码, 其他线程会等待该线程执行完毕 #pragma omp single &#123; a = 10; printf("Single construct executed by thread %d\n", omp_get_thread_num()); &#125; // A barrier is automatically inserted here #pragma omp for for(i = 0; i &lt; n; i++) &#123; b[i] = a; &#125; &#125; printf("After the parallel region:\n"); for (i=0; i&lt;n; i++) printf("b[%d] = %d\n",i,b[i]);&#125; 下面是执行结果:123456789101112Single construct executed by thread 2After the parallel region:b[0] = 10b[1] = 10b[2] = 10b[3] = 10b[4] = 10b[5] = 10b[6] = 10b[7] = 10b[8] = 10b[9] = 10 下面是single指令后面可以跟随的子句:1234567private(list)firstprivate(list)copyprivate(list)nowait Combined Parallel Work-Sharing Constructs将parallel指令和work-sharing指令结合起来, 使代码更加简洁. 如下面的代码12345#pragma omp parallel&#123; #pragma omp for for(.....)&#125; 可以写为12#pragma omp parallel for for(.....) 具体的参见下图:使用这些组合结构体(combined constructs)不仅增加程序的可读性, 而且对程序的性能有一定的帮助. 当使用这些组合结构体的时候, 编译器可以知道下一步要做什么, 从而可能会生成更高效的代码. Clauses to Control Parallel and Work-Sharing ConstructsOpenMP指令后面可以跟一些子句, 用来控制构造器的行为. 下面介绍一些常用的子句. sharedshared子句用来指定哪些数据是在线程之间共享的, 语法形式为shared(list), 下面是其使用方法:12345#pragma omp parallel for shared(a) for(i = 0; i &lt; n; i++) &#123; a[i] += i; &#125; 在并行域中使用共享变量时, 如果存在写操作, 需要对共享变量加以保存, 因为可能存在多个线程同时修改共享变量或者在一个线程读取共享变量时另外一个变量在更新共享变量的情况, 而这些情况都可能会引起程序错误. privateprivate子句用来指定哪些数据是线程私有的, 即每个线程具有变量的私有副本, 线程之间互不影响. 其语法形式为private(list), 使用方法如下:1234567891011121314void test_private() &#123; int n = 8; int i=2, a = 3; // i,a 定义为private之后不改变原先的值 #pragma omp parallel for private(i, a) for ( i = 0; i&lt;n; i++) &#123; a = i+1; printf("In for: thread %d has a value of a = %d for i = %d\n", omp_get_thread_num(),a,i); &#125; printf("\n"); printf("Out for: thread %d has a value of a = %d for i = %d\n", omp_get_thread_num(),a,i);&#125; 下面是程序运行结果:12345678910In for: thread 2 has a value of a = 5 for i = 4In for: thread 2 has a value of a = 6 for i = 5In for: thread 3 has a value of a = 7 for i = 6In for: thread 3 has a value of a = 8 for i = 7In for: thread 0 has a value of a = 1 for i = 0In for: thread 0 has a value of a = 2 for i = 1In for: thread 1 has a value of a = 3 for i = 2In for: thread 1 has a value of a = 4 for i = 3Out for: thread 0 has a value of a = 3 for i = 2 对于private子句中的变量, 需要注意一下两点: 不论该变量之前有没有初始值, 在进入并行域之后都是未初始化的. 并行域中对变量的修改只在该域中起作用, 当离开并行域后, 变量值仍然是未进入并行域之前的值 lastprivatelastprivate会在退出并行域时, 将其修饰变量的最后取值(last value)保存下来, 可以作用于 for 和 sections, 语法格式为lastprivate(list). 关于last value的定义: 如果是作用于for指令, 那么last value就是指串行执行的最后一次循环的值；如果是作用于sections指令, 那么last value就是执行完最后一个包含该变量的section之后的值. 使用方法如下:1234567891011121314void test_last_private() &#123; int n = 8; int i=2, a = 3; // lastprivate 将for中最后一次循环(i == n-1) a 的值赋给a #pragma omp parallel for private(i) lastprivate(a) for ( i = 0; i&lt;n; i++) &#123; a = i+1; printf("In for: thread %d has a value of a = %d for i = %d\n", omp_get_thread_num(),a,i); &#125; printf("\n"); printf("Out for: thread %d has a value of a = %d for i = %d\n", omp_get_thread_num(),a,i);&#125; 程序执行结果为:12345678910In for: thread 3 has a value of a = 7 for i = 6In for: thread 3 has a value of a = 8 for i = 7In for: thread 2 has a value of a = 5 for i = 4In for: thread 2 has a value of a = 6 for i = 5In for: thread 1 has a value of a = 3 for i = 2In for: thread 0 has a value of a = 1 for i = 0In for: thread 0 has a value of a = 2 for i = 1In for: thread 1 has a value of a = 4 for i = 3Out for: thread 0 has a value of a = 8 for i = 2 firstprivatefirstprivate 子句用于为private变量提供初始值. 使用firstprivate修饰的变量会使用在前面定义的同名变量的值作为其初始值. 语法形式为firstprivate(list), 使用方法如下:12345678910111213void test_first_private() &#123; int n = 8; int i=0, a[n]; for(i = 0; i &lt; n ;i++) &#123; a[i] = i+1; &#125;#pragma omp parallel for private(i) firstprivate(a) for ( i = 0; i&lt;n; i++) &#123; printf("thread %d: a[%d] is %d\n", omp_get_thread_num(), i, a[i]); &#125;&#125; 执行结果如下:12345678thread 0: a[0] is 1thread 0: a[1] is 2thread 2: a[4] is 5thread 2: a[5] is 6thread 3: a[6] is 7thread 3: a[7] is 8thread 1: a[2] is 3thread 1: a[3] is 4 defaultdefault子句用于设置变量默认的data-sharing属性, 在C/C++中只支持default(none | shared), 其中default(shared)设置所有的变量默认为共享的, default(none)取消变量的默认属性, 需要显示指定变量是共享的还是私有的. nowait用于取消任务分担结构(work-sharing constructs)中的隐式屏障(implicit barrier), 下面是一个使用示例:123456789101112131415void test_nowait() &#123; int i, n =6; #pragma omp parallel &#123; #pragma omp for nowait for(i = 0; i &lt; n; i++) &#123; printf("thread %d: ++++\n", omp_get_thread_num()); &#125; #pragma omp for for(i = 0; i &lt; n; i++) &#123; printf("thread %d: ----\n", omp_get_thread_num()); &#125; &#125;&#125; 如果第一个 for 后面没有加 nowait , 那么输出如下所示:123456789101112thread 3: ++++thread 0: ++++thread 0: ++++thread 2: ++++thread 1: ++++thread 1: ++++thread 0: ----thread 0: ----thread 3: ----thread 1: ----thread 1: ----thread 2: ---- 因为for指令有一个隐式的屏障, 会同步所有的线程直到第一个for循环执行完, 再继续往下执行. 加上 nowait 之后就消除了这个屏障, 使线程执行完第一个for循环之后无需再等待其他线程就可以去执行第二个for循环的内容, 下面是加上nowait之后的输出:123456789101112thread 2: ++++thread 2: ----thread 1: ++++thread 1: ++++thread 1: ----thread 1: ----thread 3: ++++thread 3: ----thread 0: ++++thread 0: ++++thread 0: ----thread 0: ---- 使用nowait时需要注意前后for之间有没有依赖关系, 如果第二个for循环需要用到第一个for循环的结果, 那么使用nowait就可能会造成程序错误. scheduleschedule子句只作用于循环结构(loop construct), 它用来设置循环任务的调度方式. 语法形式为schedule(kind[,chunk_size]), 其中kind的取值有 static, dynamic, guided, auto, runtime, chunk_size是可选项,可以指定也可以不指定. 下面是使用方法:123456789void test_schedule() &#123; int i, n = 10;#pragma omp parallel for default(none) schedule(static, 2) \ private(i) shared(n) for(i = 0; i &lt; n; i++) &#123; printf("Iteration %d executed by thread %d\n", i, omp_get_thread_num()); &#125;&#125; 下面介绍一下各个取值的含义, 假设有n次循环, t个线程static静态调度, 如果不指定chunk_size , 那么会为每个线程分配 n/t 或者 n/t+1(不能除尽)次连续的迭代计算, 如果指定了 chunk_size, 那么每次为线程分配chunk_size次迭代计算, 如果第一轮没有分配完, 则循环进行下一轮分配, 假设n=8, t=4, 下表给出了chunk_size未指定、等于1、等于3时的分配情况. 线程编号\chunk_size 未指定 chunk_size = 1 chunk_size = 3 0 0 1 0 4 0 1 2 1 2 3 1 5 3 4 5 2 4 5 2 6 6 7 3 6 7 3 7 dynamic动态调度, 动态为线程分配迭代计算, 只要线程空闲就为其分配任务, 计算快的线程分配到更多的迭代. 如果不指定chunk_size参数, 则每次为一个线程分配一次迭代循环(相当于chunk_size=1), 若指定chunk_size, 则每次为一个线程分配chunk_size次迭代循环. 在动态调度下, 分配结果是不固定的, 重复执行同一个程序, 每次的分配结果一般来说是不同的, 下面给出n=12, t=4时, chunk_size未指定、等于2时的分配情况(运行两次) 线程编号\chunk_size 未指定(第一次) 未指定(第二次) chunk_size=2(第一次) chunk_size = 2(第二次) 0 2 0 4 5 8 9 10 11 0 1 1 0 4 5 6 7 8 9 10 11 3 0 1 4 5 2 3 1 4 5 6 7 8 9 10 11 2 3 6 7 3 1 2 6 7 2 3 8 9 10 11 使用动态动态可以一定程度减少负载不均衡的问题, 但是需要注意任务动态申请时也会有一定的开销. guidedguided调度是一种指定性的启发式自调度方法. 开始时每个线程会分配到较大的迭代块, 之后分配到的迭代块的大小会逐渐递减. 如果指定chunk_size, 则迭代块会按指数级下降到指定的chunk_size大小, 如果没有指定size参数, 那么迭代块大小最小会降到1(相当于chunk_size=1). 和动态调度一样, 执行块的线程会分到更多的任务, 不同的是这里迭代块的大小是变化的. 同样使用guided调度的分配结果也不是固定的, 重复执行会得到不同的分配结果. 下面给出n=20, t=4, chunk_size未指定、chunk_size=3时的分配情况(执行两次) 线程编号\chunk_size 未指定(第一次) 未指定(第二次) chunk_size=3(第一次) chunk_size = 3(第二次) 0 12 13 0 1 2 3 4 0 1 2 3 4 5 6 7 8 18 19 1 5 6 7 8 16 17 18 19 5 6 7 8 9 10 11 9 10 11 2 0 1 2 3 4 14 15 9 10 11 14 15 16 17 18 19 5 6 7 8 15 16 17 18 19 0 1 2 3 4 15 16 17 3 9 10 11 12 13 12 13 14 12 13 14 当设置chunk_size=3时, 因为最后只剩下18、19两次循环, 所以最后执行的那个线程只分配到2次循环. 下面的图展示了当循环次数为200次, 线程数量为4时, static 、 (dynamic,7) 、(guided, 7) 3种调度方式的分配情况 runtime运行时调度, 并不是一种真正的调度方式, 在运行时同时环境变量OMP_SCHEDULE来确定调度类型, 最终的调度类型仍为上面的3种调度方式之一. 在bash下可以使用下面的方式设置:1export OMP_SCHEDULE="static" auto将选择的权利赋予编译器, 让编译器自己选择合适的调度决策. 负载不均衡在for循环中, 如果每次循环之间花费的时间是不同的, 那么就可能出现负载不均衡问题, 下面代码模拟一下这种情况,1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071void test_schedule() &#123; int i,j, n = 10; double start, end; GET_TIME(start);#pragma omp parallel for default(none) schedule(static) \ private(i, j) shared(n) for(i = 0; i &lt; n; i++) &#123; //printf("Iteration %d executed by thread %d\n", i, omp_get_thread_num()); for(j = 0; j &lt; i; j++) &#123; system("sleep 0.1"); &#125; &#125; GET_TIME(end); printf("static : use time %.2fs\n", end-start); GET_TIME(start);#pragma omp parallel for default(none) schedule(static,2) \ private(i, j) shared(n) for(i = 0; i &lt; n; i++) &#123; for(j = 0; j &lt; i; j++) &#123; system("sleep 0.1"); &#125; &#125; GET_TIME(end); printf("static,2 : use time %.2fs\n", end-start); GET_TIME(start);#pragma omp parallel for default(none) schedule(dynamic) \ private(i, j) shared(n) for(i = 0; i &lt; n; i++) &#123; for(j = 0; j &lt; i; j++) &#123; system("sleep 0.1"); &#125; &#125; GET_TIME(end); printf("dynamic : use time %.2fs\n", end-start); GET_TIME(start);#pragma omp parallel for default(none) schedule(dynamic, 2) \ private(i, j) shared(n) for(i = 0; i &lt; n; i++) &#123; for(j = 0; j &lt; i; j++) &#123; system("sleep 0.1"); &#125; &#125; GET_TIME(end); printf("dynamic,2: use time %.2fs\n", end-start); GET_TIME(start);#pragma omp parallel for default(none) schedule(guided) \ private(i, j) shared(n) for(i = 0; i &lt; n; i++) &#123; for(j = 0; j &lt; i; j++) &#123; system("sleep 0.1"); &#125; &#125; GET_TIME(end); printf("guided : use time %.2fs\n", end-start); GET_TIME(start);#pragma omp parallel for default(none) schedule(guided, 2) \ private(i, j) shared(n) for(i = 0; i &lt; n; i++) &#123; for(j = 0; j &lt; i; j++) &#123; system("sleep 0.1"); &#125; &#125; GET_TIME(end); printf("guided,2 : use time %.2fs\n", end-start);&#125; GET_TIME的定义如下:1234567891011121314#ifndef _TIMER_H_#define _TIMER_H_#include &lt;sys/time.h&gt;#include &lt;time.h&gt;#include &lt;stdio.h&gt;#define GET_TIME(now) &#123; \ struct timeval t; \ gettimeofday(&amp;t, NULL); \ now = t.tv_sec + t.tv_usec/1000000.0; \&#125;#endif 在上面的代码中, 对于第一个for循环, i越大, 循环消耗的时间越多, 下面是n=10时的输出123456static : use time 1.74sstatic,2 : use time 1.84sdynamic : use time 1.53sdynamic,2: use time 1.84sguided : use time 1.63sguided,2 : use time 1.53s 下面是n=20的输出123456static : use time 8.67sstatic,2 : use time 6.42sdynamic : use time 5.62sdynamic,2: use time 6.43sguided : use time 5.92sguided,2 : use time 6.43s 对于static调度, 如果不指定chunk_size的值, 则会将最后几次循环分给最后一个线程, 而最后几次循环是最耗时的, 其他线程执行完各自的工作需要等待这个线程执行完毕, 浪费了系统资源, 这就造成了负载不均衡. dynamic和guided可以在一定程度上减轻负载不均衡, 但是也不是绝对的, 最终选用哪种方式还是要根据具体的问题. Synchronization Constructs(同步)同步指令主要用来控制多个线程之间对于共享变量的访问. 它可以保证线程以一定的顺序更新共享变量, 或者保证两个或多个线程不同时修改共享变量. barrier同步路障(barrier), 当线程遇到路障时必须要停下等待, 直到并行区域中的所有线程都到达路障点, 线程才继续往下执行. 在每一个并行域和任务分担域的结束处都会有一个隐式的同步路障, 即在parallel、for、sections、single构造的区域之后会有一个隐式的路障, 因此在很多时候我们无需显示的插入路障. 下面是语法形式:1#pragma omp barrier 下面是一个使用示例:123456789101112131415161718192021void print_time(int tid, char* s ) &#123; int len = 10; char buf[len]; NOW_TIME(buf, len); printf("Thread %d %s at %s\n", tid, s, buf);&#125;void test_barrier() &#123; int tid;#pragma omp parallel private(tid) &#123; tid = omp_get_thread_num(); if(tid &lt; omp_get_num_threads() / 2) system("sleep 3"); print_time(tid, "before barrier "); #pragma omp barrier print_time(tid, "after barrier "); &#125;&#125; 其中NOW_TIME的定义如下12345678910111213141516#ifndef _TIMER_H_#define _TIMER_H_#include &lt;sys/time.h&gt;#include &lt;time.h&gt;#include &lt;stdio.h&gt;#define NOW_TIME(buf, len) &#123; \ time_t nowtime; \ nowtime = time(NULL); \ struct tm *local; \ local = localtime(&amp;nowtime); \ strftime(buf, len, "%H:%M:%S", local); \&#125;#endif 在上面的代码中有一半的线程(tid &lt; 2) 会睡眠3秒之后再继续往下执行, 首先看看不加路障的输出, 即去掉#pragma omp barrier12345678Thread 3 before barrier at 16:55:44Thread 2 before barrier at 16:55:44Thread 3 after barrier at 16:55:44Thread 2 after barrier at 16:55:44Thread 1 before barrier at 16:55:47Thread 0 before barrier at 16:55:47Thread 0 after barrier at 16:55:47Thread 1 after barrier at 16:55:47 下面上加上路障的输出结果:12345678Thread 3 before barrier at 17:05:29Thread 2 before barrier at 17:05:29Thread 0 before barrier at 17:05:32Thread 1 before barrier at 17:05:32Thread 0 after barrier at 17:05:32Thread 1 after barrier at 17:05:32Thread 2 after barrier at 17:05:32Thread 3 after barrier at 17:05:32 通过对比我们可以看出, 加上路障之后, 各线程要在路障点同步一次, 然后再继续往下执行. orderedordered结构允许在并行域中以串行的顺序执行一段代码, 如果我们在并行域中想按照顺序打印被不同的线程计算的数据, 就可以使用这个子句, 下面是语法形式12#pragma omp ordered structured block 在使用时需要注意一下两点 ordered 只作用于循环结构(loop construct) 使用ordered时需要在构造并行域的时候加上ordered子句, 如下面所示1#pragma omp parallel for ordered 下面是一个使用示例123456789101112131415161718192021void test_order() &#123; int i, tid, n = 5; int a[n]; for(i = 0; i &lt; n; i++) &#123; a[i] = 0; &#125;#pragma omp parallel for default(none) ordered schedule(dynamic) \ private (i, tid) shared(n, a) for(i = 0; i &lt; n; i++) &#123; tid = omp_get_thread_num(); printf("Thread %d updates a[%d]\n", tid, i); a[i] += i; #pragma omp ordered &#123; printf("Thread %d printf value of a[%d] = %d\n", tid, i, a[i]); &#125; &#125;&#125; 下面是程序运行结果:12345678910Thread 0 updates a[0]Thread 2 updates a[2]Thread 1 updates a[3]Thread 0 printf value of a[0] = 0Thread 0 updates a[4]Thread 3 updates a[1]Thread 3 printf value of a[1] = 1Thread 2 printf value of a[2] = 2Thread 1 printf value of a[3] = 3Thread 0 printf value of a[4] = 4 从输出结果我们可以看到, 在update时是以乱序的顺序更新, 但是在打印时是以串行顺序的形式打印. critical临界区(critical), 临界区保证在任意一个时间段内只有一个线程执行该区域中的代码, 一个线程要进入临界区必须要等待临界区处于空闲状态, 下面是语法形式12#pragma omp critical [(name)] structured block 其中name是为临界区指定的一个名字. 下面是一个求和的使用示例, 注意这里只是用来说明临界区的作用, 对于求和操作我们可以使用reduction指令12345678910111213141516171819202122232425void test_critical() &#123; int n = 100, sum = 0, sumLocal, i, tid; int a[n]; for(i = 0; i &lt; n; i++) &#123; a[i] = i; &#125;#pragma omp parallel shared(n, a, sum) private (tid, sumLocal) &#123; tid = omp_get_thread_num(); sumLocal = 0; #pragma omp for for(i = 0; i &lt; n; i++) &#123; sumLocal += a[i]; &#125; #pragma omp critical(update_sum) &#123; sum += sumLocal; printf("Thread %d: sumLocal = %d sum =%d\n", tid, sumLocal, sum); &#125; &#125; printf("Value of sum after parallel region: %d\n",sum);&#125; 在该代码中, sum是全局的, localSum是每个线程执行完各自的求和任务后的和值, 将每个线程的sumLocal加给sum, 就是最后的和值. 在执行sum+=sunLocal操作时, 需要保证一次只有一个线程执行该操作, 因此这里使用了临界区, 下面是运行结果:12345Thread 2: sumLocal = 1550 sum =1550Thread 3: sumLocal = 2175 sum =3725Thread 1: sumLocal = 925 sum =4650Thread 0: sumLocal = 300 sum =4950Value of sum after parallel region: 4950 下面是将临界区去掉的运行结果(运行结果不是固定的, 这里只是其中一种情况):12345Thread 2: sumLocal = 1550 sum =1550Thread 3: sumLocal = 2175 sum =2475Thread 1: sumLocal = 925 sum =925Thread 0: sumLocal = 300 sum =300Value of sum after parallel region: 2475 通过对比我们可以看到临界区保证了程序的正确性. atomic原子操作, 可以锁定一个特殊的存储单元(可以是一个单独的变量,也可以是数组元素), 使得该存储单元只能原子的更新, 而不允许让多个线程同时去写. atomic只能作用于单条赋值语句, 而不能作用于代码块. 语法形式为:12#pragma omp atomic statement 在C/C++中, statement必须是下列形式之一 x++, x--, ++x, --x x binop= expr 其中binop是二元操作符: +, -, *, /, &amp;, ^, |, &lt;&lt;, &gt;&gt;之一 atomic的可以有效的利用的硬件的原子操作机制来控制多个线程对共享变量的写操作, 效率较高, 下面是一个使用示例1234567891011void test_atomic() &#123; int counter=0, n = 1000000, i;#pragma omp parallel for shared(counter, n) for(i = 0; i &lt; n; i++) &#123; #pragma omp atomic counter += 1; &#125; printf("counter is %d\n", counter);&#125; 对于下面的情况12#pragma omp atomicic += func(); atomic只保证ic的更新是原子的, 即不会被多个线程同时更新, 但是不会保证func函数的执行是原子的, 即多个线程可以同时执行func函数, 如果要使func的执行也是原子的, 可以使用临界区. locks互斥锁, 提供了一个更底层的机制来处理同步的问题, 比使用critical和atomic有更多的灵活性, 但也相对更加复杂一些. openmp提供了两种类型的锁–简单锁(simple locks) 和 嵌套锁(nested locks), 对于简单锁来说, 如果其处于锁住的状态, 那么它就可能无法再次被上锁. 而对于嵌套锁来说, 可以被同一个线程上锁多次. 下面是简单锁的几个函数12345void omp_init_lock(omp_lock_t *lck) // 初始化互斥锁void omp_destroy_lock(omp_lock_t *lck) // 销毁互斥锁void omp_set_lock(omp_lock_t *lck) // 获得互斥锁void omp_unset_lock(omp_lock_t *lck) // 释放互斥锁bool omp_test_lock(omp_lock_t *lck) // 尝试获得互斥锁, 如果获得成功返回true, 否则返回false 嵌套锁的函数和简单锁略有不同, 如下所示12345void omp_init_nest_lock(omp_nest_lock_t *lck)void omp_destroy_nest_lock(omp_nest_lock_t *lck)void omp_set_nest_lock(omp_nest_lock_t *lck)void omp_unset_nest_lock(omp_nest_lock_t *lck)void omp_test_nest_lock(omp_nest_lock_t *lck) 下面是一个使用示例1234567891011121314void test_lock() &#123; omp_lock_t lock; int i,n = 4; omp_init_lock(&amp;lock);#pragma omp parallel for for(i = 0; i &lt; n; i++) &#123; omp_set_lock(&amp;lock); printf("Thread %d: +\n", omp_get_thread_num()); system("sleep 0.1"); printf("Thread %d: -\n", omp_get_thread_num()); omp_unset_lock(&amp;lock); &#125; omp_destroy_lock(&amp;lock);&#125; 其中system(“sleep 0.1”) 是为了两次的输出有个间隔, 以便和不加锁时的情况进行对比. 下面是程序的输出:12345678Thread 1: +Thread 1: -Thread 2: +Thread 2: -Thread 3: +Thread 3: -Thread 0: +Thread 0: - 下面是去掉锁的输出12345678Thread 3: +Thread 2: +Thread 0: +Thread 1: +Thread 2: -Thread 3: -Thread 0: -Thread 1: - master用于指定一段代码只由主线程执行. master指令和single指令的区别如下: master指令包含的代码段只有主线程执行, 而single指令包含的代码可以由任意一个线程执行. master指令在结束处没有隐式同步, 也不可以使用nowait从句 下面是一个使用示例:123456789101112131415161718192021void test_master() &#123; int a, i, n = 5; int b[n];#pragma omp parallel shared(a, b) private(i) &#123; #pragma omp master &#123; a = 10; printf("Master construct is executed by thread %d\n", omp_get_thread_num()); &#125; #pragma omp barrier #pragma omp for for(i = 0; i &lt; n; i++) b[i] = a; &#125; printf("After the parallel region:\n"); for(i = 0; i &lt; n; i++) printf("b[%d] = %d\n", i, b[i]);&#125; 下面是输出结果1234567Master construct is executed by thread 0After the parallel region:b[0] = 10b[1] = 10b[2] = 10b[3] = 10b[4] = 10]]></content>
      <categories>
        <category>OpenMP</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>OpenMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenMP学习笔记】基本使用]]></title>
    <url>%2F2016%2F01%2F25%2F%E3%80%90OpenMP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言OpenMP 是基于共享内存模式的一种并行编程模型, 使用十分方便, 只需要串行程序中加入OpenMP预处理指令, 就可以实现串行程序的并行化. 这里主要进行一些学习记录, 使用的书籍为: Using OpenMP: Portable Shared Memory Parallel Programming 和OpenMP编译原理及实现技术 执行模式OpenMP编程模型是以线程为基础的, OpenMP 执行模式采用fork-join的方式, 其中fork创建新线程或者唤醒已有的线程, join将多个线程合并. 在程序执行的时候, 只有主线程在运行, 当遇到需要并行计算的区域, 会派生出线程来并行执行, 在并行执行的时候, 主线程和派生线程共同工作, 在并行代码结束后, 派生线程退出或者挂起, 不再工作, 控制流程回到单独的线程中下. 下图说明了fork-join模型的执行流程 HelloWorld123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;omp.h&gt;int main() &#123;#pragma omp parallel &#123; printf("The parallel region is executed by thread %d\n", omp_get_thread_num()); if ( omp_get_thread_num() == 2 ) &#123; printf(" Thread %d does things differently\n", omp_get_thread_num()); &#125; &#125; return 0;&#125; 然后使用gcc编译程序, 为了使用OpenMP需要加上-fopenmp选项1gcc -fopenmp helloworld.c -o helloworld 下面是执行结果12345The parallel region is executed by thread 2 Thread 2 does things differentlyThe parallel region is executed by thread 1The parallel region is executed by thread 3The parallel region is executed by thread 0 在上面的代码中, 程序开了四个线程, 其编号分别为0-3, 线程之间的执行是没有顺序的, 当下次再执行上述代码输出的结果可能就会不一样. 在上面的代码中, 我们并没有显式的指定线程的数量, OpenMP会根据下面的规则确定线程数量: num_threads的设置 omp_set_num_threads()库函数的设置 OMP_NUM_THREADS环境变量的设置 编译器默认实现（一般而言，默认实现的是总线程数等于处理器的核心数） 上面规则的优先级是依次递减的. 如果1 2 3 都没有指定, 那么就会使用规则4 参考文章OpenMP Tutorial学习笔记(4)OpenMP指令之同步构造（Parallel）OpenMP学习笔记：基本概念]]></content>
      <categories>
        <category>OpenMP</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>OpenMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【MIC学习笔记】向量化]]></title>
    <url>%2F2015%2F12%2F27%2F%E3%80%90MIC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%90%91%E9%87%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言向量化简单的说就是使用SIMD指令, 来实现使用一条指令同时处理多个数据, MIC中具有32个长度为512位的向量处理单元, 每个向量处理单元可以处理16个32位或者8个64位的数据. 这里主要记录一下MIC向量化的使用方式以及一些向量指令的作用. 数据类型MIC中使用下面的数据类型作为执行向量函数的操作数1__m512, __m512i __m512d 下面是它们的各自的作用: __m512 - 处理单精度向量(float32 vector) __m512d - 处理双精度向量(float64 vector) __m512i - 处理整形向量, 包括32位和64位整形(int32/int64) 上面的数据类型直接映射到向量寄存器上(vector registers), 除此之外还有一种数据类型__mmask16 - is an unsigned short type associated with the mask register values.我们可以使用 Load Intrinsics(为向量赋值) 和 Store Intrinsics (保存向量的值) 实现向量的存取. 下面是一个示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445void test_load_store() &#123; // 使用int32_t和int64_t 需要引入stdint.h int32_t *arr_int32; int64_t *arr_int64; int i, n = 32; // 需要使用_mm_malloc分配内存, 并且以64位对齐, 否则可能出现错误 arr_int32 = _mm_malloc(sizeof(int32_t) * n, 64); arr_int64 = _mm_malloc(sizeof(int64_t) * n, 64); for(i = 0; i &lt; n; i++) &#123; arr_int32[i] = i; arr_int64[i] = i + n; &#125;#pragma offload target(mic) inout(arr_int32:length(n)) inout(arr_int64:length(n)) &#123; __m512i m_32, m_64; // 将arr_int32 中0-15个元素加载到 m_32 中 m_32 = _mm512_load_epi32(arr_int32); // 将arr_int32 中16-31个元素加载到 m_32 中 m_32 = _mm512_load_epi32(arr_int32 + 16); // 将arr_int64中0-7个元素加载到 m_64 中 m_64 = _mm512_load_epi64(arr_int64); // 将arr_int64中8-15个元素加载到 m_64 中 m_64 = _mm512_load_epi64(arr_int64 + 8); // 将m_32 中的值保存到arr_int32 的0-15个元素中 _mm512_store_epi32(arr_int32, m_32); // 将m_64 中的值保存到arr_int32 的16-31个元素中 _mm512_store_epi32(arr_int32 + 16, m_32); // 将m_64 中的值保存到arr_int64的0-7个元素 _mm512_store_epi64(arr_int64, m_64); // 将m_64 中的值保存到arr_int64的8-15个元素中 _mm512_store_epi64(arr_int64 + 8, m_64); &#125; // 使用_mm_malloc分配的内存需要_mm_free来释放 _mm_free(arr_int32); _mm_free(arr_int64);&#125; 向量化函数(Intrinsics)这里主要记录一些编译器提供的向量化函数, 完整的函数集可以在这里或者这里查询 算术运算MIC中提供了加,减, 乘 三种算术运算函数, 这里以32位整型的加法为例:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;immintrin.h&gt;void mic_add() &#123; uint32_t *arr_a, *arr_b, *arr_c; int i = 0, n = 16; arr_a = _mm_malloc(sizeof(uint32_t) * n, 64); arr_b = _mm_malloc(sizeof(uint32_t) * n, 64); arr_c = _mm_malloc(sizeof(uint32_t) * n, 64); for(i = 0; i &lt; n; i++) &#123; arr_a[i] = i; arr_b[i] = n + i; &#125;#pragma offload target(mic) in(arr_a:length(n)) in(arr_b:length(n)) out(arr_c:length(n)) &#123; __m512i m_a, m_b, m_c; m_a = _mm512_load_epi32(arr_a); m_b = _mm512_load_epi32(arr_b); m_c = _mm512_add_epi32(m_a, m_b); // 减法 //m_c = _mm512_sub_epi32(m_a, m_b); // 乘法 _mm512_mullo_epi32 保留乘法结果的低32位, _mm512_mulhi_epi32保存结果的高32位 // m_c = _mm512_mullo_epi32(m_a, m_b); _mm512_store_epi32(arr_c, m_c); &#125; for(i = 0; i &lt; n; i++) &#123; printf("arr_a[%2d] is: %2d \t arr_b[%2d] is: %2d \t arr_c[%2d] is : %2d\n", i, arr_a[i], i, arr_b[i], i, arr_c[i]); &#125; _mm_free(arr_a); _mm_free(arr_b); _mm_free(arr_c);&#125;int main() &#123; mic_add();&#125; 输出结果为:12345678910111213141516arr_a[ 0] is: 0 arr_b[ 0] is: 16 arr_c[ 0] is : 16arr_a[ 1] is: 1 arr_b[ 1] is: 17 arr_c[ 1] is : 18arr_a[ 2] is: 2 arr_b[ 2] is: 18 arr_c[ 2] is : 20arr_a[ 3] is: 3 arr_b[ 3] is: 19 arr_c[ 3] is : 22arr_a[ 4] is: 4 arr_b[ 4] is: 20 arr_c[ 4] is : 24arr_a[ 5] is: 5 arr_b[ 5] is: 21 arr_c[ 5] is : 26arr_a[ 6] is: 6 arr_b[ 6] is: 22 arr_c[ 6] is : 28arr_a[ 7] is: 7 arr_b[ 7] is: 23 arr_c[ 7] is : 30arr_a[ 8] is: 8 arr_b[ 8] is: 24 arr_c[ 8] is : 32arr_a[ 9] is: 9 arr_b[ 9] is: 25 arr_c[ 9] is : 34arr_a[10] is: 10 arr_b[10] is: 26 arr_c[10] is : 36arr_a[11] is: 11 arr_b[11] is: 27 arr_c[11] is : 38arr_a[12] is: 12 arr_b[12] is: 28 arr_c[12] is : 40arr_a[13] is: 13 arr_b[13] is: 29 arr_c[13] is : 42arr_a[14] is: 14 arr_b[14] is: 30 arr_c[14] is : 44arr_a[15] is: 15 arr_b[15] is: 31 arr_c[15] is : 46 With MaskMIC提供的向量函数一般有两种形式12345// Without Maskextern _m512i __cdecl _mm512_add_epi32(_m512i v2, _m512i v3);// With Maskextern _m512i __cdecl _mm512_mask_add_epi32(_m512i v1_old, __mmask16 k1, _m512i v2, _m512i v3); 一种是带Mask的, 一种是不带Mask的. 带Mask的多了两个参数: v1_old和k1, 其中k1是__mmask16类型的数据, 在上面我们知道__mmask类型就是unsigned short类型, 长度为16位. 关于带mask函数的解释: 将v1的16位分别对应到_m512i的16个整型上, 如果k1某个位是1, 则将v2和v3中与该位对应的整型相加, 作为结果值, 如果k1某个位为0, 就使用v1_old向量中对应位的整型作为结果值. 例如如果k1的第一位为1, 那么就将v2的第一个整数和v3的第一个整数相加, 作为结果向量的第一个整型的值. 如果k1的第一位是0, 就将v1_old向量中的第一个整型的值作为结果向量中第一个整型的值. 好吧, 还是看个例子吧.123456789101112131415161718192021222324252627282930313233343536void mic_mask_add() &#123; uint32_t *arr_a, *arr_b, *arr_c, *arr_old; int i = 0, n = 16; arr_a = _mm_malloc(sizeof(uint32_t) * n, 64); arr_b = _mm_malloc(sizeof(uint32_t) * n, 64); arr_c = _mm_malloc(sizeof(uint32_t) * n, 64); arr_old = _mm_malloc(sizeof(uint32_t) * n, 64); for(i = 0; i &lt; n; i++) &#123; arr_a[i] = i; arr_b[i] = n + i; arr_old[i] = 10000; &#125;#pragma offload target(mic) in(arr_a:length(n)) in(arr_b:length(n)) in(arr_old:length(n)) out(arr_c:length(n)) &#123; __m512i m_a, m_b, m_c, m_old; // 11换成二进制就是0000000000001011 __mmask16 k1 = 11; m_a = _mm512_load_epi32(arr_a); m_b = _mm512_load_epi32(arr_b); m_old = _mm512_load_epi32(arr_old); // 根据k1的值只有1,2,4位为1 所以m_c中只有第1,2,4个元素为m_a 和m_b中1,2,4个元素的和 剩余元素使用arr_old对应元素的值 m_c = _mm512_mask_add_epi32(m_old, k1, m_a, m_b); _mm512_store_epi32(arr_c, m_c); &#125; for(i = 0; i &lt; n; i++) &#123; printf("arr_a[%2d] is: %2d \t arr_b[%2d] is: %2d \t arr_old[%2d] is: %d \t arr_c[%2d] is : %2d\n", i, arr_a[i], i, arr_b[i], i, arr_old[i], i, arr_c[i]); &#125; _mm_free(arr_a); _mm_free(arr_b); _mm_free(arr_c); _mm_free(arr_old);&#125; 运行结果为:12345678910111213141516arr_a[ 0] is: 0 arr_b[ 0] is: 16 arr_old[ 0] is: 10000 arr_c[ 0] is : 16arr_a[ 1] is: 1 arr_b[ 1] is: 17 arr_old[ 1] is: 10000 arr_c[ 1] is : 18arr_a[ 2] is: 2 arr_b[ 2] is: 18 arr_old[ 2] is: 10000 arr_c[ 2] is : 10000arr_a[ 3] is: 3 arr_b[ 3] is: 19 arr_old[ 3] is: 10000 arr_c[ 3] is : 22arr_a[ 4] is: 4 arr_b[ 4] is: 20 arr_old[ 4] is: 10000 arr_c[ 4] is : 10000arr_a[ 5] is: 5 arr_b[ 5] is: 21 arr_old[ 5] is: 10000 arr_c[ 5] is : 10000arr_a[ 6] is: 6 arr_b[ 6] is: 22 arr_old[ 6] is: 10000 arr_c[ 6] is : 10000arr_a[ 7] is: 7 arr_b[ 7] is: 23 arr_old[ 7] is: 10000 arr_c[ 7] is : 10000arr_a[ 8] is: 8 arr_b[ 8] is: 24 arr_old[ 8] is: 10000 arr_c[ 8] is : 10000arr_a[ 9] is: 9 arr_b[ 9] is: 25 arr_old[ 9] is: 10000 arr_c[ 9] is : 10000arr_a[10] is: 10 arr_b[10] is: 26 arr_old[10] is: 10000 arr_c[10] is : 10000arr_a[11] is: 11 arr_b[11] is: 27 arr_old[11] is: 10000 arr_c[11] is : 10000arr_a[12] is: 12 arr_b[12] is: 28 arr_old[12] is: 10000 arr_c[12] is : 10000arr_a[13] is: 13 arr_b[13] is: 29 arr_old[13] is: 10000 arr_c[13] is : 10000arr_a[14] is: 14 arr_b[14] is: 30 arr_old[14] is: 10000 arr_c[14] is : 10000arr_a[15] is: 15 arr_b[15] is: 31 arr_old[15] is: 10000 arr_c[15] is : 10000 Bitwise运算MIC中提供了3中Bitwise运算函数- and or xor, 其中取反元素可以通过与1异或来实现, 下面是and操作的一个例子1234567891011121314151617181920212223242526272829303132333435363738394041void mic_and() &#123; uint32_t *arr_a, *arr_b, *arr_c; int i = 0, n = 16; arr_a = _mm_malloc(sizeof(uint32_t) * n, 64); arr_b = _mm_malloc(sizeof(uint32_t) * n, 64); arr_c = _mm_malloc(sizeof(uint32_t) * n, 64); for(i = 0; i &lt; n; i++) &#123; arr_a[i] = i ; arr_b[i] = n + i; &#125;#pragma offload target(mic) in(arr_a:length(n)) in(arr_b:length(n)) out(arr_c:length(n)) &#123; __m512i m_a, m_b, m_c; m_a = _mm512_load_epi32(arr_a); m_b = _mm512_load_epi32(arr_b); m_c = _mm512_and_epi32(m_a, m_b); // or // m_c = _mm512_or_epi32(m_a, m_b); // xor // m_c = _mm512_xor_epi32(m_a, m_b); _mm512_store_epi32(arr_c, m_c); &#125; for(i = 0; i &lt; n; i++) &#123; print_binary (arr_a[i], 8); printf( " &amp; "); print_binary(arr_b[i], 8); printf (" = "); print_binary(arr_c[i], 8); printf("\n"); &#125; _mm_free(arr_a); _mm_free(arr_b); _mm_free(arr_c);&#125; 其中print_binary是一个打印二进制的函数, 这里只打印了后8位12345678910111213141516171819202122// 打印二进制 void print_binary(uint64_t t, int bit_len) &#123;trueshort buffer[bit_len];trueint i;truefor(i = 0; i &lt; bit_len; i++) &#123;truetruebuffer[i] = 0;true&#125;truefor (i = 0; i &lt; bit_len; i++) &#123;truetrueif (t == 0)truetruetruebreak;truetrueif (t % 2 == 0) &#123;truetruetruebuffer[i] = 0;truetrue&#125; else &#123;truetruetruebuffer[i] = 1;truetrue&#125;truetruet = t / 2;true&#125;truefor (i = bit_len - 1; i &gt;= 0; i--) &#123;truetrueprintf("%hd", buffer[i]);true&#125;&#125; 下面是一个取反的示例123456789101112131415161718192021222324252627282930313233void mic_not() &#123; uint32_t *arr_a, *arr_c; int i = 0, n = 16; arr_a = _mm_malloc(sizeof(uint32_t) * n, 64); arr_c = _mm_malloc(sizeof(uint32_t) * n, 64); for(i = 0; i &lt; n; i++) &#123; arr_a[i] = i ; &#125;#pragma offload target(mic) in(arr_a:length(n)) out(arr_c:length(n)) &#123; __m512i m_a, m_b, m_c; int32_t all_one = 0xffffffff; // _mm512_set1_epi32 : 将向量中的16个整型都设为all_one m_b = _mm512_set1_epi32(all_one); m_a = _mm512_load_epi32(arr_a); m_c = _mm512_xor_epi32(m_a, m_b); _mm512_store_epi32(arr_c, m_c); &#125; for(i = 0; i &lt; n; i++) &#123; printf("~ "); print_binary (arr_a[i], 8); printf( " = "); print_binary(arr_c[i], 8); printf("\n"); &#125; _mm_free(arr_a); _mm_free(arr_c);&#125; 下面是运行结果12345678910111213141516~ 00000000 = 11111111~ 00000001 = 11111110~ 00000010 = 11111101~ 00000011 = 11111100~ 00000100 = 11111011~ 00000101 = 11111010~ 00000110 = 11111001~ 00000111 = 11111000~ 00001000 = 11110111~ 00001001 = 11110110~ 00001010 = 11110101~ 00001011 = 11110100~ 00001100 = 11110011~ 00001101 = 11110010~ 00001110 = 11110001~ 00001111 = 11110000 移位操作移位操作分为算术移位和逻辑移位, 逻辑左移和算术左移的规则是一样的, 所以两者共用同一个左移函数, 而逻辑右移和算术右移不同, 逻辑右移是一直补0, 而算术右移要看符号位, 符号位为0则补0, 符号位为1, 则补1. 同时移位操作有两种形式, 一种给定一个常数, 向量中的每个元素都移该常数位, 一种是给定一个向量, 向量中的每个元素移给定向量中对应数值的位. 好吧下面还是看例子吧.左移: 给定一个常数1234567891011121314151617181920212223242526272829void mic_lshift() &#123; uint32_t *arr_a, *arr_c; int i = 0, n = 16; arr_a = _mm_malloc(sizeof(uint32_t) * n, 64); arr_c = _mm_malloc(sizeof(uint32_t) * n, 64); for(i = 0; i &lt; n; i++) &#123; arr_a[i] = i ; &#125;#pragma offload target(mic) in(arr_a:length(n)) out(arr_c:length(n)) &#123; __m512i m_a, m_c; m_a = _mm512_load_epi32(arr_a); // 向量中的每个整型都左移一位 ,逻辑右移 _mm512_srli_epi32 m_c = _mm512_slli_epi32 (m_a, 1); _mm512_store_epi32(arr_c, m_c); &#125; for(i = 0; i &lt; n; i++) &#123; print_binary (arr_a[i], 8); printf( " \t "); print_binary(arr_c[i], 8); printf("\n"); &#125; _mm_free(arr_a); _mm_free(arr_c);&#125; 左移:给定一个向量123456789101112131415161718192021222324252627282930313233void mic_lshift_v() &#123; uint32_t *arr_a, *arr_c; int i = 0, n = 16; arr_a = _mm_malloc(sizeof(uint32_t) * n, 64); arr_c = _mm_malloc(sizeof(uint32_t) * n, 64); for(i = 0; i &lt; n; i++) &#123; arr_a[i] = i+1 ; &#125;#pragma offload target(mic) in(arr_a:length(n)) out(arr_c:length(n)) &#123; __m512i m_a, m_b, m_c; // _mm512_set_epi32(int e15, int e14, int e13, int e12, int e11, int e10, int e9, int e8, int e7, int e6, int e5, int e4, int e3, int e2, int e1, int e0); // _mm512_set_epi32 按从高到低的顺序, 第一个参数设为向量中第16个整型的值, 最后一个参数设为第1个整型的值 m_b = _mm512_set_epi32(1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4); m_a = _mm512_load_epi32(arr_a); // 逻辑右移 _mm512_srlv_epi32 m_c = _mm512_sllv_epi32 (m_a, m_b); _mm512_store_epi32(arr_c, m_c); &#125; for(i = 0; i &lt; n; i++) &#123; print_binary (arr_a[i], 8); printf( " \t "); print_binary(arr_c[i], 8); printf("\n"); &#125; _mm_free(arr_a); _mm_free(arr_c);&#125; 执行结果为:1234567891011121314151600000001 0001000000000010 0001000000000011 0000110000000100 0000100000000101 0101000000000110 0011000000000111 0001110000001000 0001000000001001 1001000000001010 0101000000001011 0010110000001100 0001100000001101 1101000000001110 0111000000001111 0011110000010000 00100000 算术右移12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void mic_arshift() &#123; uint32_t *arr_a, *arr_b, *arr_c, *arr_d; int i = 0, n = 16; arr_a = _mm_malloc(sizeof(uint32_t) * n, 64); arr_b = _mm_malloc(sizeof(uint32_t) * n, 64); arr_c = _mm_malloc(sizeof(uint32_t) * n, 64); arr_d = _mm_malloc(sizeof(uint32_t) * n, 64); uint32_t high_one = 1 &lt;&lt; 31; for(i = 0; i &lt; n; i++) &#123; arr_a[i] = i+1; arr_b[i] = high_one | (i + 1); &#125;#pragma offload target(mic) in(arr_a:length(n)) in(arr_b:length(n)) out(arr_c:length(n)) out(arr_d:length(n)) &#123; __m512i m_a,m_b, m_c, m_d; m_a = _mm512_load_epi32(arr_a); // 算术右移, 符号为0, 补0；符号位为1, 补1 m_c = _mm512_srai_epi32 (m_a, 2); _mm512_store_epi32(arr_c, m_c); m_b = _mm512_load_epi32(arr_b); m_d = _mm512_srai_epi32(m_b, 2); _mm512_store_epi32(arr_d, m_d); &#125; printf("符号位为0: \n"); for(i = 0; i &lt; n; i++) &#123; print_binary (arr_a[i],32); printf( " \t "); print_binary(arr_c[i], 32); printf("\n"); &#125; printf("符号位为1: \n"); for(i = 0; i &lt; n; i++) &#123; print_binary (arr_b[i],32); printf( " \t "); print_binary(arr_d[i], 32); printf("\n"); &#125; _mm_free(arr_a); _mm_free(arr_b); _mm_free(arr_c); _mm_free(arr_d);&#125; 执行结果为:12345678910111213141516171819202122232425262728293031323334符号位为0: 00000000000000000000000000000001 0000000000000000000000000000000000000000000000000000000000000010 0000000000000000000000000000000000000000000000000000000000000011 0000000000000000000000000000000000000000000000000000000000000100 0000000000000000000000000000000100000000000000000000000000000101 0000000000000000000000000000000100000000000000000000000000000110 0000000000000000000000000000000100000000000000000000000000000111 0000000000000000000000000000000100000000000000000000000000001000 0000000000000000000000000000001000000000000000000000000000001001 0000000000000000000000000000001000000000000000000000000000001010 0000000000000000000000000000001000000000000000000000000000001011 0000000000000000000000000000001000000000000000000000000000001100 0000000000000000000000000000001100000000000000000000000000001101 0000000000000000000000000000001100000000000000000000000000001110 0000000000000000000000000000001100000000000000000000000000001111 0000000000000000000000000000001100000000000000000000000000010000 00000000000000000000000000000100符号位为1: 10000000000000000000000000000001 1110000000000000000000000000000010000000000000000000000000000010 1110000000000000000000000000000010000000000000000000000000000011 1110000000000000000000000000000010000000000000000000000000000100 1110000000000000000000000000000110000000000000000000000000000101 1110000000000000000000000000000110000000000000000000000000000110 1110000000000000000000000000000110000000000000000000000000000111 1110000000000000000000000000000110000000000000000000000000001000 1110000000000000000000000000001010000000000000000000000000001001 1110000000000000000000000000001010000000000000000000000000001010 1110000000000000000000000000001010000000000000000000000000001011 1110000000000000000000000000001010000000000000000000000000001100 1110000000000000000000000000001110000000000000000000000000001101 1110000000000000000000000000001110000000000000000000000000001110 1110000000000000000000000000001110000000000000000000000000001111 1110000000000000000000000000001110000000000000000000000000010000 11100000000000000000000000000100 _mm512_alignr_epi32函数原型为:1extern __m512i __cdecl _mm512_alignr_epi32(__m512i v2, __m512i v3, const int count); 该函数的作用就是将v2和v3拼接起来, v2在前, v3在后, 然后循环左移count个元素, 然后取最右侧的16个元素, 下面看个例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void mic_alignr() &#123; uint32_t *arr_a, *arr_b, *arr_c, *arr_d; int i = 0, n = 16; arr_a = _mm_malloc(sizeof(uint32_t) * n, 64); arr_b = _mm_malloc(sizeof(uint32_t) * n, 64); arr_c = _mm_malloc(sizeof(uint32_t) * n, 64); arr_d = _mm_malloc(sizeof(uint32_t) * n, 64); for(i = 0; i &lt; n; i++) &#123; arr_a[i] = i+1; arr_b[i] = n + i + 1; &#125;#pragma offload target(mic) in(arr_a:length(n)) in(arr_b:length(n)) out(arr_c:length(n)) out(arr_d:length(n)) &#123; __m512i m_a,m_b, m_c, m_d; m_a = _mm512_load_epi32(arr_a); m_b = _mm512_load_epi32(arr_b); // 算术右移, 符号为0, 补0；符号位为1, 补1 m_c = _mm512_alignr_epi32 (m_a, m_b, 3); _mm512_store_epi32(arr_c, m_c); m_d = _mm512_alignr_epi32(m_a, m_b, 8); _mm512_store_epi32(arr_d, m_d); &#125; printf("arr_a: "); for(i = 0; i &lt; n; i++) &#123; printf("%2u ", arr_a[i]); &#125; printf(" \narr_b: "); for(i = 0; i &lt; n; i++) &#123; printf("%2u ", arr_b[i]); &#125; printf("\n\n"); printf("count = 3 arr_c: "); for(i = 0; i &lt; n; i++) &#123; printf("%2u ", arr_c[i]); &#125; printf("\n"); printf("count = 8 arr_c: "); for(i = 0; i &lt; n; i++) &#123; printf("%2u ", arr_d[i]); &#125; printf("\n"); _mm_free(arr_a); _mm_free(arr_b); _mm_free(arr_c); _mm_free(arr_d);&#125; 执行结果为:12345arr_a: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 arr_b: 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 count = 3 arr_c: 20 21 22 23 24 25 26 27 28 29 30 31 32 1 2 3 count = 8 arr_c: 25 26 27 28 29 30 31 32 1 2 3 4 5 6 7 8]]></content>
      <categories>
        <category>MIC</category>
      </categories>
      <tags>
        <tag>MIC</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【软件】Intellij IDEA 导入maven web项目并部署到Tomcat]]></title>
    <url>%2F2015%2F12%2F26%2F%E3%80%90%E8%BD%AF%E4%BB%B6%E3%80%91Intellij-IDEA-14-%E5%AF%BC%E5%85%A5maven-web%E9%A1%B9%E7%9B%AE%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0Tomcat%2F</url>
    <content type="text"><![CDATA[前言本文中所使用的IDEA版本为14.1.1, 所使用测试项目为sping mvc的一个最简单的示例, 可以在这里下载示例代码 导入项目 File -&gt; New -&gt; Project from Existing Sources… 选择maven项目所在的文件夹 Import project from external model -&gt; Maven 使用默认设置, 然后一直Next, 直到项目创建成功. 配置项目添加Spring支持我们打开applicationContext.xml 会提示 Create Spring facet, 我们点击它, 增加对Spring 的支持 点击右侧的+ 号选择Spring 的配置文件 添加Web支持 File -&gt; Project Structure… -&gt; Modules -&gt; 选中项目(不是Spring) , 然后点击上方的+号 选择 Web 然后我们会看到在下方会提示&#39;Web&#39; Facet resources are not included in an artifact, 我们点击Create Artifact新建一个 然后我们会跳转到Artifacts选项中, 注意右侧Available Elements , 这些是Spring的依赖包, 我们在这些依赖包上双击, 就可以添加到WEB-INF的lib文件夹中, 这样部署到Tomcat上程序才可以正常运行. 下图是点击之后的效果, 然后点击OK即可 配置Source文件夹在本项目中, src是默认的source文件夹, 造成的结果就是包名要以 main.java开头(不知道是没配置好, 还是默认这样), 为了解决这个问题, 我们可以手动更改一下默认的source文件夹 File -&gt; Project Structure… -&gt; Modules -&gt; 点击项目名称, 在Sources选项卡中我们可以看到项目的结构, 在右侧有当前的Sources Folders是哪些文件夹, 我们把点击src右侧的X号, 将其从Sources Folders中删除, 然后在左侧面板中, 展开src, 右击java文件夹, 选择 Sources 选项 修改完成后如下图所示, 然后点击 OK 即可 配置Tomcat Run -&gt; Edit Configurations… 点击+号, 添加Tomcat 如果之前没有配置过Tomcat, 那么需要配置一下Tomcat的路径, 点击 Application server 右边的 Configure... 切换到 Deployment 选项卡, 点击 + 号, 选择 Artifact... 选择完后, 应该为下图的样子, 在 Application context 里可以更改项目的url路径 运行程序到了这里我们终于配置完了, 下面就可以运行程序了, 在面板下方有个Application Server 选项卡, 如果没有默认打开, 我们点击它即可, 然后点击 run 按钮, 就可以运行我们的程序了. 下图是运行结果]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C】文件操作]]></title>
    <url>%2F2015%2F12%2F15%2F%E3%80%90C%E3%80%91%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[打开文件fopen我们可以使用fopen()创建一个新的或者打开一个文件, 文件信息会保存在一个FILE类型的指针中, 该函数的原型为:1FILE *fopen( const char * filename, const char * mode ); filename是文件名, mode是打开模式, 可选值如下: r - 以只读方式打开一个文件, 该文件必须存在 w - 以只写方式打开一个文件, 文件不存在会创建新的文件, 文件存在会首先清空原有内容 a - 以追加的方式写文件, 文件不存在会创建新的文件, 文件存在从文件尾开始写文件 r+ - 以读写方式打开文件, 文件不存在不会创建新的文件 w+ - 以读写方式打开文件, 文件不存在会创建新的文件, 文件存在会首先清空原有内容 a+ - 以追加方式读写文件, 文件不存在会创建新的文件, 文件存在从文件尾开始写文件 如果是操作二进制文件, 那么需要在mode里加上b, 如下所示:1"rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b", "ab+", "a+b" 文件成功打开会返回一个’FILE’类型的指针, 如果打开失败, 会返回一个空指针, 并把错误代码存在errno中. r+ 和 w+的区别看下面的代码123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;void test() &#123; FILE *fp; fp = fopen("test.txt", "w"); fprintf(fp, "this is a test...\n"); fprintf(fp, "this is a test...\n"); fprintf(fp, "this is a test...\n"); fclose(fp);&#125;void test_w() &#123; FILE *fp; fp = fopen("test.txt", "w+"); fprintf(fp, "hello"); fclose(fp);&#125;void test_r() &#123; FILE *fp; fp = fopen("test.txt", "r+"); fprintf(fp, "hello"); fclose(fp);&#125;int main() &#123; test(); test_w(); //test(); //test_r();&#125; 首先运行test, 然后运行test_w, test.txt中的结果如下:1hello 然后运行test和test_r, test.txt中的结果如下:123hellois a test...this is a test...this is a test... 由上面我们可以看到r+在写时并不清空已有的内容, 但是会从文件开头开始写, 写入的内容会覆盖已有内容. r, w, a, b, + 的解释mode一般由上面5个字符组成, 有些可能还会使用t, 下面是该它们的含义 r - read, 读 w - write, 写 a - append, 追加 t - text, 文本文件, 可省略不写 b - binary, 二进制文件 + - 读和写 新的修饰符 x在C2011中, 添加一个新的修饰符x, 和w 一起使用, 如下1"wx", "wbx", "w+x" or "w+bx"/"wb+x" 当文件存在时, x会强制使文件访问出错, 而不是清空文件内容. 关闭文件我们可以使用fclose来关闭文件, 函数原型为:1int fclose( FILE *fp ); 如果fclose执行成功, 会返回0, 如果执行出错则会返回EOF(在stdio.h中定义). 当fclose关闭文件时, 会首先将输出流(output) buffer 中的内容写入到文件, 将输入流(input) buffer 中的内容丢弃, 然后关闭文件, 释放其对应的内存. 写文件在C中有多种方式可以读写文件, 下面将具体介绍它们 fputc将一个字符写入到fp所指向的输出流中(不只是文件输出流), 写入成功会返回写入的字符, 写入失败会返回EOF, 函数原型为1int fputc( int c, FILE *fp ); 下面是一个示例:1234567891011void test_fputc() &#123; FILE *fp; fp = fopen("test.txt", "w+"); char c; int num; for(c = 'A'; c &lt;= 'Z'; c++) &#123; num = fputc(c, fp); printf("num is %d\n", num); &#125; fclose(fp);&#125; test.txt中的内容为1ABCDEFGHIJKLMNOPQRSTUVWXYZ 另外putchar就是以fputc为基础实现的(额, 这个和实现有关, 这里暂且这么认为)1#define putchar(__c) fputc(__c, stdout) putc和fputc的功能一样, 都是将一个字符写入到对应的输出流中, 并且两者的原型是相同的:12extern int fputc(int __c, FILE *__stream);extern int putc(int __c, FILE *__stream); 但是在实现的时候, putc是以宏定义的方式实现的, 而fputc则是以函数的方式实现的(f表示function)1#define putc(__c, __stream) fputc(__c, __stream) 关于两者的区别可以参考下面两篇文章fputc vs putc in CC语言中fgetc、fputc和getc、putc的区别是什么大概的意思就是使用putc在一般情况下会快些, 但是可能会出现一些问题, 所以建议使用fputc. fputsfputs从指定的地址(str)开始复制, 直到遇到标志结束的null字符\0, 同时\0不会被复制到输出流中. 如果函数执行成功会返回一个非负整数, 否则返回EOF, 该函数的原型为:1int fputs ( const char * str, FILE * stream ); 下面是一个使用示例123456789101112void test_fputs() &#123; FILE *fp; fp = fopen("test.txt", "w+"); char *c = "this is a test...\n"; char c1[6] = &#123;'A', 'B', 'C', '\0', 'E', 'F'&#125;; int num; num = fputs(c, fp); printf("num is %d\n", num); num = fputs(c1, fp); printf("num is %d\n", num); fclose(fp); &#125; 执行完test_fputs, test.txt中的内容如下所示, 注意c1只写入了ABC12this is a test...ABC 和fputs相关的一个函数为puts, 其函数原型为:1extern int puts(const char *__str); puts不可指定输出流, 默认会输出到标准输出流(stdout), 除此之外puts在输出完内容之后会在内容后面追加上换行符(newline character). fprintffprintf用来将格式化数据输出到输出流, 和printf用法相同, 下面是函数原型1int fprintf ( FILE * stream, const char * format, ... ); 下面是一个使用示例1234567891011void test_fprintf() &#123; FILE *fp; fp = fopen("test.txt", "w+"); int num; int i = 100; num = fprintf(fp, "this is a test...\n"); printf("num is %d\n", num); num = fprintf(fp, "i is %d and address of i is %p", i, &amp;i); printf("num is %d\n", num); fclose(fp); &#125; 执行test_fprintf后, test.txt中的内容为:12this is a test...i is 100 and address of i is 0x7ffd32721f90 关于格式化形式可以参考printf, 或者下面的链接http://www.cplusplus.com/reference/cstdio/fprintf/ 读文件fgetcfgetc一次读取一个字符, 同时将文件指针往后移一个字符, 如果读取成功会返回读取的字符, 出现错误会返回EOF. 当读到文件末尾时, 也会返回EOF, 并且在输出流中设置文件结束标志(end-of-file indicator). 下面是该函数的原型:1int fgetc ( FILE * stream ); 下面是一个使用示例, 其中test.txt中的内容为this is a test...123456789101112void test_fgetc() &#123; FILE *fp; fp = fopen("test.txt", "r"); int i, n = 20; char c; for(i = 0; i &lt; 20; i++) &#123; c = fgetc(fp); printf("%c",c); &#125; printf("\n"); fclose(fp); &#125; 输出结果为:1this is a test...��� 对应的ascii码值为:1116 104 105 115 32 105 115 32 97 32 116 101 115 116 46 46 46 -1 -1 -1 当读到文件末尾时返回EOF(即-1), 而ascii码中没有-1的对应值, 所以会显示乱码.和fgetc相关的函数有getchar和getc, 它们的关系和fputc与putchar, putc的关系一样, 下面是getchar和getc的实现12#define getchar() fgetc(stdin)#define getc(__stream) fgetc(__stream) fgets该函数的原型为:1char * fgets ( char * str, int num, FILE * stream ); fgets从stream中读取内容到str, 当满足下面任意一个条件时完成读取操作: 读取了num-1个字符 读到了换行符(newline character) 读到了文件结尾(end-of-file) 注意第二条, 换行符也会被读到str中. 读取完成后会在str后面追加上 终止null字符 (即\0), 这也是第一条为什么只读 num-1 个字符的原因. 函数返回值是一个指向str的指针.下面是一个使用示例,1234567891011121314void test_fgets() &#123; FILE *fp; fp = fopen("test.txt", "r"); char c[50]; fgets(c, 5, fp); printf("c is '%s'\n", c); printf("c length is %ld\n", strlen(c)); // 重置文件指针到文件开头 rewind(fp); fgets(c, 20, fp); printf("c is '%s'\n", c); printf("c length is %ld\n", strlen(c)); fclose(fp); &#125; 其中test.txt中内容为:123this is a test...this is a test...this is a test... 执行结果为:12345c is 'this'c length is 4c is 'this is a test...'c length is 18 gets从标准输入流(stdin)里读取数据, 以换行符(回车)作为读取完成的标志, 下面是该函数的原型1char * gets ( char * str ); 下面是一个使用示例:123456void test_gets() &#123; char string [256]; printf ("Insert your full address: "); gets (string); // warning: unsafe (see fgets instead) printf ("Your address is: %s\n",string);&#125; 在编译时会有警告12file.c:102:5: warning: ‘gets’ is deprecated (declared at /usr/include/stdio.h:638) [-Wdeprecated-declarations] gets (string); // warning: unsafe (see fgets instead) 即gets函数已过时deprecated, 不建议使用, 而应使用fgets代替 fscanffscanf以格式化的形式读入数据, 函数原型如下:1int fscanf ( FILE * stream, const char * format, ... ); fscanf以空格和换行符作为读入的结束字符, 同时在fscanf读入时会忽略第一个非空字符前面的空白符(空格,换行,tab), 下面是一个测试示例12345678910111213void test_scanf() &#123; FILE *fp; fp = fopen("test.txt", "r"); int num[3], i; for(i = 0; i &lt; 3; i++) &#123; num[i] = 0; &#125; fscanf(fp, "%d%d", num, num+1); for(i = 0; i &lt; 3; i++) &#123; printf("num[%d] is %d\n", i, num[i]); &#125; fclose(fp); &#125; 其中test.txt中的内容为:1210 55dddd 程序执行结果为:123num[0] is 10num[1] is 55num[2] is 0 在test.txt中 10 前面有个空行, 55 前面有多个空格, 并且后面有 dddd等非数字字符, fscanf在读入时会忽略掉前面的空白符, 并且执行到不匹配的地方就不再往后读入. 参考文章 http://www.tutorialspoint.com/cprogramming/c_file_io.htmhttp://www.cplusplus.com/reference/cstdio/http://www.2cto.com/kf/201207/143344.html]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【MIC学习笔记】CPU和MIC异步计算及数据传输]]></title>
    <url>%2F2015%2F12%2F09%2F%E3%80%90MIC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91CPU%E5%92%8CMIC%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97%E5%8F%8A%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[异步计算当使用#pragma offload target(mic) 方式分载时, cpu会等待offload的代码块执行完再继续往下执行, 如果不希望等待offload, 我们可以使用cpu和mic异步计算的方式. 具体方法为在offload的时候添加一个信号量, 如下面的形式:123456char signal_var;#pragma offload target(mic:0)signal(&amp;signal_var)&#123; ... &#125; 此时offload 的代码就会异步执行, 需要注意的一点是要制定mic的编号(如上面的target(mic:0)), 如果需要等待offload执行完后在往下执行, 可以使用offload_wait, 如下面的形式 1#pragma offload_wait target(mic:0) wait(&amp;signal_var) 当代码执行到这一句时如果offload没有执行完就会处于等待状态, 直到offload执行完再往下执行. 下面是一个完整的示例, test1是异步执行, test2是同步执行.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;offload.h&gt;void test1() &#123; char signal_var; //需要指定mic卡的编号#pragma offload target(mic:0)signal(&amp;signal_var) &#123; long long i; long long t; for(i = 0; i &lt; 1000000000; i++) &#123; t += i; t += i * 2; t += i * 3; t +=i %2; t += i %3; &#125; printf("t is %lld\n", t); &#125; int j = 0; for(j = 0; j &lt; 100000; j++) &#123;&#125; printf("j is %d\n", j);#pragma offload_wait target(mic:0) wait(&amp;signal_var) printf("after wait\n");&#125;void test2() &#123;#pragma offload target(mic:0) &#123; long long i; long long t; for(i = 0; i &lt; 1000000000; i++) &#123; t += i; t += i * 2; t += i * 3; t +=i %2; t += i %3; &#125; printf("t is %lld\n", t); &#125; int j = 0; for(j = 0; j &lt; 100000; j++) &#123;&#125; printf("j is %d\n", j); printf("after wait\n");&#125;int main() &#123; test1(); //test2();&#125; 异步传输如果数据量很大, 那么cpu和mic之间的数据传输也要花费一些时间, 如果不希望等待数据传输, 那么可以使用offload_transfer进行异步数据传输, 如下面的方式12#pragma offload_transfer target(mic:0) signal(f1) \ in (f1:length(n) alloc_if(1) free_if(0)) 如果后面的offload需要使用本次offload上传的数据, 那么可以使用wait来等待数据传输完毕再执行1#pragma offload target(mic:0) wait(f1) 下面是一个完整的示例:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define __ONMIC__ __attribute__((target(mic)))__ONMIC__ void add_inputs(int n, float *f1, float *f2)&#123; int i; for( i =0; i &lt; n; i++) &#123; f2[i] += f1[i]; &#125;&#125;void display_vals( int id, int n, float *f2) &#123; printf("\nResults after Offload #%d:\n",id); int i; for ( i = 0; i &lt; n; i++) &#123; printf("f2[%d] is %f\n", i, f2[i] ); &#125; printf("====================\n");&#125;void test() &#123; float *f1 , *f2; int n = 10000; int i, j; f1 = (float*) malloc(sizeof(float) * n); f2 = (float*)malloc(sizeof(float) * n); for(i = 0; i &lt; n; i++) &#123; f1[i] = i+1; f2[i] = 0.0; &#125; // 这里只上传数据#pragma offload_transfer target(mic:0) signal(f1) \ in (f1:length(n) alloc_if(1) free_if(0))\ in (f2:length(n) alloc_if(1) free_if(0)) // wait(f1)等待上面的数据传输完毕, 再执行该操作#pragma offload target(mic:0) wait(f1) signal(f2) \ in(n) \ nocopy(f1:alloc_if (0) free_if(1))\ out(f2:length(n) alloc_if(0) free_if(1)) add_inputs(n, f1, f2); // 等该f2执行完#pragma offload_wait target(mic:0) wait(f2) // 如果不加wait, 就会全部打印出0 display_vals(1, 10, f2); // 多个数据异步上传#pragma offload_transfer target(mic:0) signal(f1) \ in(f1:length(n) alloc_if(1) free_if(0))#pragma offload_transfer target(mic:0) signal(f2) \ in(f2:length(n) alloc_if(1) free_if(0)) // 同时等待两个信号量#pragma offload target(mic:0) wait(f1, f2) \ in (n) \ nocopy (f1:alloc_if(0) free_if(1)) \ out (f2:length(n) alloc_if(0) free_if(1)) add_inputs(n, f1, f2); display_vals(2, 10, f2); // 异步传输和同步传输结合#pragma offload_transfer target(mic:0) signal(f2)\ in(f2:length(n) alloc_if(1) free_if(0))#pragma offload target(mic:0) wait(f2) \ in(n) \ in(f1:length(n) alloc_if(1) free_if(0))\ nocopy(f2) add_inputs(n ,f1, f2);#pragma offload_transfer target(mic:0) signal(f2) \ out(f2:length(n) alloc_if(0) free_if(1))#pragma offload_wait target(mic:0) wait(f2) display_vals(3, 10, f2); free(f1); free(f2);&#125;int main() &#123; test(); &#125;]]></content>
      <categories>
        <category>MIC</category>
      </categories>
      <tags>
        <tag>MIC</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【MIC学习笔记】共享虚拟内存模式]]></title>
    <url>%2F2015%2F12%2F09%2F%E3%80%90MIC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%85%B1%E4%BA%AB%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言使用#pragma offload target(mic) 方式将程序分载到MIC上计算是比较常用的方式, 但是这种方式只支持一维指针, 如果有较为复杂的数据结构, 比如二维指针, 树, 链表等结构则需要将这些数据结构转换为一维结构(如果可以), 否则不能将数据传到MIC上去. 为了满足复杂的数据结构, mic提供了共享虚拟内存的方式, 即将mic的内存和cpu的内存看做共享同一块虚拟内存, 在共享内存中的数据被cpu和mic共享, 不需要使用offload将数据在cpu和mic之间相互传递. 声明共享变量和函数我们可以使用_Cilk_shared来声明mic和cpu共享的变量和函数, 使用_Cilk_offload在mic端运行共享函数.123_Cilk_shared int i;_Cilk_shared void a(); 共享变量的虚拟内存地址在cpu和mic上是相同的, 并且它们的值会在cpu和mic之间同步. 下面是一个示例: 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// 声明CPU和MIC共享的变量_Cilk_shared int x = 1;// 声明CPU和MIC共享的函数_Cilk_shared void run_onmic() &#123; x = 3; printf("mic: the value of x is %d and the address of mic is %p\n", x, &amp;x); // 确认是否在mic上执行#ifdef __MIC__ printf("this is onmic\n");#endif&#125;void run_oncpu() &#123; printf("cpu: the value of x is %d and the address of mic is %p\n", x, &amp;x);&#125;int main() &#123; // 使用_Cilk_offload 代替#pragma offload target(mic) _Cilk_offload run_onmic(); run_oncpu();&#125; 指针内存管理首先说下共享指针的声明方式:1int *_Cilk_shared share_pointer; 上面是声明一个共享指针, 注意*号在_Cilk_shared的前面, 下面的两种方式都不是共享指针正确的声明方式123int _Cilk_shared *share_pointer;_Cilk_shared int *share_pointer; 共享内配的分配和释放应该使用下面的函数12345void *_Offload_shared_malloc(size_t size);void *_Offload_shared_aligned_malloc(size_t size, size_t alignment);_Offload_shared_free(void *p);_Offload_shared_aligned_free(void *p); 其中_Offload_shared_aligned_malloc 和 _Offload_shared_aligned_free 用于处理需要内存对齐时的情况. 不过好像在共享函数中可以使用malloc为共享变量分配内存, 但是不清楚是否会有什么副作用. 还要注意的一点是_Offload_shared_malloc和free , malloc和_Offload_shared_free 不能混用, 否则可能出现意想不到的结果, 下面是一个示例代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// int _Cilk_shared *p 是本地指针, 可以指向共享数据, 如果直接p = _Offload_share_malloc() 会报warning// 而使用下面的方式定义则没有问题// typedef int *fp;// _Cilk_shared fp p;// p = (fp)_Offload_shared_malloc(sizeof(int) * n);// _Offload_shared_free(p);int *_Cilk_shared share_pointer;_Cilk_shared int n = 8;// 在共享函数内, 使用malloc和free为共享变量分配和释放内存_Cilk_shared void cilk_malloc() &#123; int i; share_pointer = (int *)malloc(sizeof(int) * n); for(i = 0; i &lt; n; i++) &#123; share_pointer[i] = i; &#125; for(i = 0; i &lt; n; i++) &#123; printf("cilk_malloc: share_pointer[%d] is %d\n", i, share_pointer[i]); &#125; free(share_pointer);&#125;// 在mic上执行下面函数会报错// CARD--ERROR:1 thread:3 myoArenaFree: It is not supported to free shared memory from the MIC side!_Cilk_shared void cilk_sharedfree() &#123; int i; share_pointer = (int *)_Offload_shared_malloc(sizeof(int) * n); for(i = 0; i &lt; n; i++) &#123; share_pointer[i] = i; &#125; for(i = 0; i &lt; n; i++) &#123; printf("cilk_sharedfree: share_pointer[%d] is %d\n", i, share_pointer[i]); &#125; _Offload_shared_free(share_pointer);&#125;_Cilk_shared void cilk_pointer() &#123; int i; for(i = 0; i &lt; n; i++) &#123; share_pointer[i] = i; &#125; for(i = 0; i &lt; n; i++) &#123; printf("cilk_pointer: share_pointer[%d] is %d\n", i, share_pointer[i]); &#125;&#125;int main() &#123; //_Cilk_offload cilk_malloc(); //_Cilk_offload cilk_sharedfree(); // 下面三条语句执行时会错误 //share_pointer =(int *) malloc(sizeof(int) * n); //_Cilk_offload cilk_pointer(); //free(share_pointer); // 下面三条语句可以正常执行 share_pointer = (int *) _Offload_shared_malloc(sizeof(int) * n); _Cilk_offload cilk_pointer(); _Offload_shared_free(share_pointer); return 0;&#125; 当在mic上执行cilk_share_free时会报错误, 原因是只能在cpu端调用_Offload_shared_free函数释放内存. 二维指针示例下面是一个使用共享二维指针的一个示例1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;int **_Cilk_shared p;_Cilk_shared int n = 3, m = 3;void init_p() &#123; int index = 0, i, j; for(i = 0; i &lt; n; i++) &#123; for( j = 0; j &lt; m; j++) &#123; p[i][j] = index++; &#125; &#125;&#125;_Cilk_shared void print_p() &#123; int i, j; for(i = 0; i &lt; n; i++) &#123; for(j = 0; j &lt; n; j++) &#123; printf("print_p: p[%d][%d] is %d\n", i, j, p[i][j]); &#125; &#125;&#125;int main() &#123; int i; p = (int **) _Offload_shared_malloc(sizeof(int *) * n); for( i = 0; i &lt; n ;i++) &#123; p[i] =(int *) _Offload_shared_malloc(sizeof(int) * m); &#125; init_p(); _Cilk_offload print_p(); for(i = 0; i &lt; n; i++) &#123; _Offload_shared_free(p[i]); &#125; _Offload_shared_free(p);&#125;]]></content>
      <categories>
        <category>MIC</category>
      </categories>
      <tags>
        <tag>MIC</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【MIC学习笔记】记录几个用法]]></title>
    <url>%2F2015%2F12%2F08%2F%E3%80%90MIC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E8%AE%B0%E5%BD%95%E5%87%A0%E4%B8%AA%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[into使用into可以将一个变量的值上传到另外一个变量中, 比如in (a into(b)), 表示将CPU上变量a的值赋给MIC上的变量b, 也可以out(b into(c)) 将MIC上变量b的值传回给CPU上的变量c. 需要注意的地方是into 只能用于in或者out中, 不能用于inout或者nocopy中. 下面是使用示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;stdio.h&gt;void init_array(int* arr, int n, int start_num)&#123; int i; for(i = 0; i &lt; n; i++) &#123; arr[i] = start_num + i; &#125;&#125;void use_into() &#123; int n = 3, i; int p[n], p1[n]; init_array(p, n, 0); init_array(p1, n, n); for(i = 0; i &lt; n; i++) &#123; printf("before offload: p[%d] is %d\n", i, p[i]); &#125; for(i = 0; i &lt; n; i++) &#123; printf("before offload: p1[%d] is %d\n", i, p1[i]); &#125; printf("==============================\n"); //into 将一个变量的值上传到另外一个变量中,如下在mic上p没有值,只有p1有值, 调用out之后原先p1的值会改变#pragma offload target(mic) in(p[0:n] : into(p1[0:n])) out(p1) &#123; for(i = 0; i &lt; n; i++) &#123; printf("On Mic: p[%d] is %d\n", i, p[i]); &#125; for(i = 0; i &lt; n; i++) &#123; printf("On Mic: p1[%d] is %d\n", i, p1[i]); &#125; &#125; for(i = 0; i &lt; n; i++) &#123; printf("after offload: p[%d] is %d\n", i, p[i]); &#125; for(i = 0; i &lt; n; i++) &#123; printf("after offload: p1[%d] is %d\n", i, p1[i]); &#125; printf("==============================\n");&#125;void use_into2() &#123; int n = 4, i; int p[n], p1[n+1], p2[n-1]; init_array(p, n, 0); init_array(p1, n+1, n); init_array(p2, n-1, 2*n+1); for(i = 0; i &lt; n; i++) &#123; printf("before offload: p[%d] is %d\n", i, p[i]); &#125; for(i = 0; i &lt; n+1; i++) &#123; printf("before offload: p1[%d] is %d\n", i, p1[i]); &#125; for(i = 0; i &lt; n-1; i++) &#123; printf("before offload: p2[%d] is %d\n", i, p2[i]); &#125; printf("==============================\n"); // 当数组长度不一样时, 当length(p) &lt; length(p1)时, p1数组多余的部分会补0 // 当length(p) &gt; length(p2)时, in的时候需要注意p的长度不可大于p2的长度#pragma offload target(mic) in(p[0:n]:into(p1[0:n+1])) in(p[0:n-1]:into(p2[0:n-1])) out(p1) out(p2) &#123; for(i = 0; i &lt; n; i++) &#123; printf("on mic: p[%d] is %d\n", i, p[i]); &#125; for(i = 0; i &lt; n+1; i++) &#123; printf("on mic: p1[%d] is %d\n", i, p1[i]); &#125; for(i = 0; i &lt; n-1; i++) &#123; printf("on mic: p2[%d] is %d\n", i, p2[i]); &#125; &#125; for(i = 0; i &lt; n; i++) &#123; printf("after offload: p[%d] is %d\n", i, p[i]); &#125; for(i = 0; i &lt; n+1; i++) &#123; printf("after offload: p1[%d] is %d\n", i, p1[i]); &#125; for(i = 0; i &lt; n-1; i++) &#123; printf("after offload: p2[%d] is %d\n", i, p2[i]); &#125; printf("==============================\n");&#125;// 将一维数组放到二维数组里以及二维数组放到一维数组,// 文档中说不可以, 但是这里确实可以使用void use_into3() &#123; int n = 10, i; int p[n * n]; int a[n][n]; init_array(p, n * n, 0);#pragma offload target(mic) in(p:into(a)) out(a:into(p)) &#123; for(i = 0; i &lt; n; i++) &#123; printf("on mic: a[%d][0] is %d\n", i, a[i][0]); &#125; // 相当于p[0] a[0][0] = 1000; // 相当于p[10] a[1][0] = 1000; &#125; printf("p[0] is %d and p[10] is %d\n", p[0], p[10]); printf("==============================\n");&#125;int main() &#123; use_into(); //use_into2(); //use_into3();&#125; alloc_if 和 free_if对于指针变量来说, 每次执行offload都会为其分配新的内存, 当offload执行完之后, 就会将该内存释放掉. 为了能够重用前面offload所开辟的空间, mic提供了alloc_if和free_if来显示指定是否为offload的指针变量(非指针变量使用alloc_if和free_if会报错)分配新的内存以及执行完offload后是否释放该内存. 下面是具体含义: alloc_if(1) - offload时为指针分配新的内存 alloc_if(0) - offload时不开辟新的内存, 而是使用前面保留的内存 free_if(1) - offload执行完成后, 释放掉为该指针分配的内存 free_if(0) - offload执行完成后, 不释放指针对应的内存 默认值是alloc_if(1) 和 free_if(1), 为了使程序更加清晰, 我们预定义几个宏1234#define ALLOC alloc_if(1)#define FREE free_if(1)#define RETAIN free_if(0)#define REUSE alloc_if(0) 下面是具体的示例代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ALLOC alloc_if(1)#define FREE free_if(1)#define RETAIN free_if(0)#define REUSE alloc_if(0)void init_array(int* arr, int n, int start_num)&#123; int i; for(i = 0; i &lt; n; i++) &#123; arr[i] = start_num + i; &#125;&#125;// 当mic上没有未释放的内存时, 使用alloc_if(0)会报错void reuse_before_alloc() &#123; int n = 10; int *p =(int*) calloc(n, sizeof(int)); int i; init_array(p, n, 0); //当然这是错的offload error: cannot find data associated with pointer variable 0x15e2c60 //因为没有已有的内存#pragma offload target(mic) in(p:length(10) REUSE) &#123; for(i = 0; i &lt; n; i++) &#123; printf("the p[%d] id %d\n", i, p[i]); &#125; &#125; free(p);&#125;//这里保存内存, 在下面执行reuse, reuse2 之前都应该先执行该函数在MIC上保存内存.void retain() &#123; int n = 10; int *p =(int*) calloc(n, sizeof(int)); int i; init_array(p, n, 0); #pragma offload target(mic) in(p:length(n) RETAIN) &#123; for(i = 0; i &lt; n; i++) &#123; printf("retain: the p[%d] id %d\n", i, p[i]); &#125; &#125; free(p);&#125;//这里使用上面保存的内存空间void reuse() &#123; int n = 10; int *p =(int*) calloc(n, sizeof(int)); int i; init_array(p, n, 0); //如果不加retain会默认释放掉该内存 #pragma offload target(mic) in(p:length(n) REUSE) &#123; for(i = 0; i &lt; n; i++) &#123; printf("reuse: the p[%d] id %d\n", i, p[i]); &#125; &#125; free(p);&#125;// 重用的内存不可以大于MIC上已保存的内存, 小于是可以的void reuse2() &#123; // 如果n=11就会报错 int n = 9; int *p =(int*) calloc(n, sizeof(int)); int i; init_array(p, n, 0);#pragma offload target(mic) in(p:length(n) REUSE) &#123; for(i = 0; i &lt; n; i++) &#123; printf("reuse: the p[%d] is %d\n", i, p[i]); &#125; &#125; free(p);&#125;int main()&#123; // reuse_before_alloc(); retain(); reuse(); // retain(); // reuse2(); return 0;&#125; 还有一个问题就是重用内存的时候好像是不需要两个变量名相同, 看下面的代码1234567891011121314151617181920212223242526272829void retain() &#123; int n = 10; int *p =(int*) calloc(n, sizeof(int)); int i; init_array(p, n, 0); #pragma offload target(mic) in(p:length(n) RETAIN) &#123; for(i = 0; i &lt; n; i++) &#123; printf("retain: the p[%d] id %d\n", i, p[i]); &#125; &#125; free(p);&#125;void reuse() &#123; int n = 10; int *p2 =(int*) calloc(n, sizeof(int)); int i; init_array(p2, n, 0);#pragma offload target(mic) in(p2:length(n) REUSE) &#123; for(i = 0; i &lt; n; i++) &#123; printf("reuse: the p2[%d] is %d\n", i, p2[i]); &#125; &#125; free(p2);&#125; 首先执行retain, 然后在执行reuse, 程序仍然可以正常运行. Applying the target Attribute to Multiple Declarations当有多个变量或者函数需要在MIC上使用时, 我们可以采用一种较为方便的声明方式为这些变量和函数加上 target(mic) 的属性, 下面是声明方式:123#pragma offload_attribute(push, target(mic))...#pragma offload_attribute(pop) 在两个#pragma之间声明的变量和函数都可以在mic上运行, 如果要声明共享虚拟内存模式下使用的共享变量和函数, 可以采用下面的形式123#pragma offload_attribute(push, _Cilk_shared)...#pragma offload_attribute(pop) 下面是一个示例:1234567891011121314151617181920212223#pragma offload_attribute(push, target(mic))#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void test1();void test2();#pragma offload_attribute(pop)int main() &#123;#pragma offload target(mic) test1();#pragma offload target(mic) test2();&#125;void test1() &#123; printf("this is test1\n");&#125;void test2() &#123; printf("this is test2\n");&#125;]]></content>
      <categories>
        <category>MIC</category>
      </categories>
      <tags>
        <tag>MIC</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【MIC学习笔记】in/out/inout详细用法]]></title>
    <url>%2F2015%2F11%2F30%2F%E3%80%90MIC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Offload-Using-a-Pragma%EF%BC%9Ain-out-inout%E8%AF%A6%E7%BB%86%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[下面的代码主要使用in作为测试, out和inout的用法应该是类似的， 下面主要以代码为主， 并且附带执行结果。 静态一维数组12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void offload_one_dim_array(int n) &#123; int arr[n]; int arr2[n]; int arr3[n]; int i; for(i = 0; i &lt; n; i++) &#123; arr[i] = i; arr2[i] = n + i; arr3[i] = 2 * n + i; &#125; //上传arr的全部元素,上传arr2的前0-4共5(长度为5)个元素,上传arr3的从索引2开始的5个元素(即索引2-6)到mic上 #pragma offload target(mic) in(arr) in(arr2:length(5)) in(arr3[1:5]) &#123; for(i = 0; i &lt; n; i++) &#123; printf(" arr[%d] is %d\n", i, arr[i]); &#125; printf("==========================\n"); for(i = 0; i &lt; n; i++) &#123; printf("arr2[%d] is %d\n", i, arr2[i]); &#125; printf("==========================\n"); for(i = 0; i &lt; n; i++) &#123; printf("arr3[%d] is %d\n", i, arr3[i]); &#125; &#125;&#125;int main() &#123; offload_one_dim_array(10); return 0;&#125; 输出结果为:1234567891011121314151617181920212223242526272829303132 arr[0] is 0 arr[1] is 1 arr[2] is 2 arr[3] is 3 arr[4] is 4 arr[5] is 5 arr[6] is 6 arr[7] is 7 arr[8] is 8 arr[9] is 9==========================arr2[0] is 10arr2[1] is 11arr2[2] is 12arr2[3] is 13arr2[4] is 14arr2[5] is 0arr2[6] is 0arr2[7] is 0arr2[8] is 0arr2[9] is 0==========================arr3[0] is 0arr3[1] is 0arr3[2] is 22arr3[3] is 23arr3[4] is 24arr3[5] is 25arr3[6] is 26arr3[7] is 0arr3[8] is 0arr3[9] is 0 静态二维数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void offload_two_dim_array(int n) &#123; int arr[n][n]; int arr2[n][n]; int arr3[n][n]; int arr4[n][n]; int i, j, index = 0; for(i = 0; i &lt; n; i++) &#123; for(j = 0; j &lt; n; j++) &#123; arr[i][j] = index; arr2[i][j] = n * n + index; arr3[i][j] = 2 * n * n + index; arr4[i][j] = 3 * n * n + index; index++; &#125; &#125; //上传arr的全部值,上传arr2的前5个值(整体看为长度为n*n的一维数组,取前5个值),上传arr3中[0-1][0-(n-1)]的值, //不加后面的y的维度,默认y的是1-(n-1), 上传arr4中[0-1][0-1]的值 #pragma offload target(mic) in(arr) in(arr2:length(5)) in(arr3[0:2]) in(arr4[0:2][0:2]) &#123; for(i = 0; i &lt; n; i++) &#123; for(j = 0; j &lt; n; j++) &#123; printf(" arr[%d][%d] is %d\n", i, j, arr[i][j]); &#125; &#125; printf("==========================\n"); for(i = 0; i &lt; n; i++) &#123; for(j = 0; j &lt; n; j++) &#123; printf("arr2[%d][%d] is %d\n", i, j, arr2[i][j]); &#125; &#125; printf("==========================\n"); for(i = 0; i &lt; n; i++) &#123; for(j = 0; j &lt; n; j++) &#123; printf("arr3[%d][%d] is %d\n", i, j, arr3[i][j]); &#125; &#125; printf("==========================\n"); for(i = 0; i &lt; n; i++) &#123; for(j = 0; j &lt; n; j++) &#123; printf("arr4[%d][%d] is %d\n", i, j, arr4[i][j]); &#125; &#125; &#125;&#125;int main() &#123; offload_two_dim_array(3); return 0;&#125; 下面是输出结果123456789101112131415161718192021222324252627282930313233343536373839 arr[0][0] is 0 arr[0][1] is 1 arr[0][2] is 2 arr[1][0] is 3 arr[1][1] is 4 arr[1][2] is 5 arr[2][0] is 6 arr[2][1] is 7 arr[2][2] is 8==========================arr2[0][0] is 9arr2[0][1] is 10arr2[0][2] is 11arr2[1][0] is 12arr2[1][1] is 13arr2[1][2] is 0arr2[2][0] is 0arr2[2][1] is 0arr2[2][2] is 0==========================arr3[0][0] is 18arr3[0][1] is 19arr3[0][2] is 20arr3[1][0] is 21arr3[1][1] is 22arr3[1][2] is 23arr3[2][0] is 0arr3[2][1] is 0arr3[2][2] is 0==========================arr4[0][0] is 27arr4[0][1] is 28arr4[0][2] is 0arr4[1][0] is 30arr4[1][1] is 31arr4[1][2] is 0arr4[2][0] is 0arr4[2][1] is 0arr4[2][2] is 0 一个小问题当数组(非指针)被offload一次之后会在mic上保存,并没有立即释放,在同一个作用域下,再次offload时,如果值改变会更改为新值,如果没有offload某些位置的值,这些位置会使用上一次的旧值下面是局部变量测试1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void offload_array_test(int n) &#123; int arr[n]; int i; for(i = 0; i &lt; n; i++) &#123; arr[i] = i; &#125; #pragma offload target(mic) in(arr) &#123; for(i = 0; i &lt; n; i++) &#123; printf("arr[%d] in first offload is %d\n", i, arr[i]); &#125; // 这里修改了并没有传回到CPU上, 但是会保存在MIC上 arr[9] = 1111; printf("==========================\n"); &#125; arr[1] = 1000; arr[8] = 2000; //这次的offload只上传了0-2共3个值,mic上arr[1]的值会更改为1000,arr[3-(n-1)]的值会使用MIC上保存的值, 注意arr[9]的值 #pragma offload target(mic) in(arr:length(3)) &#123; for(i = 0; i &lt; n; i++) &#123; printf("arr[%d] in second offload is %d\n",i, arr[i]); &#125; &#125; for(i = 0; i &lt; n; i++) &#123; printf("arr[%d] without offload is %d\n",i, arr[i]); &#125; printf("==========================\n");&#125;int main() &#123; offload_array_test(10); return 0;&#125; 输出结果为:1234567891011121314151617181920212223242526272829303132arr[0] without offload is 0arr[1] without offload is 1000arr[2] without offload is 2arr[3] without offload is 3arr[4] without offload is 4arr[5] without offload is 5arr[6] without offload is 6arr[7] without offload is 7arr[8] without offload is 2000arr[9] without offload is 9==========================arr[0] in first offload is 0arr[1] in first offload is 1arr[2] in first offload is 2arr[3] in first offload is 3arr[4] in first offload is 4arr[5] in first offload is 5arr[6] in first offload is 6arr[7] in first offload is 7arr[8] in first offload is 8arr[9] in first offload is 9==========================arr[0] in second offload is 0arr[1] in second offload is 1000arr[2] in second offload is 2arr[3] in second offload is 3arr[4] in second offload is 4arr[5] in second offload is 5arr[6] in second offload is 6arr[7] in second offload is 7arr[8] in second offload is 8arr[9] in second offload is 1111 下面是全局变量测试:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define __ONMIC__ __attribute__((target(mic)))__ONMIC__ int gArr[10];void test1() &#123; int i; for(i = 0; i &lt; 10; i++) &#123; gArr[i] = i; &#125; #pragma offload target(mic) &#123; for(i = 0; i &lt; 10; i++) &#123; printf("gArr[%d] in test1 is %d\n", i, gArr[i]); &#125; printf("==========================\n"); &#125;&#125;void test2() &#123; gArr[0] = 10; gArr[5] = 10; int i; #pragma offload target(mic) in(gArr[0:2]) &#123; for(i = 0; i &lt; 10; i++) &#123; printf("gArr[%d] in test2 is %d\n", i, gArr[i]); &#125; &#125;&#125;int main() &#123; test1(); test2(); return 0;&#125; 下面是测试结果:123456789101112131415161718192021gArr[0] in test1 is 0gArr[1] in test1 is 1gArr[2] in test1 is 2gArr[3] in test1 is 3gArr[4] in test1 is 4gArr[5] in test1 is 5gArr[6] in test1 is 6gArr[7] in test1 is 7gArr[8] in test1 is 8gArr[9] in test1 is 9==========================gArr[0] in test2 is 10gArr[1] in test2 is 1gArr[2] in test2 is 2gArr[3] in test2 is 3gArr[4] in test2 is 4gArr[5] in test2 is 5gArr[6] in test2 is 6gArr[7] in test2 is 7gArr[8] in test2 is 8gArr[9] in test2 is 9 一维动态数组123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void offload_point() &#123; int n = 10; int *arr =(int*) calloc(n, sizeof(int)); int *arr2 = (int*) calloc(n, sizeof(int)); int *arr3 = (int*) calloc(n, sizeof(int)); int i; for(i = 0; i &lt; n; i++) &#123; arr[i] = i; arr2[i] = n + i; arr3[i] = n * 2 + i; &#125; //需要注意:上传指针定义的数组时 1:要指定length或者[start:length]属性 2:要显示用in #pragma offload target(mic) in(arr:length(n)) in (arr2[2:3]) in (arr3:length(3)) &#123; for(i = 0; i &lt; n; i++) &#123; printf(" arr[%d] is %d\n",i, arr[i]); &#125; printf("==========================\n"); for(i = 0; i &lt; n; i++) &#123; printf("arr2[%d] is %d \n",i, arr2[i]); &#125; printf("==========================\n"); for(i = 0; i &lt; n; i++) &#123; printf("arr3[%d] is %d \n", i, arr3[i]); &#125; &#125; free(arr); free(arr2); free(arr3);&#125;int main() &#123; offload_point(); return 0;&#125; 程序输出如下:1234567891011121314151617181920212223242526272829303132 arr[0] is 0 arr[1] is 1 arr[2] is 2 arr[3] is 3 arr[4] is 4 arr[5] is 5 arr[6] is 6 arr[7] is 7 arr[8] is 8 arr[9] is 9==========================arr2[0] is 0 arr2[1] is 0 arr2[2] is 12 arr2[3] is 13 arr2[4] is 14 arr2[5] is 0 arr2[6] is 0 arr2[7] is 0 arr2[8] is 0 arr2[9] is 0 ==========================arr3[0] is 20 arr3[1] is 21 arr3[2] is 22 arr3[3] is 0 arr3[4] is 0 arr3[5] is 0 arr3[6] is 0 arr3[7] is 0 arr3[8] is 0 arr3[9] is 0 使用指针实现的二维数组首先用typedef定义一个一维静态数组的类型, 然后为该类型声明一个动态数组1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ARRAY[5];//下面相当于上传了一个二维数组void offload_point2() &#123; int n = 3; ARRAY *arr = (ARRAY*)calloc(n, sizeof(ARRAY)); ARRAY *arr2 = (ARRAY*)calloc(n, sizeof(ARRAY)); int i, j, index = 0; for(i = 0; i &lt; n; i++) &#123; for(j = 0; j &lt; 5; j++) &#123; arr[i][j] = index; arr2[i][j] = n *n + index; index++; &#125; &#125; #pragma offload target(mic) in(arr:length(n)) in (arr2[0:2][0:2]) &#123; for(i = 0; i &lt; n; i++) &#123; for(j = 0; j &lt; 5; j++) &#123; printf(" arr[%d][%d] is %d \n", i, j , arr[i][j]); &#125; &#125; printf("==========================\n"); for(i = 0; i &lt; n; i++) &#123; for(j = 0; j &lt; 5; j++) &#123; printf("arr2[%d][%d] is %d \n", i, j , arr2[i][j]); &#125; &#125; &#125; free(arr); free(arr2);&#125;int main() &#123; offload_point2(); return 0;&#125; 输出结果为:12345678910111213141516171819202122232425262728293031 arr[0][0] is 0 arr[0][1] is 1 arr[0][2] is 2 arr[0][3] is 3 arr[0][4] is 4 arr[1][0] is 5 arr[1][1] is 6 arr[1][2] is 7 arr[1][3] is 8 arr[1][4] is 9 arr[2][0] is 10 arr[2][1] is 11 arr[2][2] is 12 arr[2][3] is 13 arr[2][4] is 14 ==========================arr2[0][0] is 9 arr2[0][1] is 10 arr2[0][2] is 0 arr2[0][3] is 0 arr2[0][4] is 0 arr2[1][0] is 14 arr2[1][1] is 15 arr2[1][2] is 0 arr2[1][3] is 0 arr2[1][4] is 0 arr2[2][0] is 0 arr2[2][1] is 0 arr2[2][2] is 0 arr2[2][3] is 0 arr2[2][4] is 0 包含指针的struct12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct my_struct &#123; int y; int *a;&#125;;void offload_struct() &#123; struct my_struct m; m.y = 10; m.a =(int*) calloc(10, sizeof(int)); int i; for(i=0; i &lt; 10; i++) &#123; m.a[i] = i; &#125; //struct中有指针变量时要单独传指针变量 #pragma offload target(mic) in(m) in(m.a:length(10)) &#123; printf("offload_struct: the struct.y is %d\n", m.y); printf("offload_struct: the struct.a is %d\n", m.a[1]); &#125; free(m.a);&#125;int main() &#123; offload_struct(); return 0;&#125; 注意事项使用offload不能上传指针数组, 即一个数组中的每个元素是一个指针, 或者元素中包含一个指针， 比如下面的形式12345678int **pstruct mystruct &#123; int *i;&#125;;struct mystruct *m;]]></content>
      <categories>
        <category>MIC</category>
      </categories>
      <tags>
        <tag>MIC</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【MIC学习笔记】Offload Using a Pragma]]></title>
    <url>%2F2015%2F11%2F30%2F%E3%80%90MIC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Offload-Using-a-Pragma%2F</url>
    <content type="text"><![CDATA[这种方式对应于我们前面所说的非共享内存模型，这里记录一下它的基本用法 定义MIC使用的函数和变量如果是局部变量, 那么我们不需要做额外的工作, 如果全局变量或者函数, 要在mic上使用它们, 则需要使用下面的方式声明或者定义:1234__declspec( target (mic)) function-declaration__declspec( target (mic)) variable-declaration__attribute__ (( target (mic))) function-declaration__attribute__ (( target (mic))) variable-declaration 其中__declspec可以用于windows或者linux系统, 而_attribute__只能用于linux.下面使用示例:1234567891011121314151617181920#include &lt;stdio.h&gt;#define __ONMIC__ __attribute__((target(mic)))__ONMIC__ int i;__ONMIC__ void f(int n) &#123; printf("n*n is %d\n", n*n);&#125;int main() &#123; #pragma offload target(mic) &#123; i = 100; f(i); &#125; printf("i is %d\n", i);&#125; 数据传输虽然在host(主机端, 例如CPU)和targets(设备端, 例如MIC卡)端使用的指令集是相似的, 但是它们并不共享同一个系统内存, 这也就意味着在#pragma代码块中用到的变量必须同时存在于host和target上, 为了确保这样, pragma使用特定的说明符(Specifiers)[in, out, inout]来指定在host和target之间复制的变量. in: 指定一个变量从host端复制到target端(作为target的输入), 但是不从target端复制回host端 out: 指定一个变量从target端复制回host端(作为target的输出), 但是不从host段复制到target端 inout: 指定一个变量即从host端复制到target端, 也从target段复制回host端(即是输入又是输出). 在没有显示的调用说明符, 那么默认inout. 下面是一个示例1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main() &#123; int inVar = 10; int outVar = 20; int inoutVar = 30; #pragma offload target(mic) in(inVar) out(outVar) &#123; printf("inVar in MIC is %d\n", inVar); printf("outVar in MIC is %d\n", outVar); // 这里用到了inoutVar, 但是offload时并没有指定它的说明符, 则用默认的inout printf("inoutVar in MIC is %d\n", inoutVar); inVar = 100; outVar = 200; inoutVar = 300; &#125; printf("inVar in CPU is %d\n", inVar); printf("outVar in CPU is %d\n", outVar); printf("inoutVar in CPU is %d\n", inoutVar);&#125; 输出结果为:123456inVar in CPU is 10outVar in CPU is 200inoutVar in CPU is 300inVar in MIC is 10outVar in MIC is 0inoutVar in MIC is 30 从上面可以看出inVar的值传到了MIC上, 但是在MIC上修改后并没有传回CPU, CPU中outVar的没有传递到MIC上, 但是MIC上outVar的值却是传回到了CPU上,而inoutVar的值即传递到了MIC,也从MIC上传了回来. 同时我们还可以看到, 先打印的是in CPU, 又打印的in MIC, 这是因为在target端(比如MIC卡)输出时, 因为PCI-E设备(MIC卡是插在PCI-E插槽上的) 无法直接访问显示器, 所以必须经过CPU中转. 虽然各家厂商实现方式不尽相同, 但总免不了使用卡上的内存进行缓冲, 之后交换到host端内存中, 再进行输出, 这样就会有一定的延迟, 因此一般target上的输出要慢于host端的输出.]]></content>
      <categories>
        <category>MIC</category>
      </categories>
      <tags>
        <tag>MIC</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【MIC学习笔记】HelloWorld]]></title>
    <url>%2F2015%2F11%2F29%2F%E3%80%90MIC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91HelloWorld%2F</url>
    <content type="text"><![CDATA[什么是MIC以下摘自”MIC高性能编程指南” 通常提及MIC系列, 会提及以下几个名词: MIC(Many Integrated Core), Knights系列(如Knights Corner. KNC), Intel® Xeon PhiTM(官方中文译名:英特尔® 至强融核TM). MIC作为这个系列的架构名称, 类似于CPU, 是对采用这种架构的产品的总称. Knights 系列, 是Intel公司推出的MIC产品的研发代号, 类似于Ivy Bridge, 是内部研发人员对某一代产品的命名,不用于商业用途, 例如第一代正式产品锁采用的,就是Knights Corner架构. 提到具体KNx的架构, 与MIC架构相比, 可以看做是面向对象中父类与子类的关系, MIC架构是父类, 而KNx则是子类. Intel® Xeon PhiTM则是产品线的总称, 类似于Pentium、 Xeon等产品系列, Intel® Xeon PhiTM 是Intel公司推出的基于MIC架构的高性能计算协处理器卡的系列产品名称. 运行模式MIC卡本身自带了一个简化的linux系统, 因此在安装了MIC卡的系统中, MIC既可以和CPU协同工作(使用offload), 也可以独立工作(native模式), 我们这里主要使用的是MIC和CPU协同工作的模式. HelloWorld为了能够直观的看出我们的程序是在MIC端运行的, 首先介绍一个宏__MIC__, 这个宏只有在MIC上运行时才有效, 在CPU端运行是没有该宏的定义的. 下面是Hello World代码:123456789101112131415#include &lt;stdio.h&gt;__attribute__ (( target (mic))) void say_hello() &#123; //如果有__MIC__的宏定义, 证明是在MIC端运行的 #ifdef __MIC__ printf("Hello from MIC\n"); #else printf("Hello from CPU\n"); #endif&#125;int main() &#123; #pragma offload target(mic) say_hello();&#125; 使用下面的命令进行编译1icc -o helloworld helloworld.c 然后执行helloworld会打印Hello from MIC, 如果将’#pragma offload target(mic)’ 注释掉, 就会打印出Hello from CPU. offload(分载)offload(分载)大概就是说程序在cpu上运行时, 会将一部分的工作交给mic去做, mic做完之后将结果再传递回来.下面是高性能编程指南中中关于分载的定义: 分载是指设计的程序运行在处理器上, 同时将部分工作负载分载到一个或多个协处理器上. 因为主处理器和协处理器之间不能共享常规的系统内存, 所以需要大量的分载控制与功能, 因此导致数据在主处理器和协处理器之间需要往复传递. 分载分为两种模式:非共享内存模式和共享虚拟内存模式. 非共享内存模式非共享内存模式使用#pramga预编译指令, 使用方式为#pragma offload target(mic) , 上面的HelloWorld就使用了这种模式. 在这种模式下将cpu和mic的内存看作两块独立的内存(实际上也是这样), 数据在这两块内存之间根据需求相互传输. 我们可以指定将哪些数据传输到mic上, 以及将哪些数据传回cpu. 这种模式适合处理扁平的数据结构(flat structure-scalars, arrays, and structs that can be copied from one variable to another using a simple memcpy). 该模式的性能高于共享内存模式. 共享虚拟内存模式共享虚拟内存(shared Virtual Memory) 模式默认集成到Intel Cilk Plus中, 在C/C++编程中使用_Cilk_shared和_Cilk_offload关键字. 共享虚拟内存不支持Fortran语言.在这种模式下, 变量通过_Cilk_shared 关键字在CPU和MIC之间共享, 所共享的动态内存必须通过特定的函数分配:_Offload_shared_malloc, _Offload_shared_aligned_malloc, _Offload_shared_free, _Offload_shared_aligned_free. 此模式适用于处理复杂的数据结构,比如链表, 树等. 该模式性能相对较差, 但是为编程提供了方便. 学习资料目前关于MIC的中文书籍大概有两本: MIC 高性能计算编程指南 Intel Xeon Phi协处理器高性能编程指南 另外的学习资料大概就是Intel 编译器的指导手册https://software.intel.com/en-us/compiler_15.0_ug_c在Key Features有关于MIC的讲解,如果访问速度太慢, 可以访问下面的链接http://scc.ustc.edu.cn/zlsc/tc4600/intel/2015.1.133/compiler_c/]]></content>
      <categories>
        <category>MIC</category>
      </categories>
      <tags>
        <tag>MIC</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C】alignment]]></title>
    <url>%2F2015%2F11%2F28%2F%E3%80%90C%E3%80%91alignment%2F</url>
    <content type="text"><![CDATA[内存访问粒度如果没有深入的了解内存方面的东西, 我们可能会认为内存不过是简单的字节数组, 例如下面的形式但是实际上, 计算机的处理器并不是以单个字节块为单位读写内存, 而是以2个,4个,8个,甚至16或者32个字节块为单位读写内存,如下图所示 我们将处理器访问内存单元的大小叫做其内存访问的粒度.知道上面这一点很重要, 这也是C语言alignment的基础. alignment 基本知识为了说明对齐的基本原则, 下面举一个例子: 该示例很简单首先我们从地址0读取4个字节到处理器的register(寄存器), 然后我们从地址1读取4个字节到同一个寄存器. 首先我们看一下当处理器的访问粒度为1时的情况:在这种情况下, 从地址0开始读和从地址1开始需要访问四次内存其所需的时间是相同的. 下面再看一下当处理器的内存访问粒度为2时的情况:在这种情况下, 每次访问内存可以读取两个字节, 所以当从地址0 开始读时, 只需要访问两次内存, 这比单字节粒度减少了一半的时间. 但是当从地址1开始读时, 却需要访问三次内存, 第一次读[0,1]两个位置的字节, 第二次读[2,3]两个位置的字节,第三次读[4,5]两个位置的字节. 之所以出现这种情况是因为开始读取的位置(即1)没有位于处理器内存访问的边界上(当粒度为2时, 边界为0, 2, … , 2n), 所以需要额外的操作. 而这种地址就是所说的未对齐的地址(unaligned address).最后我们再来看一下当内存访问粒度为4时的情况当从地址0开始读时, 只需要一次内存访问, 而从地址1(未对齐的地址)开始读时需要两次内存访问.通过上面的示例我们可以看到从未对齐位置访存要比从对齐位置访问多一次访存的操作, 然而除了多了一次访问之外, 我们还要注意到未对齐访存时会取到一些多余的数据, 处理器还要将这些多余的数据去除, 如下图所示:从上面可以看到当读取了第一个内存块之后需要移除地址0的字节, 当读取了第二个内存块后要移除地址6-8的字节, 这很大程度上增加了处理器的负担. 内存对齐(memory alignment)大多数CPU都要求位于内存中的变量和对象有一个特殊的起始位置(或者偏移 offset), 例如32位的处理器要求一个4字节整型在内存中的地址(第一个字节的地址)能被4整除, 我们就可以将这种要求(requirement)称为”memory alignment”. 当向内存中存入一个变量(variable)时, 此数据的地址应该是该数据alignmengt的整数倍. 基本类型对齐对于基本类型来说, 它的alignment值和其所占的长度有关, 一般来说, 其alignment值就是其所占的字节数. 1234567891011121314151617#include &lt;stdio.h&gt;int main() &#123; char c; short s; int i; float f; long long l; double d; printf("the size of c is %ld and address of c is %p\n", sizeof(c), &amp;c); printf("the size of s is %ld and address of s is %p\n", sizeof(s), &amp;s); printf("the size of i is %ld and address of i is %p\n", sizeof(i), &amp;i); printf("the size of f is %ld and address of f is %p\n", sizeof(f), &amp;f); printf("the size of l is %ld and address of l is %p\n", sizeof(l), &amp;l); printf("the size of d is %ld and address of d is %p\n", sizeof(d), &amp;d);&#125; 下面是基本的对齐原则: 在不同的机器上对其原则是不同的, 所以要根据具体的机器来, 上面所说的地址的最低一位为0, 就是起始位置必须是2的倍数, 最低两位为0, 则是起始位置必须是4的倍数. 结构体对齐默认对齐方式基本对齐原则如下: 结构体对齐值: 其成员中自身对齐值最大的那个值 结构体中成员的对齐值: 成员自身对齐值和结构体对齐值中较小的那个 结构体的大小为结构体对齐值的整倍数 结构体一般会通过插入空位的(padding)方式来满足上面的原则 比如下面的结构体:12345struct mystruct &#123; char c; int i; short s;&#125;; 在这个结构体中, c占1个字节, i占4个字节, s占两个字节, 所以mystruct的alignment值是4, 此时该结构体占12个字节, 下面是示意图我们将上面的结构修改一下, 将s和i的顺序换一下12345struct mystruct&#123; char c; short s; int i;&#125;; 那么此时该结构体所占的字节为8, 下面是内存示意图所以为了尽量减少结构体中的空位, 我们应该合理的安排结构体中成员的顺寻.如果结构体中包含结构体, 比如下面的代码:123456789struct mystruct1&#123; char c; double d;&#125;;struct mystruct2&#123; char c; struct mystruct1 st1;&#125;; 在这种情况下, 我们其实可以将mystruct1当成一个对齐值为8, 长度为16的基本类型处理, 只不过对齐值和所占的字节数是不固定的. 指定对齐值的大小方法一： #pragma pack(value)我们可以通过使用#pragma pack(value) 来指定对齐值的大小. 看下面的代码:1234567#pragma pack(1) // 设置对齐值为1struct mystruct &#123; char c; int i; short s;&#125;;#pragma pack() // 取消指定对齐, 采用默认对齐方式 #pragma pack(1)将结构体及其成员的对齐值设为1, 也就是说结构体中的成员可以从任意的地址位置开始, 此时mystruct的大小为7._注意如果pack中的value大于结构体原先的对齐值, 那么结构体仍然采用原先的对应值. 而结构体中每个数据成员的对齐，按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行. _ 方法二：__attribute__((aligned(n))) __attribute__((aligned(n))) : 让所作用的结构成员对齐在n字节自然边界上。如果结构中有成员的长度大于n，则按照最大成员的长度来对齐。 __attribute__((packed)):取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐。 1234567891011121314151617// 对齐值为16struct mystruct &#123; char c; int i;&#125;__attribute__((aligned(16)));// 对齐值为4(以i为对齐值)struct mystruct2 &#123; char c; int i;&#125;__attribute__((aligned(2)));// 按实际占用字节对齐(即1)struct mystruct3 &#123; char c; int i;&#125;__attribute__((packed)); 华丽的分割线 实际的运行效率其实现在的计算机已经能很好没有对齐的情况了, 所以我们在一般的机器上运行时, 即使没有对齐也不会有很大的效率问题, 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/time.h&gt;#include &lt;stdint.h&gt;#define GET_TIME(now) &#123; struct timeval t; gettimeofday(&amp;t, NULL); now = t.tv_sec + t.tv_usec/1000000.0;&#125;struct Foo &#123; char x; short y; int z; char x1; int z1; char x2; int z2; char x3; long z3; char x4; long z4;&#125;;struct Foo foo;struct Bar &#123; char x; short y; int z; char x1; int z1; char x2; int z2; char x3; long z3; char x4; long z4;&#125; __attribute__((packed));struct Bar bar;int main() &#123; double start, end, start1, end1 ; double time1, time2; GET_TIME(start1); uint64_t i; for ( i =0; i &lt; RUNS; i++) &#123; foo.z = i; foo.z1 =i+ 1; foo.z2 = i + 2; foo.z3 = i + 3; foo.z4 = i + 4; &#125; GET_TIME(end1); time1 = end1 - start1; GET_TIME(start); for( i =0; i &lt; RUNS; i++) &#123; bar.z = i; bar.z1 = i + 1; bar.z2 = i + 2; bar.z3 = i + 3; bar.z4 = i + 4; &#125; GET_TIME(end); time2 = end - start; printf("the size of Foo is %dn", sizeof(foo)); printf("the size of Bar is %dn", sizeof(bar)); printf("the time of Foo is %fn", time1); printf("the time of Bar is %fn", time2); &#125; 使用gcc编译代码1gcc -DRUNS=400000000 -o time test_time.c 然后执行会发现两者运行速度几乎是相同的. 但是在一些老的机器或者协处理器上内存对齐对速度还是有一定影响的. 参考文章 Data alignment: Straighten up and fly rightAlignment in C]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C】记录两个C语言的误区]]></title>
    <url>%2F2015%2F11%2F15%2F%E3%80%90C%E3%80%91%E8%AE%B0%E5%BD%95%E4%B8%A4%E4%B8%AAC%E8%AF%AD%E8%A8%80%E7%9A%84%E8%AF%AF%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[前言之前在windows上使用vc++6.0，编写过c的代码，主要是为了完成一些作业，并没有十分深入的学习C语言. 因此当时留下了两个对于c语的言的误区，现在记录一下。 关于函数的调用一直以我都认为在调用一个方法之前，必须要在前面声明原型或者直接定义该方法， 大概如下面的形式， 否则程序就会出现编译错误。 12345678910int test();int main() &#123; test(); return 0;&#125;int test() &#123; //some code return 0;&#125; 直到我偶然使用gcc编译了一下下面的代码: 123456789int main() &#123; aa(); return 0;&#125;int aa() &#123; printf("this is aa\n"); return 0;&#125; 编译器竟然没有报任何错误和警告， 并且程序可以正常运行。 瞬间有三观被刷新的感觉. 一开始我以为是使用的编译器的标准不同，因此尝试着使用c89，c90，c99，c11编译程序，使用c89和c90时， 编译器还是没有报任何错误，而使用c99和c11时，会报下面的警告:1234test.c: In function ‘main’:test.c:5:2: warning: implicit declaration of function ‘aa’ [-Wimplicit-function-declaration] aa(); ^ 然而仅仅是警告，程序还是可以正常执行。 随后我又看了一下gcc的版本，发现是4.8.4， 然后查看了一下它的手册， 发现其默认使用的c编译标准是c901The default， if no C language dialect options are given， is -std=gnu90; 不过有意思的如果将代码写成下面的形式:1234567int main() &#123; aa();&#125;void aa(int n) &#123; printf("this is aa\n");&#125; 那么编译时就会报下面的警告:123456test.c:8:7: warning: conflicting types for ‘aa’ [enabled by default] void aa() &#123; ^test.c:4:2: note: previous implicit declaration of ‘aa’ was here aa(); ^ 如果将aa的void改为double，就会直接报错了:123456test.c:8:9: error: conflicting types for ‘aa’ double aa() &#123; ^test.c:4:2: note: previous implicit declaration of ‘aa’ was here aa(); ^ 查了一下， 大该就是如果不事先定义函数原型并且在函数定义前调用该函数， 那么编译器就会认为该函数 return int 类型， 并且接受的参数个数不确定， 因此当在下面的函数定义时不返回int类型， 就会重现冲突的警告或者错误。总结一下就是在函数未被定义之前(并且没有声明函数原型)， 我们并不是绝对的不能调用它， 但是这种方式是十分不优雅的， 并且可能出现各种问题.。 所以还是采取函数原型的方式比较好。 静态数组另一个误区就是静态数组的定义， 如下面的形式在vc++6.0中编译时会出现错误12int n = 5;int arr[n]; 因此我一直以为在c中定义静态数组必须要制定一个确定的值，而不能是变量。 当然当我无意中使用gcc编译一下上面的代码，发现是可以编译通过的， 并且没有任务的警告和错误， 于是感觉三观又被刷新了。。。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【应用】信息短时存储]]></title>
    <url>%2F2015%2F11%2F07%2F%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91%E4%BF%A1%E6%81%AF%E7%9F%AD%E6%97%B6%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[功能这是一个在线的应用，用来短时间存储一些信息，以实现在不同设备上共享这些信息的功能。其实目的就是可以将手机上的一些信息快速的复制到电脑上，尤其是在使用Linux系统的时候。下面是该应用的截图。其中阅后即焚是指信息被访问一次之后就会被销毁。 流程程序主要的流程就是首先在文本框中输入或者粘贴一些内容，然后保存到服务器（使用的是新浪sae），保存成功之后会返回给客户端一个编号，通过该编号就可以访问存储的内容。因为就是为了给手机和电脑之间的复制粘贴提供一个介质，所以信息的有效时间暂时设为了2分钟，2分钟之后就会清除保存的信息。 前端实现整体风格程序使用的是bootstrap框架，如果你还没有用过这个前端框架，那么强烈推荐你试用一下，因为使用该框架可以极大的减少你的工作量，并且兼容手机设备。下面是页面的主要html代码，其中css样式几乎全部为bootstrap定义的样式，这样我们就可以将更多的时间放在功能实现，而不是网页设计上。12345678910111213141516171819202122232425262728293031323334&lt;div class="container "&gt; &lt;div class="row "&gt; &lt;div style="padding:10px; "&gt; &lt;form class="bs-example bs-example-form" role="form"&gt; &lt;div class="col-lg-12"&gt; &lt;div class="input-group input-group-lg"&gt; &lt;span class="input-group-addon"&gt;编号&lt;/span&gt; &lt;input type="text" class="form-control" id="textId"&gt; &lt;span class="input-group-btn"&gt; &lt;button class="btn btn-default" type="button" id="msgGet"&gt;获取信息&lt;/button&gt; &lt;/span&gt; &lt;/div&gt; &lt;br&gt; &lt;div class="form-group "&gt; &lt;textarea class="form-control custom-control change_font" style="resize:none" rows="8" placeholder="请输入信息" id="mainText"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class="text-center"&gt; &lt;button type="button" class="btn btn-primary button_width" id="msgClear"&gt;清空&lt;/button&gt; &lt;button type="button" class="btn btn-primary button_width2 " id="msgSave"&gt;保存&lt;/button&gt; &lt;div class="bootstrap-switch "&gt; &lt;input type="checkbox" name="onlyOne" data-label-text="阅后即焚" data-on-text="是" data-off-text="否" onSwitchChange="changeOne"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; bootstrap有自适应机制，页面内容的宽度会随浏览器窗口的大小改变而改变。但是在我们的页面中如果采用默认的自适应机制，就可能会造成在较宽的屏幕上输入框的宽度过大，从而使的页面看起来不美观。所以我们更改了一下其默认行为，当浏览器窗口宽度大于800px时，将网页内容的宽度固定为800px。实现方式很简单，加上下面的css代码即可。12345@media screen and (min-width: 800px) &#123; .container &#123; width: 800px; &#125;&#125; 还有一点就是input的placeholder属性在较低的IE版本中不兼容，使用下面的js代码可以解决这个问题123456789101112131415161718192021222324252627282930313233343536var JPlaceHolder = &#123; //检测 _check: function () &#123; return 'placeholder' in document.createElement('input'); &#125;, //初始化 init: function () &#123; if (!this._check()) &#123; this.fix(); &#125; &#125;, //修复 fix: function () &#123; jQuery(':input[placeholder]').each(function (index, element) &#123; var self = $(this), txt = self.attr('placeholder'); self.wrap($('&lt;div&gt;&lt;/div&gt;').css(&#123;position: 'relative', zoom: '1', border: 'none', background: 'none', padding: 'none', margin: 'none'&#125;)); var pos = self.position(), h = self.outerHeight(true), paddingleft = self.css('padding-left'); var holder = $('&lt;span&gt;&lt;/span&gt;').text(txt).css(&#123;position: 'absolute', left: pos.left, top: pos.top, height: h, lienHeight: h, paddingLeft: paddingleft, fontSize: '1.5em', color: '#aaa'&#125;).appendTo(self.parent()); self.focusin(function (e) &#123; holder.hide(); &#125;).focusout(function (e) &#123; if (!self.val()) &#123; holder.show(); &#125; &#125;); holder.click(function (e) &#123; holder.hide(); self.focus(); &#125;); &#125;); &#125;&#125;;//执行jQuery(function () &#123; JPlaceHolder.init();&#125;); bootstrap开关切换插件在选择”阅后即焚”功能的地方，我们使用了一个开关切换的插件——bootstrap switch，这里 是该插件的github地址，使用起来也十分简单，下面是一个简单的示例，更多的属性可以参考官方文档123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;bootstrap switch demo&lt;/title&gt; &lt;link rel="stylesheet" href="css/bootstrap3/bootstrap.min.css"&gt; &lt;link rel="stylesheet" href="css/bootstrap3/bootstrap-switch.min.css"&gt; &lt;script type="text/javascript" src="js/jquery.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/bootstrap.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/bootstrap-switch.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(document).ready(function() &#123; $("[name='my-checkbox']").bootstrapSwitch(); $('input[name="my-checkbox"]').on('switchChange.bootstrapSwitch', function(event, state) &#123; console.log(this); // DOM element console.log(event); // jQuery event console.log(state); // true | false &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="checkbox" name="my-checkbox" data-on-text="是" data-off-text="否" checked&gt;&lt;/body&gt;&lt;/html&gt; 效果图如下所示 信息提示一般来说使用alert就可以实现弹窗提示的功能，但是各个浏览器的弹窗样式都不相同并且也不美观，这里使用了jQuery Toaster插件，效果如下图所示，这里 是github地址。这个插件需要bootstrap 3.0+，不过使用起来更加方便，只需要引入一个jquery.toaster.js即可，下面是一个示例123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;bootstrap toaster demo&lt;/title&gt; &lt;link rel="stylesheet" href="css/bootstrap3/bootstrap.min.css"&gt; &lt;script type="text/javascript" src="js/jquery.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/bootstrap.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/jquery.toaster.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;button id="open" class="btn btn-primary "&gt;Click Me&lt;/button&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; $("#open").click(function () &#123; $.toaster(&#123;message: 'Your message here', title: 'Your Title', priority: 'danger'&#125;); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在默认情况下，弹窗出现的位置是在右上角，我们可以修改一下css样式使其出现在屏幕中间，不过要首先去jquery.toaster.js中，将下面的代码注释掉(大概90行附近)，12345678'css' :&#123; 'position' : 'fixed', 'top' : '10px', 'right' : '10px', 'width' : '300px', 'zIndex' : 50000&#125; 下面是修改后的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;bootstrap toaster demo&lt;/title&gt; &lt;link rel="stylesheet" href="css/bootstrap3/bootstrap.min.css"&gt; &lt;script type="text/javascript" src="js/jquery.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/bootstrap.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/jquery.toaster.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; @media screen and (min-width: 800px) &#123; .center_toaster &#123; right: 30%; width: 40%; &#125; &#125; @media screen and (min-width: 500px) and (max-width: 799px) &#123; .center_toaster &#123; right: 20%; width: 60%; &#125; &#125; @media screen and (min-width: 200px ) and (max-width: 499px) &#123; .center_toaster &#123; right: 5%; width: 90%; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;button id="open" class="btn btn-primary "&gt;Click Me&lt;/button&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; $.toaster(&#123; settings: &#123; 'toaster': &#123; 'class': 'center_toaster', 'css': &#123; 'position': 'fixed', 'top': '2px', 'zIndex': 50000 &#125; &#125; &#125; &#125;); $("#open").click(function () &#123; $.toaster(&#123;message: 'Your222 message here', title: 'Your Title', priority: 'danger'&#125;); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 不过按上面修改之后在低于IE9的浏览器中工作并不理想，可能是IE9以下对 @media 支持不太好，所以在js的代码中加了一个判断，如果浏览器支持html5的一些特性(使用jquery判断)就使用toaster，否则使用alert。12345if ($.support.leadingWhitespace) &#123; $.toaster(&#123; priority: 'warning', title: '警告', message: '编号不能为空'&#125;);&#125; else &#123; alert("警告：编号不能为空");&#125; Loading插件当用户点完获取数据或者保存按钮时，会弹出一个正在加载的弹出层，防止由于网络延迟等原因造成用户重复点击，下面是效果图 这里 是github地址。下面是一个简单的示例：12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;bootstrap watingDialog demo&lt;/title&gt; &lt;link rel="stylesheet" href="css/bootstrap3/bootstrap.min.css"&gt; &lt;script type="text/javascript" src="js/jquery.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/bootstrap.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/bootstrap-waitingfor.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;button id="open" class="btn btn-primary "&gt;Click Me&lt;/button&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; $("#open").click(function () &#123; waitingDialog.show(); setTimeout(function() &#123; waitingDialog.hide(); &#125;,2000); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 底部固定当页面内容的高度小于屏幕的高度时，将footer固定在底部，当页面内容的高度大于屏幕高度时，footer会随着滚动条滚动，不会遮盖到正常的内容，下面一个解决方法，这里 是原文地址。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;bootstrap fixed footer demo&lt;/title&gt; &lt;link rel="stylesheet" href="css/bootstrap3/bootstrap.min.css"&gt; &lt;script type="text/javascript" src="js/jquery.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/bootstrap.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; &#125; html, body &#123; height: 100%; &#125; .wrapper &#123; min-height: 100%; height: auto !important; height: 100%; margin: 0 auto -6em; &#125; /*push和footer的高度不一样是因为加了一条hr*/ .push &#123; height: 6em; &#125; .footer, &#123; height: 4em; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="wrapper"&gt; &lt;div class="container"&gt; &lt;p&gt;这里是内容&lt;/p&gt; &lt;/div&gt; &lt;div class="push"&gt;&lt;/div&gt;&lt;/div&gt;&lt;footer class="footer"&gt; &lt;div class=" col-lg-12 text-center"&gt; &lt;hr&gt; &lt;p&gt;Copyright &amp;copy; zhangjk 2015&lt;/p&gt; &lt;/div&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 服务端实现平台及语言服务器使用的新浪的sae，语言是使用的php。 php restful service因为应用逻辑非常简单，就是一个存和取数据，所以简单的实现了几个restful的接口，并没有使用专门的框架（主要是对php不熟悉）。接口的实现参考自这篇文章，下面是该文章给出的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;?php/* API Demo This script provides a RESTful API interface for a web application Input: $_GET['format'] = [ json | html | xml ] $_GET['method'] = [] Output: A formatted HTTP response Author: Mark Roland History: 11/13/2012 - Created*/// --- Step 1: Initialize variables and functions/** * Deliver HTTP Response * @param string $format The desired HTTP response content type: [json, html, xml] * @param string $api_response The desired HTTP response data * @return void * */function deliver_response($format, $api_response) &#123; // Define HTTP responses $http_response_code = array( 200 =&gt; 'OK', 400 =&gt; 'Bad Request', 401 =&gt; 'Unauthorized', 403 =&gt; 'Forbidden', 404 =&gt; 'Not Found' ); // Set HTTP Response header('HTTP/1.1 ' . $api_response['status'] . ' ' . $http_response_code[$api_response['status']]); // Process different content types if (strcasecmp($format, 'json') == 0) &#123; // Set HTTP Response Content Type header('Content-Type: application/json; charset=utf-8'); // Format data into a JSON response $json_response = json_encode($api_response); // Deliver formatted data echo $json_response; &#125; elseif (strcasecmp($format, 'xml') == 0) &#123; // Set HTTP Response Content Type header('Content-Type: application/xml; charset=utf-8'); // Format data into an XML response (This is only good at handling string data, not arrays) $xml_response = '&lt;?xml version="1.0" encoding="UTF-8"?&gt;' . "\n" . '&lt;response&gt;' . "\n" . "\t" . '&lt;code&gt;' . $api_response['code'] . '&lt;/code&gt;' . "\n" . "\t" . '&lt;data&gt;' . $api_response['data'] . '&lt;/data&gt;' . "\n" . '&lt;/response&gt;'; // Deliver formatted data echo $xml_response; &#125; else &#123; // Set HTTP Response Content Type (This is only good at handling string data, not arrays) header('Content-Type: text/html; charset=utf-8'); // Deliver formatted data echo $api_response['data']; &#125; // End script process exit;&#125;// Define whether an HTTPS connection is required$HTTPS_required = FALSE;// Define whether user authentication is required$authentication_required = FALSE;// Define API response codes and their related HTTP response$api_response_code = array( 0 =&gt; array( 'HTTP Response' =&gt; 400, 'Message' =&gt; 'Unknown Error' ) , 1 =&gt; array( 'HTTP Response' =&gt; 200, 'Message' =&gt; 'Success' ) , 2 =&gt; array( 'HTTP Response' =&gt; 403, 'Message' =&gt; 'HTTPS Required' ) , 3 =&gt; array( 'HTTP Response' =&gt; 401, 'Message' =&gt; 'Authentication Required' ) , 4 =&gt; array( 'HTTP Response' =&gt; 401, 'Message' =&gt; 'Authentication Failed' ) , 5 =&gt; array( 'HTTP Response' =&gt; 404, 'Message' =&gt; 'Invalid Request' ) , 6 =&gt; array( 'HTTP Response' =&gt; 400, 'Message' =&gt; 'Invalid Response Format' ));// Set default HTTP response of 'ok'$response['code'] = 0;$response['status'] = 404;$response['data'] = NULL;// --- Step 2: Authorization// Optionally require connections to be made via HTTPSif ($HTTPS_required &amp;&amp; $_SERVER['HTTPS'] != 'on') &#123; $response['code'] = 2; $response['status'] = $api_response_code[$response['code']]['HTTP Response']; $response['data'] = $api_response_code[$response['code']]['Message']; // Return Response to browser. This will exit the script. deliver_response($_GET['format'], $response);&#125;// Optionally require user authenticationif ($authentication_required) &#123; if (empty($_POST['username']) || empty($_POST['password'])) &#123; $response['code'] = 3; $response['status'] = $api_response_code[$response['code']]['HTTP Response']; $response['data'] = $api_response_code[$response['code']]['Message']; // Return Response to browser deliver_response($_GET['format'], $response); &#125; // Return an error response if user fails authentication. This is a very simplistic example // that should be modified for security in a production environment elseif ($_POST['username'] != 'foo' &amp;&amp; $_POST['password'] != 'bar') &#123; $response['code'] = 4; $response['status'] = $api_response_code[$response['code']]['HTTP Response']; $response['data'] = $api_response_code[$response['code']]['Message']; // Return Response to browser deliver_response($_GET['format'], $response); &#125;&#125;// --- Step 3: Process Request// Method A: Say Hello to the APIif (strcasecmp($_GET['method'], 'hello') == 0) &#123; $response['code'] = 1; $response['status'] = $api_response_code[$response['code']]['HTTP Response']; $response['data'] = 'Hello World';&#125;// --- Step 4: Deliver Response// Return Response to browserdeliver_response($_GET['format'], $response);?&gt; 对于apache服务器，需要修改一下.htaccess文件，该成下面的形式123456# Turn on the rewrite engineOptions +FollowSymlinksRewriteEngine on # Request routingRewriteRule ^([a-zA-Z_-]*)\.(html|json|xml)?$ index.php?method=$1&amp;format=$2 [nc,qsa] 其中RewriteRule部分是指将[a-zA-Z_-]*匹配到的字符串赋值到 $1 的位置，将(html|json|xml)?匹配的字符串赋值到 $2 的位置，访问 hello.json 就相当于访问 index.php?method=hello&amp;format=json。在sae中，使用的服务器也是apache，不过它不能更改.htaccess文件，而是需要修改config.yaml文件，如果使用git方式管理代码，默认是不会将该文件下载到本地的，所以推荐使用svn方式管理代码，下面是具体配置12345name: appnameversion: 1handle: -rewrite: if(!is_dir() &amp;&amp; !is_file() &amp;&amp; path ~ "^([a-zA-Z_-]*).(html|json|xml)?$") goto "index.php?method=$1&amp;format=$2" 信息存储–memcache这里存储没有使用数据库，而是使用的memcache，主要是信息只是短期存储，并且数据量不会太大。官方对memcache的使用解释的并不是十分详细，这里主要参考了 这篇文章 ，下面是具体的代码：123456789101112131415161718192021222324252627282930313233343536&lt;?php //连接 $mem = memcache_init(); //保存数据 $mem-&gt;set('key1', 'This is first value', 0, 60); $val = $mem-&gt;get('key1'); echo "Get key1 value: " . $val . "&lt;br /&gt;"; //替换数据 $mem-&gt;replace('key1', 'This is replace value', 0, 60); $val = $mem-&gt;get('key1'); echo "Get key1 value: " . $val . "&lt;br /&gt;"; //保存数组 $arr = array('aaa', 'bbb', 'ccc', 'ddd'); $mem-&gt;set('key2', $arr, 0, 60); $val2 = $mem-&gt;get('key2'); echo "Get key2 value: "; print_r($val2); echo "&lt;br /&gt;"; //删除数据 $mem-&gt;delete('key1'); $val = $mem-&gt;get('key1'); echo "Get key1 value: " . $val . "&lt;br /&gt;"; //清除所有数据 $mem-&gt;flush(); $val2 = $mem-&gt;get('key2'); echo "Get key2 value: "; print_r($val2); echo "&lt;br /&gt;"; //关闭连接 $mem-&gt;close(); 其中$mem-&gt;set的第四个参数就是数据的有效期，单位是秒。 ajax跨域访问为了使服务端允许客户端的ajax跨域请求，需要在php代码中加上下面的代码。1header('Access-Control-Allow-Origin:*'); 前端使用jquery 的 $.ajax 发送ajax请求，在IE10及以上的版本中，工作正常，但是IE9及以下的版本无法正确访问，找了半天也没有找到好的解决方法。索性就在sae上放了一个同样的应用首页，如果使用IE9及以下的浏览器，可以访问那个页面。]]></content>
      <categories>
        <category>应用</category>
      </categories>
      <tags>
        <tag>应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C】Storage Class]]></title>
    <url>%2F2015%2F10%2F26%2F%E3%80%90C%E3%80%91Storage-Class%2F</url>
    <content type="text"><![CDATA[什么是Storage ClassStorage Class翻译成中文为存储类（总感觉翻译成汉语不太好），用来修饰C中变量和函数。如果没有显式的指定storage class，会使用默认值。它的作用主要以下几点： 决定变量存储的位置。每个变量都需要一定的空间来存储，经常用到的存储单元就是内存，除了内存之外，CPU中的寄存器也可以存储变量，而且一般来说寄存器的访问速度要远远大于内存的访问速度。 决定变量的生命周期。 决定变量的可见级别。 决定变量是否初始化。 Storage Class 说明符（Specifiers）下面列出了5中Storage Class的说明符，但是只有前四种是真正意义上的说明符，typedef只是为了语义上的方便，才将其称为一个storage class的说明符。 auto register static extern typedef 需要注意的是我们在一个声明中，我们至多使用一个storage class的说明符。如果没有显示使用说明符，则会使用以下的默认规则： 在函数内部声明的变量默认使用 auto 说明符 在函数内部声明的函数默认使用 extern 说明符 在函数外部声明的变量和函数默认使用static说明符，并且具有外部链接（external linkage） 具有外部链接的变量和函数可以作用于程序中的所有文件，单纯使用static的变量和函数具有文件作用域（File Scope），它们只有内部链接（internal linkage），只能作用于当前文件。局部变量没有链接，它们只作用于定义的代码块。 Storage Class 类别（Type）根据上面所说，在C中一共有四类storage class： Automatic Storage Class Register Storage Class Static Storage Class External Storage Class 下面是详细介绍 Auto Storage Class在代码块或者函数中，使用auto声明的变量属于automatic storage class，如果没有显示调用storage class说明符，那么auto就是其默认值。auto storage class的变量属于局部变量，只在其定义的代码块或者函数中起作用，当离开代码块或者函数执行完毕之后就会被销毁（destroyed）。下面是一个示例：123456789101112131415#include &lt;stdio.h&gt;int main( )&#123; auto int i = 1; &#123; auto int i = 2; &#123; auto int i = 3; printf ( "\n%d ", i); &#125; printf ( "%d ", i); &#125; printf( "%d\n", i);&#125; 输出结果为：3 2 1在上面的代码中我们定义3个相同名称的变量i，并且成功执行。这是因为这三个变量的作用域不同，并且8-11行代码块中的i覆盖了6-13行中对于i的定义（类似于局部变量覆盖全局变量），即程序执行时会先在当前代码块的作用域中查找相应变量，如果找不到再去其属于的更大范围的代码块查找，直至找到或者报错。需要注意的地方是automatic storage class变量并不会被初始化，在使用之前要手动为其赋初值，否则程序可能会出现意想不到的结果。 Register Storage Class使用register声明的变量属于Register Storage Class。Register Storage Class类型的变量可以看作是一种特殊形式的automatic变量，Automatic变量是在内存中分配存储空间的，但是对于大多数的电脑来说，数据的访问速度要小于CPU的计算速度，因此CPU会有一定的空间来缓存少量的数据，以加快访问数据的速度，CPU的这些存储单元就叫做寄存器（Register）。&emsp;&emsp;一般来说编译器会决定何时将数据存储到CPU的寄存器中。不过C同时提供了一种方式建议编译器将变量放到寄存器中，这种方式就是register storage class，之所以说建议是因为编译器并不一定会将register变量放入到寄存器中，这个和具体的实现以及寄存器的空间大小有关系，但是大多数情况中只要显示调用了register说明符，编译器就会在寄存器上为其分配空间。同时，并不是所有类型的变量都可以放到编译器中，这个也和具体的编译器实现有关。&emsp;&emsp;同时需要注意的是，register变量不能使用取地址符’&amp;’，因为按照标准它是存储在寄存器中的，并没有内存的地址，所以下面的代码是编译不过的12345678#include &lt;stdio.h&gt;int main()&#123; register int i = 1; int *p = &amp;i; //error: address of register variable requested printf("Value of i: %d\n", *p);&#125; register变量同样没有初始值。另外需要说明的是并不是使用了register变量就一定会比使用automatic变量快，比如你定义了很多的register的变量，导致寄存器的空间不够使用，那么为了使其他register变量可以正常使用，就不得不将一些寄存器的值交换到内存中，而这个交换过程往往会浪费大量的时间。同时，自定义register变量的使用可能会影响编译器对于寄存器使用的默认行为，例如存储表达式求值的临时值。所以应该慎重使用register变量。 Static Storage Classstatic用来声明static storage class的变量。static可以修饰局部变量或者全局变量，当修饰局部变量时，static并不改变该变量的作用域，但是会一直保存该局部变量的值，直至程序结束。当修饰全局变量或者函数时，static会限定该变量的作用域为当前文件（具有内部链接），其他文件并不能使用该变量或者函数。下面是一个示例：12345678910111213141516#include &lt;stdio.h&gt;static int gInt = 1;static void staticDemo()&#123; static int i; printf("%d ", i); i++; printf("%d\n", gInt); gInt++;&#125;int main()&#123; staticDemo(); staticDemo();&#125; 输出结果为：0 11 2当第一次调用staticDemo时，会首先初始化static变量，如果手动设置了初始值，那么就将其值设为指定的值，否则初始为0，程序打印出0和1，但是当执行完staticDemo时，变量i并没有别销毁。当第二次调用staticDemo时，即便执行到第5行代码，编译器也不会重新初始化i了，而是使用已经创建的i变量。因此可以总结两点：（1）static变量初始值为0（2）在其生命周期中只会被初始化一次。 External Storage Classextern用来声明external storage class的变量，它的作用是：告诉编译器这个变量或者函数已经在其他地方定义过了，这里无需再定义了，直接使用即可。下面简单说明一下声明（declaration）和定义（definition）的区别：声明是告诉编译器变量或者函数的一些基本信息，而定义是为这些变量或者函数分配存储空间（详细的的可以看上一篇文章），同一个名称的变量或者函数可以声明很多次，但是只能定义一次。&emsp;&emsp;对于全局变量或者函数来说，如果不加static说明符，那么变量或者函数就可以被程序中的所有文件使用，而extern就是实现这一功能的关键。如果想在文件A中使用文件B中的变量i，那么就需要在A中使用extern声明i，下面是一个例子：123456789A.c#include &lt;stdio.h&gt;extern int i;int main() &#123; printf("the i is %d\n", i);&#125;B.cint i = 5; 注意使用extern只是声明一个变量，并没有为其分配存储空间，所以extern int i = 5的写法是错误的，如果不加extern，那么就是对于i的定义。external变量也是会初始化的，其初始值为0。对于函数声明（不是定义）来说，其默认storage class说明符就是extern，即void a();和extern void a();是等同的。 参考文章 C Storage Classes and Storage Class SpecifiersStorage Class and Scope]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C】变量定义（Definition）与声明（Declaration）]]></title>
    <url>%2F2015%2F10%2F25%2F%E3%80%90C%E3%80%91%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%EF%BC%88Definition%EF%BC%89%E4%B8%8E%E5%A3%B0%E6%98%8E%EF%BC%88Declaration%EF%BC%89%2F</url>
    <content type="text"><![CDATA[含义 声明（Declaration）*:告诉编译器变量或者函数的信息，例如变量的类型（type）、命名（name） 定义（Definition）*: 为变量或者函数分配存储空间 变量（Variable)对于局部变量（定义在函数或者代码块中的），声明和定义可以认为是等同的，因为声明变量的同时会为变量分配存储单元，即便在严格意义上认为局部变量的声明和定义是不同的，但是两个过程是不可拆分的，即无法只声明一个局部变量。对于全局变量（定义在函数外）来说，声明和定义是要做区别的，诸如int i, static int i这样的代码，变量的声明和定义是在一起的，即执行完代码之后，变量已经有了对应的存储单元。但是如果加上 extern 修饰符extern int i，此时就仅仅是对变量的声明了，这个过程是不分配存储空间的， extern 会告诉编译器我的定义在其它的地方，你先使用我这个声明，等到编译时再链接到我的定义。 函数（functions）int a(int i);上面的只是声明（declare）了一个函数a，该声明描述了函数a的返回值类型（return type），函数命名（name），参数（parameters）的个数以及类型。当我们声明完变量a之后，编译器已经知道了函数a信息，但是并没有为函数分配空间，当我们为函数加上函数体（body）之后，函数才真正的被定义（define），如下，此时函数才有了对应的存储单元,执行该函数会返回1.123int a(int i) &#123; return 1;&#125; 在程序中，对同一个函数，可以有多次的声明（没有函数体），但只能有一次的定义（带函数体部分）。需要注意的一点是函数声明默认的存储类（storage class）是 extern 的，但函数的定义并不是。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HTML5】图片预加载]]></title>
    <url>%2F2015%2F06%2F22%2F%E3%80%90HTML5%E3%80%91%E5%9B%BE%E7%89%87%E9%A2%84%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[在HTML5中，我们可以使用drawImage方法在canvas上进行画图操作，其基本代码如下：12345var canvas = document.getElementById("canvas");var context = canvas.getContext("2d");var image = new Image();image.src = "images/01.jpg";context.drawImage(image, 0, 0); 不过我们会发现这样写是无法显示出图片的，因为图片并没有加载完全，我们就调用了drawImage方法，我们可以使用img的onload方法，使图片加载完全后在执行drawImage操作，代码如下12345var image = new Image();image.src = "images/01.jpg";image.onload = function() &#123; context.drawImage(image, 0, 0);&#125; 或者使用&lt;img&gt;标签先加载图片&lt;img src=&quot;images/01.jpg&quot; style=&quot;display: none&quot; id=&quot;image&quot;&gt;然后使用getElementById来获得图片对象var image = document.getElementById(&#39;image&#39;);但是在图片较多的情况下，使用上面两种方式都不是太优雅，我们可以使用下面的方法，等待所有图片加载完全后，再执行其他操作1234567891011121314151617181920212223242526document.addEventListener("DOMContentLoaded", loadImages, true);var images = new Array(3), imageNums = 0;function loadImages() &#123; for (var i = 0; i &lt; images.length; i++) &#123; images[i] = new Image(); images[i].addEventListener("load", trackProcess, true); images[i].src = "images/01.jpg"; &#125;&#125;function trackProcess() &#123; imageNums++; if (imageNums = images.length) &#123; drawImages(); &#125;&#125;function drawImages() &#123; var canvas = document.getElementById("canvas"); var context = canvas.getContext("2d"); for (var i = 0; i &lt; images.length; i++) &#123; context.drawImage(images[i], 200 * i, 0); &#125;&#125; 参考文章: Preloading Images]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
</search>
