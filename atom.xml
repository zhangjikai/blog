<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jk&#39;s Blog</title>
  
  <subtitle>No Start No End</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.zhangjikai.com/"/>
  <updated>2019-09-08T07:04:48.526Z</updated>
  <id>http://blog.zhangjikai.com/</id>
  
  <author>
    <name>Zhang Jikai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Java】 JVM 如何保存 Java 对象</title>
    <link href="http://blog.zhangjikai.com/2019/09/08/%E3%80%90Java%E3%80%91-JVM-%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98-Java-%E5%AF%B9%E8%B1%A1/"/>
    <id>http://blog.zhangjikai.com/2019/09/08/【Java】-JVM-如何保存-Java-对象/</id>
    <published>2019-09-08T06:59:01.000Z</published>
    <updated>2019-09-08T07:04:48.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要讲解一下在 JVM 中如何保存 Java 对象以及 Java 对象指针压缩相关的东西。</p><h2 id="JVM-体系结构"><a href="#JVM-体系结构" class="headerlink" title="JVM 体系结构"></a>JVM 体系结构</h2><p><img src="/images/jvm-java/jvm体系.gif" alt></p><blockquote><p>图片摘自 <a href="https://www.artima.com/insidejvm/ed2/jvm2.html" target="_blank" rel="noopener">https://www.artima.com/insidejvm/ed2/jvm2.html</a></p></blockquote><p>上图是 JVM 规范中定义的体系结构（这个只是定义的规范，实际的  JVM 实现中可能与这个结构会有差异），这里我们主要看下运行时数据区（runtime data areas）的内容，以下摘自 <a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf" target="_blank" rel="noopener">The Java® Virtual Machine Specification Java SE 8 Edition</a></p><ul><li>PC register -  If that method is not native , the pc register contains the address of the Java Virtual Machine instruction currently being executed.</li><li>Java stacks - A Java Virtual Machine stack is analogous to the stack of a conventional language such as C: it holds local variables and partial results, and plays a part in method invocation and return.</li><li>Heap - The heap is the run-time data area from which memory for all class instances and arrays is allocated.</li><li>Method area -  The method area is analogous to the storage area for compiled code of a conventional language or analogous to the “text” segment in an operating system process. It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods used in class and instance initialization and interface<br>initialization.</li><li>Native method stacks - An implementation of the Java Virtual Machine may use conventional stacks, colloquially called “C stacks,” to support native methods (methods written in a language other than the Java programming language). Native method stacks may also be used by the implementation of an interpreter() for the Java Virtual Machine’s<br>instruction set in a language such as C。</li></ul><p>堆和方法区是所有类共享的，其中堆主要存储对象实体，方法区存储的信息比较多，主要包括下面几类：</p><ul><li>类的基本类型信息<ul><li>类型的全限定名</li><li>直接超类的全限定名（除了 Object）</li><li>是类还是接口</li><li>访问修饰符</li></ul></li></ul><ul><li>该类的常量池<ul><li>虚拟机会为每个转载的类型维护一个常量池</li></ul></li><li>字段信息<ul><li>字段名称</li><li>字段类型</li><li>字段修饰符（public，private，protected，static，final，volatile，transient）</li></ul></li><li>方法信息<ul><li>方法名</li><li>方法的返回值类型或者void</li><li>方法的参数数量和类型（按照声明顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，natvie，abstract）</li><li>如果不是abstract和native方法，还会保存下面的信息<ul><li>方法的字节码</li><li>操作数栈和局部变量区的大小</li><li>异常表</li></ul></li></ul></li><li>类（静态）变量<ul><li>静态常量和非静态常量的处理方式不同，每个类都会把用到的其他类的静态常量拷贝到自己的常量池中。</li></ul></li><li>指向 ClassLoader 类的引用。</li><li>指向 Class 类的引用，对于每个被装载的类型，JVM 都会为其创建一个 java.lang.Classs 类的实例（该实例存在heap中），并且JVM 会以某种方式将该实例和方法区中对应的类型关联起来。</li></ul><h2 id="对象如何保存"><a href="#对象如何保存" class="headerlink" title="对象如何保存"></a>对象如何保存</h2><p>我们知道一个Java对象包含两部分内容，字段和方法，每个对象的字段值都可能不同，但是所用的方法都是一样的，如果每个对象都保存一套方法定义，显然会浪费很多的空间。所以方法定义相关的都放到了方法区，对象只保存自己的实例数据和指向方法定义的指针。下图是对象保存的一种方式，也是 Hotspot 虚拟机采用的方式，对象在堆中只保存实例的数据，同时会有一个指针指向方法区中的一个方法表（和 c++ 中的 <a href="https://en.wikipedia.org/wiki/Virtual_method_table" target="_blank" rel="noopener">Virtual method table</a> 类似）。方法表保存两个部分：指向类数据的指针和执行各个方法的指针。这里将类数据和方法分开存储，是为了更加快速的找到方法。每个类都会对应一个方法表，这种实现方式会稍微浪费一些内存，但是会获得更好的性能。</p><p><img src="/images/jvm-java/对象存储.gif" alt></p><blockquote><p>图片摘自 <a href="https://www.artima.com/insidejvm/ed2/jvm6.html" target="_blank" rel="noopener">https://www.artima.com/insidejvm/ed2/jvm6.html</a></p></blockquote><p>我们知道对象是有继承关系的，如果子类没有覆写父类的方法，那么子类会指向父类的中的方法。</p><p><img src="/images/jvm-java/method-demo.gif" alt></p><blockquote><p>图片摘自 <a href="https://www.artima.com/insidejvm/ed2/linkmod12.html" target="_blank" rel="noopener">https://www.artima.com/insidejvm/ed2/linkmod12.html</a></p></blockquote><h2 id="HotSpot-内存结构"><a href="#HotSpot-内存结构" class="headerlink" title="HotSpot 内存结构"></a>HotSpot 内存结构</h2><p>上面主要是 Java 虚拟机规范中定义的规范，每种虚拟机实现的方式可能不太相同，这里我们主要看下 HotSpot 虚拟机的实现，后面的内容都是基于 HotSpot 虚拟机。<br>在 Java8 中，HotSpot VM 移除了永生代（PermGen），添加了元数据空间（Metaspace），元空间不使用虚拟机内存，而是使用本地内存。元空间主要和方法区对应，存储类的元数据和常量池（String常量的实例存在堆中）等信息。</p><p><img src="/images/jvm-java/hotspot.jpg" alt></p><blockquote><p>图片摘自 <a href="http://java-latte.blogspot.com/2014/03/metaspace-in-java-8.html" target="_blank" rel="noopener">http://java-latte.blogspot.com/2014/03/metaspace-in-java-8.html</a></p></blockquote><h2 id="Ordinary-Object-Pointer-OOP"><a href="#Ordinary-Object-Pointer-OOP" class="headerlink" title="Ordinary Object Pointer (OOP)"></a>Ordinary Object Pointer (OOP)</h2><p>在 JVM 中 Java 对象使用 OOP（Ordinary Object Pointer） 来表示，格式如下图所示。</p><p><img src="/images/jvm-java/oop.png" alt></p><p>OOP 主要包含两个部分：对象头和实例数据。对象头主要包含四个部分：</p><ul><li>Mark Word - 会存储对象的多种标记信息，例如哈希值、GC标记、锁等信息</li><li>Klass Word - 主要指向类的元数据</li><li>32-bit length word - 只有数组对象才有，记录数组的长度</li><li>32-bit gap - Java 是 8 字节对齐的（关于为什么要进行内存对齐，可以参考 <a href="http://blog.zhangjikai.com/2015/11/28/%E3%80%90C%E3%80%91alignment/">这篇文章</a>），该字段主要用做对齐填充用</li></ul><p>对象头后面就是实例数据，可能是基本数据，也可能是指向其他对象的引用。如果实例数据的大小不是 8 的倍数，那么也会插入一些填充的数据来对齐。对于继承的情况，会先存放父类的实例数据，然后再存放子类的实例数据，如下图所以：</p><p><img src="/images/jvm-java/instance.png" alt></p><p>Mark word、Klass word 以及对象的引用大小和 JVM 位数相关，32位 JVM 是 4 字节大小，64 位 JVM 是 8 字节大小。对于引用来说，4字节来寻址的话的最多可以表示 2<sup>32</sup>，也就是做大只能支持 4GB 的内存，一般来说4GB 的内存是不大够用的，所以我们常用的是 64 位的 JVM，但是使用 64 位 JVM 带来的一个问题就是引用从 4 个字节变成了 8 个字节，也就是会多占一倍的空间，这样会导致更加频繁的 GC 周期，导致性能变差。</p><h2 id="Compressed-OOPs"><a href="#Compressed-OOPs" class="headerlink" title="Compressed OOPs"></a>Compressed OOPs</h2><p>我们使用压缩的 OOP 来实现在64位的 JVM 上使用32位大小的引用来寻址，这个方式主要是基于 Java 对象是 8 字节对齐，即后三位全部为 0，也就是在当前的对象引用中后三位实际上是没有用到的。基于上面的逻辑，我们就可以做一下优化，将当前32位值的表示为第 4-35 位的值，也就是实际的值相当于左移了三位，如下图所示。这样我们就有35位来寻址，内存最大就可以支持到 32GB。</p><p><img src="/images/jvm-java/compress.jpg" alt></p><blockquote><p>图片摘自 <a href="https://www.baeldung.com/jvm-compressed-oops" target="_blank" rel="noopener">https://www.baeldung.com/jvm-compressed-oops</a></p></blockquote><p>开启了压缩之后，堆中 OOP 里的下列字段会被压缩：</p><ul><li>每个对象的 Kclass 字段（Mark不会压缩）</li><li>指向其他 OOP 的引用</li><li>OOP 数组中的每个元素</li></ul><p>下面是 Integer 对象在不同情况下占的内存大小，因为 Java 是 8 字节对齐，所以在64位 VM 上未开启压缩时，Integer 还要加上一个 32bit 填充，即总的大小是 192 bit。</p><p><img src="/images/jvm-java/compress-demo.jpg" alt></p><blockquote><p>图片摘自 <a href="https://www.javacodegeeks.com/2016/05/compressedoops-introduction-compressed-references-java.html" target="_blank" rel="noopener">https://www.javacodegeeks.com/2016/05/compressedoops-introduction-compressed-references-java.html</a></p></blockquote><p>我们可以在启动 Java 程序时使用 <code>-XX:+UseCompressedOops</code> 来开启压缩，Java7之后，如果最大内存小于32G，会自动开启 OOP 压缩。如果想在超过 32G 内存的情况下使用压缩，可以通过指定Java 对象对齐的字节数来实现 <code>-XX:ObjectAlignmentInBytes</code>，该值必须在 8 到 256 之间，并且是 2 的指数倍。假设指定为 16，那么就可以使用 64G 的内存，但是由于对齐造成的内存浪费也会更多。</p><p>另外在 Java11 中添加的 ZGC 垃圾回收器必须使用 64 位的指针，所以它不支持压缩的OOP。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.artima.com/insidejvm/ed2/" target="_blank" rel="noopener">Inside the Java Virtual Machine</a></li><li><a href="https://www.baeldung.com/jvm-compressed-oops" target="_blank" rel="noopener">Compressed OOPs in the JVM</a></li><li><a href="https://www.infoq.com/articles/Introduction-to-HotSpot/" target="_blank" rel="noopener">Getting Started with HotSpot and OpenJDK</a></li><li><a href="http://psy-lob-saw.blogspot.com/2013/05/know-thy-java-object-memory-layout.html" target="_blank" rel="noopener">Know Thy Java Object Memory Layout</a></li><li><a href="https://wiki.openjdk.java.net/display/HotSpot/CompressedOops" target="_blank" rel="noopener">CompressedOops</a></li><li><a href="https://www.javacodegeeks.com/2016/05/compressedoops-introduction-compressed-references-java.html" target="_blank" rel="noopener">CompressedOops: Introduction to compressed references in Java</a></li><li><a href="http://java-latte.blogspot.com/2014/03/metaspace-in-java-8.html" target="_blank" rel="noopener">Metaspace in Java 8</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文主要讲解一下在 JVM 中如何保存 Java 对象以及 Java 对象指针压缩相关的东西。&lt;/p&gt;
&lt;h2 id=&quot;JVM-体系结构&quot;&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.zhangjikai.com/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://blog.zhangjikai.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>【Java 8】Lambda 表达式</title>
    <link href="http://blog.zhangjikai.com/2017/12/08/%E3%80%90Java%208%E3%80%91Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://blog.zhangjikai.com/2017/12/08/【Java 8】Lambda 表达式/</id>
    <published>2017-12-08T13:07:58.000Z</published>
    <updated>2019-09-08T06:53:07.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Lambda(λ) 表达式是一种在 <em>被调用的位置</em> 或者 <em>作为参数传递给函数的位置</em> <strong>定义匿名函数对象</strong> 的简便方法。下面是关于 Lambda 表达式的几个点：</p><ul><li>匿名（Anonymous） - 不像其他普通方法那样具有名字</li><li>函数（Function） -  Lambda 表达式不像普通方法那样属于某个特定的类，它是独立于类存在的。但是和方法一样，Lambda 表达式有参数列表、函数主体和返回值，还可能有可以抛出的异常列表。</li><li>传递（Passed around）- Lambda 表达式可以作为参数传递给方法或者存储在变量中。</li><li>简洁（Concise）- 无需像匿名类那样写很多的模板代码。</li></ul><a id="more"></a><p>下面是一个示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calculator c = (a, b) -&gt; a + b;</span><br><span class="line">        System.out.println(c.cal(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        c = (a, b) -&gt; a * b;</span><br><span class="line">        System.out.println(c.cal(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Lambda-形式"><a href="#Lambda-形式" class="headerlink" title="Lambda 形式"></a>Lambda 形式</h2><p>Lambda 表达式的基本形式如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(argument list) -&gt; code</span><br></pre></td></tr></table></figure></p><p>下面是一个例子：</p><p><img src="/images/lambda/形式.png" alt></p><p>如上所示： Lambda 表达式包含三个部分：</p><ul><li>参数列表（A list of parameters） - 上图中为 <code>(Apple a1, Apple a2)</code></li><li>箭头（An arrow） - 把参数列表和 Lambda 主体分隔开</li><li>Lambda 主体（The body of the lambda） - 上图中为 <code>a1.getWeight().compareTo(a2.getWeight())</code>，该 Lambda 主体会返回 compareTo 的结果。</li></ul><p>Lambda 函数的主体可以是表达式（expression）或者语句（statement），所以 Lambda 函数返回值有下面两种情况：</p><ul><li>如果 Lambda 主体为表达式，那么 Lambda 函数的返回值就是表达式的计算值</li><li>如果 Lambda 主体为语句，那么 Lambda 返回值就是语句的返回值</li></ul><p>关于语句和表达式的区别，可以参考 <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/expressions.html" target="_blank" rel="noopener">这篇文章</a>，这里简单说一下：假设有一条语句 <code>int c = a + b;</code>，那么表达式就是指 <code>c = a + b</code>，即不包含 <code>int</code> 和 <code>;</code>，每个表达式都会有一个计算值（void 也算一种特殊的计算值）。</p><p>所以细分一下，Lambda 表达式有两种形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br></pre></td></tr></table></figure></p><p>和（使用大括号）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; &#123;statements&#125;</span><br></pre></td></tr></table></figure></p><p>下面是 Lambda 表达式的几个例子：</p><p><img src="/images/lambda/demo.png" alt></p><table><thead><tr><th style="text-align:left">使用场景</th><th style="text-align:left">使用示例</th></tr></thead><tbody><tr><td style="text-align:left">boolean 表达式</td><td style="text-align:left"><code>(List&lt;String&gt; list) -&gt; list.isEmpty()</code></td></tr><tr><td style="text-align:left">创建对象</td><td style="text-align:left"><code>() -&gt; new Apple(10)</code></td></tr><tr><td style="text-align:left">Consuming from an object</td><td style="text-align:left"><code>(Apple a) -&gt; { System.out.println(a.getWeight()); }</code></td></tr><tr><td style="text-align:left">Select/extract from an object</td><td style="text-align:left"><code>(String s) -&gt; s.length()</code></td></tr><tr><td style="text-align:left">合并两个值</td><td style="text-align:left"><code>(int a, int b) -&gt; a * b</code></td></tr><tr><td style="text-align:left">比较两个对象</td><td style="text-align:left"><code>(Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight())</code></td></tr></tbody></table><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>我们可以在函数式接口 （Functional interface）中使用 Lambda 表达式。简单来说，函数式接口就是只定义一个抽象方法的接口（接口中可以包含额外的 default 方法）。例如 Comparator 和 Runnable 都是函数式接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们一般在接口定义中加上 <code>@FunctionalInterface</code> 注解来声明该接口是一个函数式接口。例如下面的形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当一个接口通过 <code>FunctionalInterface</code> 被声明为函数式接口时，编译器将会检查接口的合法性，如果接口不合法，会报编译错误。</p><p>现在考虑一个问题，Lambda 表达式是如何匹配函数式接口的呢？假设我们有一个如下定义的函数式接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是使用 lambda 表达式以及匿名类来创建 Calculator 对象的示例代码。在下面的代码中对象 c 和 c2 的实现是等价的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Calculator c = (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; a + b;</span><br><span class="line"></span><br><span class="line">    Calculator c2 = <span class="keyword">new</span> Calculator() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的例子中，我们可以看到 <strong>Lambda 表达式</strong> 是和函数式接口中的 <strong>抽象方法</strong> 进行匹配的，其中 Lambda 表达式中参数匹配 cal 方法的参数，Lambda body 的内容作为抽象方法的具体实现，Lambda body 的计算值作为方法的返回值。这也是为什么要求函数式接口只能有一个抽象方法的原因。</p><p>函数式接口中抽象方法的签名（signature）描述了 Lambda 表达式的签名，因为 Lambda 表达式并没有名字，所以这里的签名只关注三个方面：<strong>方法参数</strong> 、<strong>返回值</strong> 以及 <strong>异常声明</strong>。我们将抽象方法所描述的 Lambda 形式称为函数描述符（function descriptor）。在 Calculator 类中，cal 方法对应的函数描述符为 <code>(int, int) -&gt; int</code>，即接受两个 int 类型作为参数，表达式的计算值为 int 类型。所以下面的 Lambda 表达式都是合法的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; a</span><br><span class="line">(<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; a + b</span><br><span class="line">(<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>如果 Lambda 表达式抛出一个可检查异常，那么对应的抽象方法所声明的 throws 语句也要与之匹配。看下面的一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ThrowExceptionInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里编译时会报 Unhandled Exception：java.io.Exception</span></span><br><span class="line">        ThrowExceptionInterface t = (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实也很好理解，Lambda body 中的内容会作为抽象方法的具体实现，在方法中抛出了异常但是方法声明中却没有相关的异常声明，编译器肯定要报错的。</p><p>另外还有一个特殊的 void 兼容规则。如果抽象方法的返回值为 void，即对应的函数描述符为 <code>(T) -&gt; void</code>，那么对于 body 为 <strong>语句表达式（statement expression）</strong> 的 Lambda 表达式，只要求参数列表匹配即可。看下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">VoidInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">voidTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 这里 a++ 返回一个 int，但是和 void 兼容</span></span><br><span class="line">        VoidInterface v = (<span class="keyword">int</span> a) -&gt; a++;</span><br><span class="line">        <span class="comment">// 下面的代码会报错，因为 a-1 不是一个语句表达式</span></span><br><span class="line">        v = (<span class="keyword">int</span> a) -&gt; a-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里说一下语句表达式:</p><blockquote><p>The term “statement expression” or “expression statement” refers to expressions that are also allowed to be used as a statement.</p></blockquote><p>语法表达式有下面四类：</p><ul><li>Assignment expressions</li><li>Any use of ++ or –</li><li>Method invocations</li><li>Object creation expressions</li></ul><h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><p>Lambda 表达式本身并不包含它是实现哪个函数式接口的信息，编译器会根据 Lambda 表达式所处的上下文（context）环境来推断 Lambda 表达式的目标类型（target type），例如对于下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calculator c = (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; a + b;</span><br></pre></td></tr></table></figure></p><p>Lambda 表达式会赋值给 Calculator 对象，那么该 Lambda 表达式对应的目标类型就是 Calculator 接口，该接口中的 cal 方法对应的函数描述符为 <code>(int, int) -&gt; int</code>，这个和 <code>(int a, int b) -&gt; a + b</code> 可以匹配，这样就完成了类型检查。下图是一个完整的例子：</p><p><img src="/images/lambda/类型检查.png" alt></p><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>在上面我们提到编译器会根据上下文环境推断出与 Lambda 表达式对应的函数式接口，这意味着编译器同样可以根据接口中抽象方法的函数函数描述符推断出 Lambda 表达式的签名，这样编译器就可以知道 Lambda 表达式的参数类型，这样就可以省略 Lambda 表达式中的参数类型，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Calculator c = (a, b) -&gt; a + b;</span><br><span class="line"><span class="comment">// 当只有一个参数时，可以省略掉 ()</span></span><br><span class="line">VoidInterface v = a -&gt; a++;</span><br></pre></td></tr></table></figure></p><h2 id="Java-8-中的函数式接口"><a href="#Java-8-中的函数式接口" class="headerlink" title="Java 8 中的函数式接口"></a>Java 8 中的函数式接口</h2><p>在 Java 8 中定义了一些函数式接口，位于 <code>java.util.function</code> 包下，下面是这些接口的总览：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">+--- BiConsumer.java</span><br><span class="line">+--- BiFunction.java</span><br><span class="line">+--- BinaryOperator.java</span><br><span class="line">+--- BiPredicate.java</span><br><span class="line">+--- BooleanSupplier.java</span><br><span class="line">+--- Consumer.java</span><br><span class="line">+--- DoubleBinaryOperator.java</span><br><span class="line">+--- DoubleConsumer.java</span><br><span class="line">+--- DoubleFunction.java</span><br><span class="line">+--- DoublePredicate.java</span><br><span class="line">+--- DoubleSupplier.java</span><br><span class="line">+--- DoubleToIntFunction.java</span><br><span class="line">+--- DoubleToLongFunction.java</span><br><span class="line">+--- DoubleUnaryOperator.java</span><br><span class="line">+--- Function.java</span><br><span class="line">+--- IntBinaryOperator.java</span><br><span class="line">+--- IntConsumer.java</span><br><span class="line">+--- IntFunction.java</span><br><span class="line">+--- IntPredicate.java</span><br><span class="line">+--- IntSupplier.java</span><br><span class="line">+--- IntToDoubleFunction.java</span><br><span class="line">+--- IntToLongFunction.java</span><br><span class="line">+--- IntUnaryOperator.java</span><br><span class="line">+--- LongBinaryOperator.java</span><br><span class="line">+--- LongConsumer.java</span><br><span class="line">+--- LongFunction.java</span><br><span class="line">+--- LongPredicate.java</span><br><span class="line">+--- LongSupplier.java</span><br><span class="line">+--- LongToDoubleFunction.java</span><br><span class="line">+--- LongToIntFunction.java</span><br><span class="line">+--- LongUnaryOperator.java</span><br><span class="line">+--- ObjDoubleConsumer.java</span><br><span class="line">+--- ObjIntConsumer.java</span><br><span class="line">+--- ObjLongConsumer.java</span><br><span class="line">+--- Predicate.java</span><br><span class="line">+--- Supplier.java</span><br><span class="line">+--- ToDoubleBiFunction.java</span><br><span class="line">+--- ToDoubleFunction.java</span><br><span class="line">+--- ToIntBiFunction.java</span><br><span class="line">+--- ToIntFunction.java</span><br><span class="line">+--- ToLongBiFunction.java</span><br><span class="line">+--- ToLongFunction.java</span><br><span class="line">+--- UnaryOperator.java</span><br></pre></td></tr></table></figure></p><h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p>用来测试对象是否满足某种条件。该接口定义了一个 test 方法，接受一个泛型对象（T），并返回测试结果（boolean），函数描述符为 <code>T -&gt; boolean</code>。下面是一个使用示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(T t, Predicate&lt;T&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.test(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPredicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String text = <span class="string">"111"</span>;</span><br><span class="line">    System.out.println(judge(text, s -&gt; s != <span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是 Predicate 接口的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a predicate (boolean-valued function) of one argument.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Evaluates this predicate on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if the input argument matches the predicate,</span></span><br><span class="line"><span class="comment">     * otherwise false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed predicate that represents a short-circuiting logical</span></span><br><span class="line"><span class="comment">     * AND of this predicate and another.  When evaluating the composed</span></span><br><span class="line"><span class="comment">     * predicate, if this predicate is false, then the other</span></span><br><span class="line"><span class="comment">     * predicate is not evaluated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a predicate that represents the logical negation of this</span></span><br><span class="line"><span class="comment">     * predicate.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed predicate that represents a short-circuiting logical</span></span><br><span class="line"><span class="comment">     * OR of this predicate and another.  When evaluating the composed</span></span><br><span class="line"><span class="comment">     * predicate, if this predicate is true, then the other</span></span><br><span class="line"><span class="comment">     * predicate is not evaluated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a predicate that tests if two arguments are equal according</span></span><br><span class="line"><span class="comment">     * to &#123;<span class="doctag">@link</span> Objects#equals(Object, Object)&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">isEqual</span><span class="params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们看到在 Predicate 类中，除了 test 方法，还定义了三个 default 方法，<code>and</code>, <code>or</code> 和 <code>negate</code>，它们分别对应逻辑运算中的与（&amp;&amp;）、或（||）、非（!）操作。通过这三个方法，我们可以构造更复杂的 predicate 表达式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPredicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String text = <span class="string">"111"</span>;</span><br><span class="line">    Predicate&lt;String&gt; a = s - &gt; s != <span class="keyword">null</span>;</span><br><span class="line">    Predicate&lt;String&gt; b = s - &gt; s.length() &gt; <span class="number">3</span>;</span><br><span class="line">    System.out.println(judge(text, a.and(b)));</span><br><span class="line">    System.out.println(judge(text, a.negate()));</span><br><span class="line">    System.out.println(judge(text, a.or(b)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对应的输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure></p><p>另外 and 和 or 方法是按照在表达式链中的位置，从左向右确定优先级的。因此 <code>a.or(b).and(c)</code> 可以看作 <code>(a || b) &amp;&amp; c</code>。</p><h3 id="BiPredicate"><a href="#BiPredicate" class="headerlink" title="BiPredicate"></a>BiPredicate</h3><p>BiPredicate 针对两个参数对象（T, U）进行测试，函数描述符为 <code>(T, U) -&gt; boolean</code>。下面是该接口的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a predicate (boolean-valued function) of two arguments.  This is</span></span><br><span class="line"><span class="comment"> * the two-arity specialization of &#123;<span class="doctag">@link</span> Predicate&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiPredicate</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> BiPredicate&lt;T, U&gt; <span class="title">and</span><span class="params">(BiPredicate&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (T t, U u) -&gt; test(t, u) &amp;&amp; other.test(t, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> BiPredicate&lt;T, U&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T t, U u) -&gt; !test(t, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> BiPredicate&lt;T, U&gt; <span class="title">or</span><span class="params">(BiPredicate&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (T t, U u) -&gt; test(t, u) || other.test(t, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是一个使用示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBiPredicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BiPredicate&lt;Integer, Integer&gt; b = (x, y) -&gt; x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">boolean</span> r = b.test(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    System.out.println(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>Consumer（消费者），针对对象进行某种操作（消费对象）。该接口定义了一个 accept 方法，会将该方法作用于目标对象，函数描述符为 <code>T -&gt; void</code>。下面是使用示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">(T t, Consumer&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">    c.accept(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConsume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String text = <span class="string">"1234"</span>;</span><br><span class="line">    consume(text, s -&gt; System.out.println(s.substring(<span class="number">2</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是 Consumer 类的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents an operation that accepts a single input argument and returns no</span></span><br><span class="line"><span class="comment"> * result. Unlike most other functional interfaces, Consumer is expected</span></span><br><span class="line"><span class="comment"> * to operate via side-effects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs this operation on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed  Consumer that performs, in sequence, this</span></span><br><span class="line"><span class="comment">     * operation followed by the after operation. If performing either</span></span><br><span class="line"><span class="comment">     * operation throws an exception, it is relayed to the caller of the</span></span><br><span class="line"><span class="comment">     * composed operation.  If performing this operation throws an exception,</span></span><br><span class="line"><span class="comment">     * the after operation will not be performed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Consumer 中定义了一个 andThen 的 default 方法，通过该方法我们可以对目标对象进行链式（chain）处理，下面是一个示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConsume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    Consumer &lt;StringBuilder&gt; a = s -&gt; s.append(<span class="string">"abcd"</span>);</span><br><span class="line">    Consumer &lt;StringBuilder&gt; b = s -&gt; s.reverse();</span><br><span class="line">    Consumer &lt;StringBuilder&gt; c = s -&gt; s.append(<span class="string">"1234"</span>);</span><br><span class="line">    consume(builder, a.andThen(b).andThen(c));</span><br><span class="line">    System.out.println(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dcba1234</span><br></pre></td></tr></table></figure></p><h3 id="BiConsumer"><a href="#BiConsumer" class="headerlink" title="BiConsumer"></a>BiConsumer</h3><p>BiConsumer 针对两个对象（T, U）进行操作，对应的函数描述符为 <code>(T, U) -&gt; void</code>。下面是该接口的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents an operation that accepts two input arguments and returns no</span></span><br><span class="line"><span class="comment"> * result.  This is the two-arity specialization of  Consumer.</span></span><br><span class="line"><span class="comment"> * Unlike most other functional interfaces, BiConsumer is expected</span></span><br><span class="line"><span class="comment"> * to operate via side-effects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiConsumer</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> BiConsumer&lt;T, U&gt; <span class="title">andThen</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (l, r) -&gt; &#123;</span><br><span class="line">            accept(l, r);</span><br><span class="line">            after.accept(l, r);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBiConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BiConsumer&lt;String, String&gt; b = (x, y) -&gt; System.out.println(x + y);</span><br><span class="line">    b.accept(<span class="string">"111"</span>, <span class="string">"222"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h3><p>Supplier（供应商），返回一个泛型对象（生产对象）。该接口中定义了一个 get 方法，没有方法参数，返回值是一个泛型对象，函数描述符为 <code>() -&gt; T</code>。下面是一个使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">supplier</span><span class="params">(Supplier&lt;T&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSupplier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String text = supplier(() -&gt; <span class="string">"1111"</span>);</span><br><span class="line">    System.out.println(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是 Supplier 接口的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a supplier of results.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>Function 接口就相当于 <code>y=f(x)</code> 中的函数 f，接收一个 x（argument）返回计算值 y（result）。该接口定义了一个 apply 方法，接收一个 T 类型的对象，返回一个 R 类型的结果，函数描述符为 <code>T -&gt; R</code>。下面是一个使用示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T, R&gt; <span class="function">R <span class="title">func</span><span class="params">(T t, Function&lt;T, R&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f.apply(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String text = <span class="string">"1234"</span>;</span><br><span class="line">    <span class="keyword">int</span> i = func(text, t -&gt; Integer.parseInt(t));</span><br><span class="line">    <span class="comment">// 输出 1235</span></span><br><span class="line">    System.out.println(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是 Function 接口的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a function that accepts one argument and produces a result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed function that first applies the before</span></span><br><span class="line"><span class="comment">     * function to its input, and then applies this function to the result.</span></span><br><span class="line"><span class="comment">     * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment">     * the caller of the composed function.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed function that first applies this function to</span></span><br><span class="line"><span class="comment">     * its input, and then applies the after function to the result.</span></span><br><span class="line"><span class="comment">     * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment">     * the caller of the composed function.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a function that always returns its input argument.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Function&lt;T, T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 Function 接口中定义了两个 default 方法：<code>compose</code> 和 <code>andThen</code> 可以进行链式的调用，假设有两个函数 f(x) 和 g(x):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.compose(g) =&gt; f(g(x))</span><br><span class="line">f.andThen(g) =&gt; g(f(x))</span><br></pre></td></tr></table></figure></p><p>下图是一个详细的解释</p><p><img src="/images/lambda/function.png" alt></p><p>下面是一个使用示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Function&lt;Integer, Integer&gt; f = x -&gt; x + <span class="number">1</span>;</span><br><span class="line">    Function&lt;Integer, Integer&gt; g = x -&gt; x * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> i = func(<span class="number">1</span>, f.andThen(g));</span><br><span class="line">    <span class="comment">// 输出 4</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line"></span><br><span class="line">    i = func(<span class="number">1</span>, f.compose(g));</span><br><span class="line">    <span class="comment">// 输出 3</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="UnaryOperator"><a href="#UnaryOperator" class="headerlink" title="UnaryOperator"></a>UnaryOperator</h4><p>UnaryOperator 是一种特殊的 Function，表示操作数和返回值是同一种类型，函数描述符为 <code>T -&gt; T</code>。下面是该接口的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents an operation on a single operand that produces a result of the</span></span><br><span class="line"><span class="comment"> * same type as its operand.  This is a specialization of &#123;<span class="doctag">@code</span> Function&#125; for</span></span><br><span class="line"><span class="comment"> * the case where the operand and result are of the same type.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UnaryOperator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a unary operator that always returns its input argument.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">UnaryOperator&lt;T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是一个使用示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUnaryOperator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UnaryOperator&lt;Integer&gt; u = x -&gt; x + <span class="number">1</span>;</span><br><span class="line">    System.out.println(u.apply(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="BiFunction"><a href="#BiFunction" class="headerlink" title="BiFunction"></a>BiFunction</h3><p>BiFunction 接收两个参数（T, U），返回一个结果（R），类似于 z=f(x, y)，对应的函数描述符为 <code>(T, U) -&gt; R</code>。下面是该接口的具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a function that accepts two arguments and produces a result.</span></span><br><span class="line"><span class="comment"> * This is the two-arity specialization of Function.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiFunction</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given arguments.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the first function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> u the second function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed function that first applies this function to</span></span><br><span class="line"><span class="comment">     * its input, and then applies the &#123;<span class="doctag">@code</span> after&#125; function to the result.</span></span><br><span class="line"><span class="comment">     * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment">     * the caller of the composed function.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">BiFunction&lt;T, U, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t, U u) -&gt; after.apply(apply(t, u));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是一个使用示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBiFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BiFunction&lt;Integer, Double, String&gt; b = (i, d) -&gt; String.valueOf(i + d);</span><br><span class="line">    String r = b.apply(<span class="number">1</span>, <span class="number">2.5</span>);</span><br><span class="line">    System.out.println(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="BinaryOperator"><a href="#BinaryOperator" class="headerlink" title="BinaryOperator"></a>BinaryOperator</h4><p>BinaryOperator 是一种特殊的 BiFunction，表示接收的参数和返回的结果都是同一种类型 T，函数描述符为 <code>(T, T) -&gt; T</code>。下面是该接口的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents an operation upon two operands of the same type, producing a result</span></span><br><span class="line"><span class="comment"> * of the same type as the operands.  This is a specialization of</span></span><br><span class="line"><span class="comment"> * BiFunction for the case where the operands and the result are all of</span></span><br><span class="line"><span class="comment"> * the same type.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BinaryOperator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BiFunction</span>&lt;<span class="title">T</span>,<span class="title">T</span>,<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a BinaryOperator which returns the lesser of two elements</span></span><br><span class="line"><span class="comment">     * according to the specified Comparator.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BinaryOperator&lt;T&gt; <span class="title">minBy</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(comparator);</span><br><span class="line">        <span class="keyword">return</span> (a, b) -&gt; comparator.compare(a, b) &lt;= <span class="number">0</span> ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a  BinaryOperator which returns the greater of two elements</span></span><br><span class="line"><span class="comment">     * according to the specified Comparator.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BinaryOperator&lt;T&gt; <span class="title">maxBy</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(comparator);</span><br><span class="line">        <span class="keyword">return</span> (a, b) -&gt; comparator.compare(a, b) &gt;= <span class="number">0</span> ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是一个使用示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBinaryOperator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BinaryOperator&lt;Integer&gt; b = (x, y) -&gt; x + y;</span><br><span class="line">    <span class="keyword">int</span> z = b.apply(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    System.out.println(z);</span><br><span class="line"></span><br><span class="line">    BinaryOperator&lt;Integer&gt; min = BinaryOperator.minBy((x, y) -&gt; x - y);</span><br><span class="line">    <span class="comment">// 输出 1</span></span><br><span class="line">    z = min.apply(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    System.out.println(z);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 3</span></span><br><span class="line">    BinaryOperator&lt;Integer&gt; max = BinaryOperator.maxBy((x, y) -&gt; x - y);</span><br><span class="line">    z = max.apply(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    System.out.println(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Primitive-specializations"><a href="#Primitive-specializations" class="headerlink" title="Primitive specializations"></a>Primitive specializations</h3><p>在上面提到的接口中，都是接受泛型参数，我们知道泛型参数只能是引用类型，也就是说对于 int 这样的基本类型，我们要首先装箱（boxing）成 Integer 类型，在使用的时候再拆箱（unboxing）成 int。虽然 Java 提供了自动装箱机制，但是在性能方面是要付出代价的。所以对于上述的函数式接口，Java 8 提供了针对基本类型的版本，以此来避免输入输出是基本类型时的自动装箱操作。以 Predicate 为例，假设我们要检测一个 int 是否满足某个条件，我们可以使用 IntPredicate ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIntPredicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IntPredicate ip = x -&gt; x &gt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">boolean</span> r = ip.test(<span class="number">4</span>);</span><br><span class="line">    System.out.println(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是 IntPredicate 的定义，我们可以看到它将泛型 T 改为了基本类型 int。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a predicate (boolean-valued function) of one &#123;<span class="doctag">@code</span> int&#125;-valued</span></span><br><span class="line"><span class="comment"> * argument. This is the &#123;<span class="doctag">@code</span> int&#125;-consuming primitive type specialization of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Predicate&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntPredicate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> IntPredicate <span class="title">and</span><span class="params">(IntPredicate other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (value) -&gt; test(value) &amp;&amp; other.test(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> IntPredicate <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (value) -&gt; !test(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> IntPredicate <span class="title">or</span><span class="params">(IntPredicate other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (value) -&gt; test(value) || other.test(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下表列出了 Java 8 中的函数式接口以及其对应的基本类型版本：</p><table><thead><tr><th>函数式接口</th><th>函数描述符</th><th style="text-align:left">基本类型版本</th></tr></thead><tbody><tr><td><code>Predicate&lt;T&gt;</code></td><td><code>T -&gt; boolean</code></td><td style="text-align:left"><code>IntPredicate, LongPredicate, DoublePredicate</code></td></tr><tr><td><code>BiPredicate&lt;T&gt;</code></td><td><code>(L, R) -&gt; boolean</code></td><td style="text-align:left"></td></tr><tr><td><code>Consumer&lt;T&gt;</code></td><td><code>T -&gt; void</code></td><td style="text-align:left"><code>IntConsumer, LongConsumer, DoubleConsumer</code></td></tr><tr><td><code>BiConsumer&lt;T, U&gt;</code></td><td><code>(T, U) -&gt; void</code></td><td style="text-align:left"><code>ObjIntConsumer&lt;T&gt;, ObjLongConsumer&lt;T&gt;, ObjDoubleConsumer&lt;T&gt;</code></td></tr><tr><td><code>Supplier&lt;T&gt;</code></td><td><code>() -&gt; T</code></td><td style="text-align:left"><code>BooleanSupplier, IntSupplier, LongSupplier, DoubleSupplier</code></td></tr><tr><td><code>Function&lt;T, R&gt;</code></td><td><code>T -&gt; R</code></td><td style="text-align:left"><code>IntFunction&lt;R&gt;, IntToDoubleFunction, IntToLongFunction, LongFunction&lt;R&gt;, LongToDoubleFunction, LongToIntFunction, DoubleFunction&lt;R&gt;, ToIntFunction&lt;T&gt;, ToDoubleFunction&lt;T&gt;, ToLongFunction&lt;T&gt;</code></td></tr><tr><td><code>UnaryOperator&lt;T&gt;</code></td><td><code>T -&gt; T</code></td><td style="text-align:left"><code>IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator</code></td></tr><tr><td><code>BiFunction&lt;T, U, R&gt;</code></td><td><code>(T, U) -&gt; R</code></td><td style="text-align:left"><code>ToIntBiFunction&lt;T, U&gt;</code>, <code>ToLongBiFunction&lt;T, U&gt;</code>, <code>ToDoubleBiFunction&lt;T, U&gt;</code></td></tr><tr><td><code>BinaryOperator&lt;T&gt;</code></td><td><code>(T, T) -&gt; T</code></td><td style="text-align:left"><code>IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator</code></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;Lambda(λ) 表达式是一种在 &lt;em&gt;被调用的位置&lt;/em&gt; 或者 &lt;em&gt;作为参数传递给函数的位置&lt;/em&gt; &lt;strong&gt;定义匿名函数对象&lt;/strong&gt; 的简便方法。下面是关于 Lambda 表达式的几个点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;匿名（Anonymous） - 不像其他普通方法那样具有名字&lt;/li&gt;
&lt;li&gt;函数（Function） -  Lambda 表达式不像普通方法那样属于某个特定的类，它是独立于类存在的。但是和方法一样，Lambda 表达式有参数列表、函数主体和返回值，还可能有可以抛出的异常列表。&lt;/li&gt;
&lt;li&gt;传递（Passed around）- Lambda 表达式可以作为参数传递给方法或者存储在变量中。&lt;/li&gt;
&lt;li&gt;简洁（Concise）- 无需像匿名类那样写很多的模板代码。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java 8" scheme="http://blog.zhangjikai.com/categories/Java-8/"/>
    
    
      <category term="Java" scheme="http://blog.zhangjikai.com/tags/Java/"/>
    
      <category term="Lambda" scheme="http://blog.zhangjikai.com/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>【Django】Django ORM 学习笔记</title>
    <link href="http://blog.zhangjikai.com/2017/06/24/%E3%80%90Django%E3%80%91Django-ORM-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.zhangjikai.com/2017/06/24/【Django】Django-ORM-学习笔记/</id>
    <published>2017-06-24T01:43:35.000Z</published>
    <updated>2019-09-08T06:53:07.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ORM，即Object-Relational Mapping（对象关系映射），它的作用是在关系型数据库和业务实体对象之间作一个映射，这样，我们在具体的操作业务对象的时候，就不需要再去和复杂的SQL语句打交道，只需简单的操作对象的属性和方法。下面是一个示例。通过使用 ORM，我们只需要操作 Author 和 Blog 对象，而不用操作相关的数据库表。这里主要介绍一下 Django ORM 的相关使用。<br><a id="more"></a><br><img src="/images/orm/orm-demo.png" alt></p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>使用 ORM 最大的优点就是快速开发，让我们将更多的精力放在业务上而不是数据库上，下面是 ORM 的几个优点</p><ul><li>隐藏了数据访问细节，使通用数据库交互变得简单易行。同时 ORM 避免了不规范、冗余、风格不统一的 SQL 语句，可以避免很多人为的 bug，方便编码风格的统一和后期维护。</li><li>将数据库表和对象模型关联，我们只需针对相关的对象模型进行编码，无须考虑对象模型和数据库表之间的转化，大大提高了程序的开发效率。</li><li>方便数据库的迁移。当需要迁移到新的数据库时，不需要修改对象模型，只需要修改数据库的配置。</li></ul><p>ORM 的最令人诟病的地方就是性能问题，不过现在已经提高了很多，下面是 ORM 的几个缺点</p><ul><li>性能问题<ul><li>自动化进行数据库关系的映射需要消耗系统资源</li><li>程序员编码</li><li>在处理多表联查、where 条件复杂的查询时，ORM 可能会生成的效率低下的 SQL</li><li>通过 Lazy load 和 Cache 很大程度上改善了性能问题</li></ul></li><li>SQL 调优，SQL 语句是由 ORM 框架自动生成，虽然减少了 SQL 语句错误的发生，但是也给 SQL 调优带来了困难。</li><li>越是功能强大的 ORM 越消耗内存，因为一个 ORM Object 会带有很多成员变量和成员函数。</li><li>对象和关系之间并不是完美映射</li></ul><p>一般来说 ORM 足以满足我们的需求，如果对性能要求特别高或者查询十分复杂，可以考虑使用原生 SQL 和 ORM 共用的方式</p><h1 id="Django-ORM"><a href="#Django-ORM" class="headerlink" title="Django ORM"></a>Django ORM</h1><p>在 Django 框架中集成了 ORM 模块，我们来看下具体的使用，部分内容会给出基于 MySQL 的 SQL 语句。</p><h2 id="Manager"><a href="#Manager" class="headerlink" title="Manager"></a>Manager</h2><p>在创建完 Model 对象之后，Django 会自动为其关联一个 Manager 对象，该对象是 Model 进行数据库操作的接口。默认的 Manager 对象名称为 objects，下面是使用 Manager 进行增删改查的一个示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_blog</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 使用 get 检索数据时，如果数据不存在，会报 DoesNotExist 错误</span></span><br><span class="line">    <span class="comment"># 可以使用 Blog.objects.all().filter(id=1).first() 方法</span></span><br><span class="line">    author = Author.objects.get(id=<span class="number">1</span>)</span><br><span class="line">    blog = Blog(title=<span class="string">'blog2'</span>, content=<span class="string">'blog2'</span>, author=author)</span><br><span class="line">    blog.save()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_blog</span><span class="params">()</span>:</span></span><br><span class="line">    blog = Blog.objects.all().get(id=<span class="number">2</span>)</span><br><span class="line">    blog.title = <span class="string">'change_title'</span></span><br><span class="line">    blog.save()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_blog</span><span class="params">()</span>:</span></span><br><span class="line">    blog = Blog.objects.all().filter(id=<span class="number">2</span>).first()</span><br><span class="line">    <span class="keyword">if</span> blog <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        blog.delete()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_blog</span><span class="params">()</span>:</span></span><br><span class="line">    blogs = Blog.objects.all()</span><br><span class="line">    <span class="keyword">for</span> blog <span class="keyword">in</span> blogs:</span><br><span class="line">        <span class="keyword">print</span> blog</span><br></pre></td></tr></table></figure></p><p>我们可以自定义 Manager 的名称，如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    people = models.Manager()</span><br><span class="line"></span><br><span class="line">Person.people.all()</span><br></pre></td></tr></table></figure></p><p>同时我们也可以定义自己的 Manager，为 Manager 加上一些额外的功能，下面的示例会为 Author 添加上所写 Blog 数量信息：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorManager</span><span class="params">(models.Manager)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_blog_counts</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">from</span> django.db <span class="keyword">import</span> connection</span><br><span class="line">        cursor = connection.cursor()</span><br><span class="line">        condition = <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> kwargs.has_key(<span class="string">'id'</span>):</span><br><span class="line">            condition = <span class="string">'a.id = %s and '</span> % kwargs[<span class="string">'id'</span>]</span><br><span class="line">        query = <span class="string">'''</span></span><br><span class="line"><span class="string">            SELECT a.id, a.name, COUNT(b.id)</span></span><br><span class="line"><span class="string">            FROM orm_author a LEFT JOIN orm_blog b</span></span><br><span class="line"><span class="string">            ON a.id = b.author_id</span></span><br><span class="line"><span class="string">            WHERE %s TRUE</span></span><br><span class="line"><span class="string">            GROUP BY a.id</span></span><br><span class="line"><span class="string">        '''</span> % condition</span><br><span class="line"></span><br><span class="line">        cursor.execute(query)</span><br><span class="line">        result_list = []</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> cursor.fetchall():</span><br><span class="line">            author = self.model(id=row[<span class="number">0</span>], name=row[<span class="number">1</span>])</span><br><span class="line">            author.blog_count = row[<span class="number">2</span>]</span><br><span class="line">            result_list.append(author)</span><br><span class="line">        <span class="keyword">return</span> result_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    objects = AuthorManager()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">authors = Author.objects.with_blog_counts(id=<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> author <span class="keyword">in</span> authors:</span><br><span class="line">        <span class="keyword">print</span> author.name, author.blog_count</span><br></pre></td></tr></table></figure></p><p>另外我们也可以为 Model 指定多个 Manager<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    manager = models.Manager()</span><br><span class="line">    manager2 = AuthorManager()</span><br></pre></td></tr></table></figure></p><h2 id="QuerySet"><a href="#QuerySet" class="headerlink" title="QuerySet"></a>QuerySet</h2><p>从数据库中查询出来的结果一般是一个集合，这个集合称为 QuerySet。QuerySet 有两种来源：通过 Manager 的方法获取、通过 QuerySet 自身的方法获得。Manager 的查询方法和 QuerySet 的方法大部分同名、同意（Manager的就是基于 QuerySet 的实现的），例如 filter, exclude等，但两者也有不同的方法，例如 Manager 的 create、get_or_create，QuerySet 的 delete 等。</p><h3 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h3><p>下面是 QuerySet (也是 Manager的)的几个基本的查询方法</p><ul><li><p>all() - 获得数据库中所有实例的一个 QuerySet</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Blog.objects.all()</span><br><span class="line"><span class="comment"># 对应SQL</span></span><br><span class="line"><span class="comment"># SELECT `orm_blog`.`id`,  `orm_blog`.`author_id`,  `orm_blog`.`title`,  `orm_blog`.`content`</span></span><br><span class="line"><span class="comment"># FROM `orm_blog`()</span></span><br></pre></td></tr></table></figure></li><li><p>filter(**kwargs) - 返回满足查询条件的 QuerySet</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Blog.objects.filter(title=<span class="string">'blog2'</span>)</span><br><span class="line"><span class="comment"># 对应 SQL</span></span><br><span class="line"><span class="comment"># SELECT `orm_blog`.`id`,  `orm_blog`.`author_id`,  `orm_blog`.`title`, `orm_blog`.`content`</span></span><br><span class="line"><span class="comment"># FROM `orm_blog` WHERE `orm_blog`.`title` = 'blog2'</span></span><br></pre></td></tr></table></figure></li><li><p>exclude(**kwargs) - 获得不满足查询条件的 QuerySet</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Blog.objects.exclude(title=<span class="string">'blog2'</span>)</span><br><span class="line"><span class="comment"># 对应 SQL</span></span><br><span class="line"><span class="comment"># SELECT `orm_blog`.`id`,  `orm_blog`.`author_id`,  `orm_blog`.`title`,  `orm_blog`.`content`</span></span><br><span class="line"><span class="comment"># FROM `orm_blog` WHERE NOT (`orm_blog`.`title` = 'blog2')</span></span><br></pre></td></tr></table></figure></li><li><p>get(**kwargs) — 从数据库中获得一个匹配的结果（一个实例），如果没有匹配结果或者匹配结果大于一个都会报错</p></li></ul><h3 id="字段查询"><a href="#字段查询" class="headerlink" title="字段查询"></a>字段查询</h3><p>在前面的 filter、exclude 和 get 方法中，我们需要传入参数作为选择条件: <code>title=&#39;blog2&#39;</code>，这个就是字段查询。字段查询的格式如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">field__lookuptype=value <span class="comment"># 中间是两个下划线</span></span><br></pre></td></tr></table></figure></p><p>lookuptype 的类型有下面几种</p><ul><li>exact 精确匹配，默认的 lookup type。上面的 <code>title=&#39;blog2&#39;</code> 就相当于 <code>title__exact=&#39;blog2&#39;</code></li><li>gt : 大于</li><li>gte : 大于等于</li><li>lt : 小于</li><li>lte :小于等于</li><li>in : in</li><li>contains : 包含，区分大小写 - <code>a LIKE BINARY &#39;%b%&#39;</code></li><li>icontains : 包含，不区分大小写 - <code>a LIKE &#39;%b%&#39;</code></li><li>iexact : 大小写不敏感的精确匹配 - <code>a LIKE &#39;b&#39;</code></li><li>startswith : 匹配开头，区分大小写 - <code>a LIKE BINARY &#39;b%&#39;</code></li><li>istartswith : 匹配开头，不区分大小写 - <code>a LIKE &#39;b%&#39;</code></li><li>endswith : 匹配结尾，区分大小写 - <code>a LIKE BINARY &#39;%b&#39;</code></li><li>iendswith : 匹配结尾，不区分大小写 - <code>a LIKE &#39;%b&#39;</code></li></ul><p>我们还可以进行关联查询，下面的例子是查询所有 author name 为 zjk 的 blog，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">blogs = Blog.objects.filter(author__name=<span class="string">'zjk'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL:</span></span><br><span class="line"><span class="comment"># SELECT `orm_blog`.`id`,  `orm_blog`.`author_id`,  `orm_blog`.`title`, `orm_blog`.`content`</span></span><br><span class="line"><span class="comment"># FROM `orm_blog` INNER JOIN `orm_author` ON (`orm_blog`.`author_id` = `orm_author`.`id`)</span></span><br><span class="line"><span class="comment"># WHERE `orm_author`.`name` = 'zjk'</span></span><br></pre></td></tr></table></figure></p><h3 id="限制-QuerySet"><a href="#限制-QuerySet" class="headerlink" title="限制 QuerySet"></a>限制 QuerySet</h3><p>有时候我们并不需要获取查询集的全部数据，而只需要一个子集，一个常见的场景就是进行分页查询。使用 Python 的切片语法可以限制 QuerySet 的实例数量，ORM 会将翻译成 SQL 的 LIMIT 和 OFFSET 子句，下面是几个例子：</p><ul><li><p>放回 QuerySet 的前 5 个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">blogs = Blog.objects.all()[:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL：</span></span><br><span class="line"><span class="comment"># SELECT `orm_blog`.`id`,  `orm_blog`.`author_id`,  `orm_blog`.`title`,  `orm_blog`.`content`</span></span><br><span class="line"><span class="comment"># FROM `orm_blog` LIMIT 5</span></span><br></pre></td></tr></table></figure></li><li><p>返回 QuerySet 的第 6-10 个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">blogs = Blog.objects.all()[<span class="number">5</span>:<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL:</span></span><br><span class="line"><span class="comment"># SELECT `orm_blog`.`id`,  `orm_blog`.`author_id`,  `orm_blog`.`title`,  `orm_blog`.`content`</span></span><br><span class="line"><span class="comment"># FROM `orm_blog` LIMIT 5 OFFSET 5</span></span><br></pre></td></tr></table></figure></li><li><p>使用切片的 step 参数，下面代码返回第 1、3、5、7、9 个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">blogs = Blog.objects.all()[:<span class="number">10</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL:</span></span><br><span class="line"><span class="comment"># SELECT `orm_blog`.`id`,  `orm_blog`.`author_id`,  `orm_blog`.`title`,  `orm_blog`.`content`</span></span><br><span class="line"><span class="comment"># FROM `orm_blog` LIMIT 10</span></span><br></pre></td></tr></table></figure></li><li><p>如果只要访问一个元素，可以直接用索引来访问：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">blog = Blog.objects.all()[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL:</span></span><br><span class="line"><span class="comment"># SELECT `orm_blog`.`id`,  `orm_blog`.`author_id`,  `orm_blog`.`title`,  `orm_blog`.`content`</span></span><br><span class="line"><span class="comment"># FROM `orm_blog` LIMIT 1 OFFSET 2</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Lazy-load"><a href="#Lazy-load" class="headerlink" title="Lazy load"></a>Lazy load</h3><p>QuerySet 是惰性加载的，创建查询集不会访问数据库，只有查询集需要求值时，才会真正运行这个查询。在下面的例子中只有执行 <code>print q</code> 才会真正的去查询数据库。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">q = Blog.objects.filter(title=<span class="string">'blog2'</span>)</span><br><span class="line">q = q.filter(content=<span class="string">'blog2'</span>)</span><br><span class="line">q = q.exclude(id=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 执行下面的语句才会真正访问数据库</span></span><br><span class="line"><span class="keyword">print</span> q</span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL:</span></span><br><span class="line"><span class="comment"># SELECT `orm_blog`.`id`,  `orm_blog`.`author_id`,  `orm_blog`.`title`,  `orm_blog`.`content` FROM `orm_blog`</span></span><br><span class="line"><span class="comment"># WHERE (`orm_blog`.`title` = 'blog2' AND `orm_blog`.`content` = 'blog2' AND NOT (`orm_blog`.`id` = 3)) LIMIT 21</span></span><br></pre></td></tr></table></figure></p><p>关联对象也是惰性加载，只有用到了关联对象的值才会访问数据库<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">blog = Blog.objects.filter(id=<span class="number">3</span>).first()</span><br><span class="line"><span class="keyword">print</span> blog.title</span><br><span class="line"><span class="comment"># 只有执行下面的语句才会访问数据库获取 author 的值，也就是执行第二条 SQL</span></span><br><span class="line"><span class="keyword">print</span> blog.author.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL:</span></span><br><span class="line"><span class="comment"># SELECT `orm_blog`.`id`,  `orm_blog`.`author_id`,  `orm_blog`.`title`,  `orm_blog`.`content`</span></span><br><span class="line"><span class="comment"># FROM `orm_blog` WHERE `orm_blog`.`id` = 3 ORDER BY `orm_blog`.`id` ASC LIMIT 1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># SELECT `orm_author`.`id`,  `orm_author`.`name` FROM `orm_author` WHERE `orm_author`.`id` = 1</span></span><br></pre></td></tr></table></figure></p><p>一般来说只要用到了 QuerySet 以及里面对象的信息，就会访问数据库。下面是文档中给出的几种会对查询集求值的情况：</p><ul><li>迭代：在首次迭代查询集时会执行数据库查询</li><li>切片(限制查询集)：对查询集执行切片操作时，指定 step 参数</li><li>序列化／缓存</li><li>repr：对查询集调用 repr 函数</li><li>len：对查询集调用 len 函数</li><li>list: 对查询集调用 list() 方法强制求值</li><li>bool:测试一个查询集的布尔值，例如使用bool(), or, and 或者 if 语句都将导致查询集的求值</li></ul><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>每个 QuerySet 都包含一个缓存来最小化对数据库的访问，下面是一个示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面代码会访问两次数据库</span></span><br><span class="line"><span class="keyword">print</span> [blog.title <span class="keyword">for</span> blog <span class="keyword">in</span> Blog.objects.all()]</span><br><span class="line"><span class="keyword">print</span> [blog.content <span class="keyword">for</span> blog <span class="keyword">in</span> Blog.objects.all()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面代码只会访问一次数据库</span></span><br><span class="line">blogs = Blog.objects.all()</span><br><span class="line"><span class="keyword">print</span> [blog.title <span class="keyword">for</span> blog <span class="keyword">in</span> blogs]</span><br><span class="line"><span class="keyword">print</span> [blog.content <span class="keyword">for</span> blog <span class="keyword">in</span> blogs]</span><br></pre></td></tr></table></figure></p><p>在一个新的 QuerySet 中，缓存为空。当首次对 QuerySet 的所有实例进行求值时，会将查询结果保存到 QuerySet 的缓冲中。当再访问该 QuerySet 时，会直接从缓冲中取数据。下面是一个示意图：</p><p><img src="/images/orm/orm-cache.png" alt></p><p>如果只对 QuerySet 的部分实例（query_set[5], query_set[0:10]）进行求值，首先会到 QuerySet 的缓冲中查找是否已经缓存了这些实例，如果有就使用缓存值，如果没有就查询数据库，但是<strong>不会将查询结果保存到缓冲中</strong>。如下图所示：</p><p><img src="/images/orm/orm-demo2.png" alt></p><p>如果 QuerySet 数量很大不希望被缓存，遍历时使用 iterator 方法:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blogs = Blog.objects.all()</span><br><span class="line"><span class="keyword">for</span> blog <span class="keyword">in</span> blogs.iterator():</span><br><span class="line">    <span class="keyword">print</span> blog.title</span><br></pre></td></tr></table></figure></p><h3 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h3><p>在讲关联查询之前，首先看一下下面的一个示例。我们前面提到，关联实例是惰性加载的，因此对于下面的代码，每次 for 循环都要访问一次数据库，会严重影响性能。因此我们需要一次将 blog 以及 author 的信息全部取出来，这就是我们马上要讲的关联查询。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> blog <span class="keyword">in</span> Blog.objects.all():</span><br><span class="line">    <span class="keyword">print</span> blog.title, blog.author.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL:</span></span><br><span class="line"><span class="comment"># SELECT `orm_blog`.`id`,  `orm_blog`.`author_id`,  `orm_blog`.`title`,  `orm_blog`.`content` FROM `orm_blog`</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># SELECT `orm_author`.`id`,  `orm_author`.`name` FROM `orm_author` WHERE `orm_author`.`id` = 1</span></span><br><span class="line"><span class="comment"># SELECT `orm_author`.`id`,  `orm_author`.`name` FROM `orm_author` WHERE `orm_author`.`id` = 1.</span></span><br><span class="line"><span class="comment"># . . . . . .</span></span><br></pre></td></tr></table></figure></p><p>关联查询就是在查询当前实例的同时，把其关联的实例数据也一块取出来。在下图中 orm_blog 通过一个外键和 orm_author 关联。关联大体上可以分为两种：</p><ul><li>只有一个关联实例： 外键关联中包含外键的表、OneToOneField，例如下图中的 orm_blog 只与一个 orm_author 的实例关联</li><li>有多个关联实例：外键关联中不含外键的表、ManyToManyField，例如下图中的 orm_author 就与多个 orm_blog 实例关联</li></ul><p>因此 Django ORM 中的关联查询也分两中 select_related(单关联实例) 和 prefetch_related(多关联实例)<br><img src="/images/orm/relation.png" alt></p><h4 id="select-related"><a href="#select-related" class="headerlink" title="select_related"></a>select_related</h4><p>select_related 用来处理单关联实例的情况，适用于 ForeignKey 和 OneToOneField。在查询时，会对关联的表进行 join 操作，取出全部的信息，下面是一个示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">blog = Blog.objects.select_related().filter(id=<span class="number">3</span>).first()</span><br><span class="line"><span class="keyword">print</span> blog.id, blog.author.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL</span></span><br><span class="line"><span class="comment"># SELECT `orm_blog`.`id`,  `orm_blog`.`author_id`,  `orm_blog`.`title`,  `orm_blog`.`content`,  `orm_author`.`id`,  `orm_author`.`name`</span></span><br><span class="line"><span class="comment"># FROM `orm_blog` INNER JOIN `orm_author` ON (`orm_blog`.`author_id` = `orm_author`.`id`)</span></span><br><span class="line"><span class="comment"># WHERE `orm_blog`.`id` = 3 ORDER BY `orm_blog`.`id` ASC LIMIT 1</span></span><br></pre></td></tr></table></figure></p><p>下面是一个示意图：</p><p><img src="/images/orm/select.png" alt></p><p>select_related 会沿着外键递归查询，例如上图中取表 1 的实例时，会沿着外键将表 3 的数据一块取出来。我们可以传入 depth 参数来指定递归的深度。</p><p>如果需要清除 QuerySet 上以前的 select_related 添加的关联字段，可以传入 None 做参数</p><h4 id="prefetch-related"><a href="#prefetch-related" class="headerlink" title="prefetch_related"></a>prefetch_related</h4><p>prefetch_related 主要适用于 OneTwoMany 和 ManyToManyField。和 select_related 类似，prefetch_related 在查询时会同时取出关联实例的值。与 select_related 不同的是 prefetch_related 不使用 JOIN 方式来查询数据库，而是分别查每个表，最后使用 Python 来实现 JOIN 操作。下面是一个示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">author = Author.objects.prefetch_related(<span class="string">'blog_set'</span>).filter(name=<span class="string">'zjk'</span>).first()</span><br><span class="line"><span class="keyword">for</span> blog <span class="keyword">in</span> author.blog_set.all():</span><br><span class="line">    <span class="keyword">print</span> blog</span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL:</span></span><br><span class="line"><span class="comment"># SELECT `orm_author`.`id`,  `orm_author`.`name` FROM `orm_author`</span></span><br><span class="line"><span class="comment"># WHERE `orm_author`.`name` = 'zjk' ORDER BY `orm_author`.`id` ASC LIMIT 1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># SELECT `orm_blog`.`id`,  `orm_blog`.`author_id`,  `orm_blog`.`title`,  `orm_blog`.`content`</span></span><br><span class="line"><span class="comment"># FROM `orm_blog` WHERE `orm_blog`.`author_id` IN (1)</span></span><br></pre></td></tr></table></figure></p><p>下面是一个示意图：</p><p><img src="/images/orm/prefetch.png" alt></p><p>如果查询出关联对象的 QuerySet 之后，再对该 QuerySet 执行查询条件，会使该 QuerySet 失效（也就是需要再次访问数据库）。如果在查询关联对象时需要使用查询条件，可以使用 Prefetch 对象，下面是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Prefetch</span><br><span class="line"></span><br><span class="line">authors = Author.objects.prefetch_related(Prefetch(</span><br><span class="line">    <span class="string">'blog_set'</span>, queryset=Blog.objects.filter(title=<span class="string">'blog2'</span>), to_attr=<span class="string">'blogs'</span></span><br><span class="line">))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> author <span class="keyword">in</span> authors:</span><br><span class="line">    <span class="keyword">print</span> author.blogs</span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL:</span></span><br><span class="line"><span class="comment"># SELECT `orm_author`.`id`,  `orm_author`.`name` FROM `orm_author`</span></span><br><span class="line"><span class="comment">#     </span></span><br><span class="line"><span class="comment"># SELECT `orm_blog`.`id`,  `orm_blog`.`author_id`,  `orm_blog`.`title`,  `orm_blog`.`content`</span></span><br><span class="line"><span class="comment"># FROM `orm_blog` WHERE (`orm_blog`.`title` = 'blog2' AND `orm_blog`.`author_id` IN (1,  2))</span></span><br></pre></td></tr></table></figure><h3 id="Q-查询"><a href="#Q-查询" class="headerlink" title="Q 查询"></a>Q 查询</h3><p>在前面所讲的 filter 和 exclude 方法，对于传入的查询条件都是执行的 AND 操作，如果我们需要对查询条件执行 OR 操作，例如查询 blog 表中 title=‘blog1’ 或者 title=‘blog2’ 的实例，就需要用到 Q 查询。Q 查询支持使用 |、&amp;、~ 操作符，分别对象查询条件的 OR、AND 和 NOT 操作。下面是一个示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line"></span><br><span class="line">blogs = Blog.objects.filter(Q(id=<span class="number">10</span>) | Q(title=<span class="string">'blog2'</span>))</span><br><span class="line"><span class="keyword">for</span> blog <span class="keyword">in</span> blogs:</span><br><span class="line">    <span class="keyword">print</span> blog</span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL:</span></span><br><span class="line"><span class="comment"># SELECT `orm_blog`.`id`,  `orm_blog`.`author_id`,  `orm_blog`.`title`,  `orm_blog`.`content`</span></span><br><span class="line"><span class="comment"># FROM `orm_blog` WHERE (`orm_blog`.`id` = 10 OR `orm_blog`.`title` = ‘blog2')</span></span><br></pre></td></tr></table></figure></p><h3 id="F-查询"><a href="#F-查询" class="headerlink" title="F 查询"></a>F 查询</h3><p>F 查询主要用来处理表中字段之间的比较，例如查询 blog 表中 title=conent 的记录。同时 F 查询还支持计算（加减乘除）。下面是一个示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br><span class="line"></span><br><span class="line">blogs = Blog.objects.filter(title=F(<span class="string">'content'</span>))</span><br><span class="line"><span class="keyword">for</span> blog <span class="keyword">in</span> blogs:</span><br><span class="line">    <span class="keyword">print</span> blog</span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL:</span></span><br><span class="line"><span class="comment"># SELECT `orm_blog`.`id`,  `orm_blog`.`author_id`,  `orm_blog`.`title`,  `orm_blog`.`content`</span></span><br><span class="line"><span class="comment"># FROM `orm_blog` WHERE `orm_blog`.`title` = (`orm_blog`.`content`)</span></span><br><span class="line"></span><br><span class="line">blogs = Blog.objects.filter(title=F(<span class="string">'content'</span>)+<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> blog <span class="keyword">in</span> blogs:</span><br><span class="line">    <span class="keyword">print</span> blog</span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL：</span></span><br><span class="line"><span class="comment"># SELECT `orm_blog`.`id`,  `orm_blog`.`author_id`,  `orm_blog`.`title`,  `orm_blog`.`content`</span></span><br><span class="line"><span class="comment"># FROM `orm_blog` WHERE `orm_blog`.`title` = ((`orm_blog`.`content` + 2))</span></span><br></pre></td></tr></table></figure></p><h3 id="values-和-values-list"><a href="#values-和-values-list" class="headerlink" title="values 和 values_list"></a>values 和 values_list</h3><p>有些时候我们不需要获取实例中所有的数据，而只需要获得几个字段的数据即可，使用 values 和 values_list 可以指定检索的字段。values 会返回一个 dict 数组，而 values_list 会返回 list 数组。下面是一个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">blogs = Blog.objects.filter(id=<span class="number">5</span>).values(<span class="string">'title'</span>)</span><br><span class="line"><span class="keyword">print</span> blogs</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;QuerySet [&#123;u'title': u’blog2'&#125;]&gt;</span></span><br><span class="line"></span><br><span class="line">blogs = Blog.objects.filter(id=<span class="number">5</span>).values_list(<span class="string">'title'</span>)</span><br><span class="line"><span class="keyword">print</span> blogs</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;QuerySet [(u’blog2',)]&gt;</span></span><br><span class="line"></span><br><span class="line">blogs = Blog.objects.filter(id=<span class="number">5</span>).values_list(<span class="string">'title'</span>, flat=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">print</span> blogs</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;QuerySet [u’blog2']&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="aggregate-和-annotate"><a href="#aggregate-和-annotate" class="headerlink" title="aggregate 和 annotate"></a>aggregate 和 annotate</h3><p>通过 aggregate 和 annotate 可以使用 SQL 的聚合函数，例如 SUM、COUNT、MIN 等。aggregate: 针对所有记录调用聚合函数，返回一个 dict 对象，下面是使用示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Min</span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Sum</span><br><span class="line"></span><br><span class="line">result = Blog.objects.aggregate(Min(<span class="string">'id'</span>))</span><br><span class="line"><span class="keyword">print</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;u'id__min': 3L&#125;</span></span><br><span class="line"><span class="comment"># SELECT MIN(`orm_blog`.`id`) AS `id__min` FROM `orm_blog`</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义属性名</span></span><br><span class="line">result = Blog.objects.aggregate(total=Sum(<span class="string">'id'</span>))</span><br><span class="line"><span class="keyword">print</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;'total': Decimal(‘657')&#125;</span></span><br><span class="line"><span class="comment"># SELECT SUM(`orm_blog`.`id`) AS `total` FROM `orm_blog</span></span><br></pre></td></tr></table></figure></p><p>annotate 先使用 groupby 分组，然后对于每组再调用聚合函数，返回 QuerySet 对象。 annotate 默认按照 id 进行分组，如果需要按其他字段分组，要结合 values ／values_list 方法。下面是使用示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#认按照 id 进行分组</span></span><br><span class="line">blogs = Blog.objects.annotate(Count(<span class="string">'title'</span>))</span><br><span class="line"><span class="keyword">for</span> blog <span class="keyword">in</span> blogs:</span><br><span class="line">    <span class="keyword">print</span> blog.title__count</span><br><span class="line"></span><br><span class="line"><span class="comment"># SELECT `orm_blog`.`id`,  `orm_blog`.`author_id`,  `orm_blog`.`title`,  `orm_blog`.`content`,  </span></span><br><span class="line"><span class="comment"># COUNT(`orm_blog`.`title`) AS `title__count` FROM `orm_blog` GROUP BY `orm_blog`.`id` ORDER BY NULL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 values 方法，会按照 values 中传入的属性分组</span></span><br><span class="line">blogs = Blog.objects.values(<span class="string">'title'</span>).annotate(Count(<span class="string">'title'</span>))</span><br><span class="line"><span class="keyword">for</span> blog <span class="keyword">in</span> blogs:</span><br><span class="line">   <span class="keyword">print</span> blog[<span class="string">'title__count'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># SELECT `orm_blog`.`title`,  COUNT(`orm_blog`.`title`) AS `title__count` FROM `orm_blog`</span></span><br><span class="line"><span class="comment"># GROUP BY `orm_blog`.`title` ORDER BY NULL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">blogs = Blog.objects.values(<span class="string">'title'</span>, <span class="string">'content'</span>).annotate(Count(<span class="string">'title'</span>))</span><br><span class="line"><span class="keyword">for</span> blog <span class="keyword">in</span> blogs:</span><br><span class="line">   <span class="keyword">print</span> blog[<span class="string">'title__count'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># SELECT `orm_blog`.`title`,  `orm_blog`.`content`,  COUNT(`orm_blog`.`title`) AS `title__count`</span></span><br><span class="line"><span class="comment"># FROM `orm_blog` GROUP BY `orm_blog`.`title`,  `orm_blog`.`content` ORDER BY NULL</span></span><br></pre></td></tr></table></figure></p><p>下图是 aggregate 和 annotate 的比较：</p><p><img src="/images/orm/agg.png" alt></p><h3 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h3><p>如何一些查询比较复杂可以考虑使用 extra 方法。extra 能在 ORM 生成的 SQL 子句中注入 SQL 代码，语法格式如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 至少保证一个参数不为空</span></span><br><span class="line">extra(select=<span class="literal">None</span>, where=<span class="literal">None</span>, params=<span class="literal">None</span>, tables=<span class="literal">None</span>, order_by=<span class="literal">None</span>, select_params=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></p><ul><li><p>select：在 select 子句中插入 SQL 代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">blogs = Blog.objects.extra(select=&#123;</span><br><span class="line">    <span class="string">'is_one'</span>: ‘id=<span class="number">5</span><span class="string">'</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string"># SELECT (id=5) AS `is_one`,  `orm_blog`.`id`. . . . .</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">authors = Author.objects.extra(</span></span><br><span class="line"><span class="string">    select=&#123;</span></span><br><span class="line"><span class="string">        '</span>blog_count<span class="string">' : '</span>select count(*) <span class="keyword">from</span> orm_blog where orm_blog.author_id = orm_author.id<span class="string">'</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"># SELECT (select count(*) from orm_blog where orm_blog.author_id = orm_author.id) AS `blog_count` . . .</span></span><br></pre></td></tr></table></figure></li><li><p>select_params: 设置 select 参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">blogs = Blog.objects.extra(</span><br><span class="line">    select=&#123;</span><br><span class="line">        <span class="string">'a'</span>: <span class="string">'%s'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    select_params=(‘id=<span class="number">1</span><span class="string">',)</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"># SELECT ('</span>id=<span class="number">1</span><span class="string">') AS `a` . . . . .</span></span><br></pre></td></tr></table></figure></li><li><p>where: 在 where 子句中插入 SQL 代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blogs = Blog.objects.extra(</span><br><span class="line">    where=[<span class="string">'id=4 or id=5'</span>]</span><br><span class="line">)</span><br><span class="line"><span class="comment"># SELECT . . . . . . FROM `orm_blog` WHERE (id=4 or id=5)</span></span><br></pre></td></tr></table></figure></li><li><p>params: 为 where 设置参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">blogs = Blog.objects.extra(</span><br><span class="line">    where=[<span class="string">'id=%s'</span>],</span><br><span class="line">    params=(<span class="number">1</span>,))</span><br><span class="line"></span><br><span class="line"><span class="comment"># SELECT . . . . . . FROM `orm_blog` WHERE (id=1)</span></span><br></pre></td></tr></table></figure></li><li><p>tables: 在 FROM 子句中插入 table 名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blogs = Blog.objects.extra(</span><br><span class="line">    tables=[<span class="string">'orm_author'</span>, <span class="string">'auth_group'</span>]</span><br><span class="line">)</span><br><span class="line"><span class="comment"># SELECT . . . . . . FROM `orm_blog` ,  `orm_author` ,  `auth_group`</span></span><br></pre></td></tr></table></figure></li><li><p>order_by：在 order_by 子句中插入排序字段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># - 表示倒序</span></span><br><span class="line">blogs = Blog.objects.extra(</span><br><span class="line">    order_by=[<span class="string">'-id'</span>, <span class="string">'title'</span>]</span><br><span class="line">)</span><br><span class="line"><span class="comment"># SELECT . . . . . . FROM `orm_blog` ORDER BY `orm_blog`.`id` DESC,  `orm_blog`.`title` ASC</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="原始-SQL-查询"><a href="#原始-SQL-查询" class="headerlink" title="原始 SQL 查询"></a>原始 SQL 查询</h3><p>使用 Manager 的 raw 方法可以用于原始的 SQL 查询，并返回 Model 的实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blogs = Blog.objects.raw(<span class="string">'select * from orm_blog'</span>)</span><br><span class="line"><span class="keyword">for</span> blog <span class="keyword">in</span> blogs:</span><br><span class="line">    <span class="keyword">print</span> blog.id , blog.title</span><br></pre></td></tr></table></figure></p><p>如果 SQL 中没有获取某个字段，那么会惰性加载该字段<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有取 title，在后面使用时会访问数据库</span></span><br><span class="line">blogs = Blog.objects.raw(<span class="string">'select id from orm_blog'</span>)</span><br><span class="line"><span class="keyword">for</span> blog <span class="keyword">in</span> blogs:</span><br><span class="line">    <span class="keyword">print</span> blog.id</span><br><span class="line">    <span class="keyword">print</span> blog.title</span><br><span class="line"></span><br><span class="line"><span class="comment"># select id from orm_blog</span></span><br><span class="line"><span class="comment"># SELECT `orm_blog`.`id`,  `orm_blog`.`title` FROM `orm_blog` WHERE `orm_blog`.`id` = 3</span></span><br><span class="line"><span class="comment"># SELECT `orm_blog`.`id`,  `orm_blog`.`title` FROM `orm_blog` WHERE `orm_blog`.`id` = 4</span></span><br><span class="line"><span class="comment">#. . . .</span></span><br></pre></td></tr></table></figure></p><h3 id="一些优化"><a href="#一些优化" class="headerlink" title="一些优化"></a>一些优化</h3><ul><li><p>如果只需要判断实例是否存在，使用 exists 更高效</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">blogs = Blog.objects.filter(id=<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> blogs.exists():</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'record exist’</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># SELECT (1) AS `a` FROM `orm_blog` WHERE `orm_blog`.`id` = 5 LIMIT 1</span></span><br></pre></td></tr></table></figure></li><li><p>如果只需要得到实例的数量，使用 count 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blogs = Blog.objects.filter(id=<span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> blogs.count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># SELECT COUNT(*) AS `__count` FROM `orm_blog` WHERE `orm_blog`.`id` = 5</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;ORM，即Object-Relational Mapping（对象关系映射），它的作用是在关系型数据库和业务实体对象之间作一个映射，这样，我们在具体的操作业务对象的时候，就不需要再去和复杂的SQL语句打交道，只需简单的操作对象的属性和方法。下面是一个示例。通过使用 ORM，我们只需要操作 Author 和 Blog 对象，而不用操作相关的数据库表。这里主要介绍一下 Django ORM 的相关使用。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://blog.zhangjikai.com/categories/Python/"/>
    
    
      <category term="学习笔记" scheme="http://blog.zhangjikai.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Django ORM" scheme="http://blog.zhangjikai.com/tags/Django-ORM/"/>
    
  </entry>
  
  <entry>
    <title>【Vue】使用 Vue2 开发一个项目列表展示应用</title>
    <link href="http://blog.zhangjikai.com/2017/04/27/%E3%80%90Vue%E3%80%91%E4%BD%BF%E7%94%A8-Vue2-%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E5%88%97%E8%A1%A8%E5%B1%95%E7%A4%BA%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.zhangjikai.com/2017/04/27/【Vue】使用-Vue2-开发一个项目列表展示应用/</id>
    <published>2017-04-27T00:50:58.000Z</published>
    <updated>2019-09-08T06:53:07.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直没有找到一个合适的展示个人项目的模板，所以自己动手使用 Vue 写了一个。该模板基于 Markdown 文件进行配置，只需要按一定规则编写 Markdown 文件，然后使用一个 <a href="http://project.zhangjikai.com/generator/" target="_blank" rel="noopener">在线工具</a> 转为 JSON 文件即可。下面是该项目的在线地址和源码。本文主要记录一下项目中用到的相关知识。</p><p><a href="http://project.zhangjikai.com/" target="_blank" rel="noopener">在线演示</a> &nbsp;&nbsp; <a href="https://github.com/zhangjikai/project-list-template" target="_blank" rel="noopener">源码</a></p><a id="more"></a><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>程序最终的效果如下图所示：</p><p><img src="/images/project/screenshot.png" style="border: 1px solid #ddd;"></p><p>整个项目只包含两个组件：项目介绍 和 侧边导航，逻辑比较简单，十分适合入门。</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>这里我们使用 Gulp 和 Webpack 用作项目构建工具。初次使用 Gulp 和 Webpack 可能不太适应，因为它们的配置可能让你看的一头雾水。不过不用担心，这两个毕竟只是一个工具，在初始时没有必要特别的了解它们的工作原理，只要能运行起来就可以。等到使用了一段时间之后，自然而然的就知道该如何配置了。这里主要记录一下项目中使用的配置，如果想要系统的学习如何使用这两个工具，可以参考下面的文章：</p><ul><li><a href="https://markpop.github.io/2014/09/17/Gulp%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">Gulp入门教程</a></li><li><a href="http://www.cnblogs.com/vajoy/p/4650467.html" target="_blank" rel="noopener">一小时包教会 —— webpack 入门指南</a></li></ul><h3 id="Gulp-和-Webpack-集成"><a href="#Gulp-和-Webpack-集成" class="headerlink" title="Gulp 和 Webpack 集成"></a>Gulp 和 Webpack 集成</h3><p>Gulp 和 Webpack 集成一个比较简单的方式就是将 Webpack 作为 Gulp 的一个 task，如下面的形式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">"gulp"</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">"webpack"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//webpack配置文件</span></span><br><span class="line">    <span class="keyword">var</span> config = &#123;</span><br><span class="line">        watch: <span class="literal">true</span>,</span><br><span class="line">        entry: &#123;</span><br><span class="line">            index: __dirname + <span class="string">'/src/js/index.js'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        output: &#123;</span><br><span class="line">            path: __dirname + <span class="string">'/dist/js'</span>,</span><br><span class="line">            filename: <span class="string">'[name].js'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;;</span><br><span class="line">    webpack(config, <span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(stats.toString());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [ <span class="string">'webpack'</span>]);</span><br></pre></td></tr></table></figure></p><p>下面我们分别介绍一下 gulp 和 webpack 的配置</p><h3 id="Gulp-配置"><a href="#Gulp-配置" class="headerlink" title="Gulp 配置"></a>Gulp 配置</h3><p>Gulp 中主要配置了两个任务：webpack 和 browserSync，这里主要说一下 browserSync。browserSync 主要用来自动刷新浏览器。首先我们配置需要监听的文件，当这些文件发生改变后，调用 browserSync 使浏览器自动刷新页面。下面是具体的配置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">"gulp"</span>);</span><br><span class="line"><span class="keyword">var</span> browserSync = <span class="built_in">require</span>(<span class="string">'browser-sync'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 browserSync 任务</span></span><br><span class="line">gulp.task(<span class="string">'browserSync'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    browserSync(&#123;</span><br><span class="line">        server: &#123;</span><br><span class="line">            baseDir: <span class="string">'.'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        port: <span class="number">80</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置需要监听的文件，当这些文件发生变化之后</span></span><br><span class="line"><span class="comment">// 将调用 browserSync.reload 使浏览器自动刷新</span></span><br><span class="line">gulp.task(<span class="string">"watch"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.watch(<span class="string">"./**/*.html"</span>, browserSync.reload);</span><br><span class="line">    gulp.watch(<span class="string">"dist/**/*.js"</span>, browserSync.reload);</span><br><span class="line">    gulp.watch(<span class="string">"dist/**/*.css"</span>, browserSync.reload);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到默认任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'browserSync'</span>, <span class="string">'watch'</span>, <span class="string">'webpack'</span>]);</span><br></pre></td></tr></table></figure></p><h3 id="Webpack-配置"><a href="#Webpack-配置" class="headerlink" title="Webpack 配置"></a>Webpack 配置</h3><p>我们使用 webpack 进行资源打包的工作，就是说将各种资源（css、js、图片等）交给 Webpack 进行管理，它会将资源整合压缩，我们在页面中只需引用压缩之后的文件即可。webpack 的基础配置文件如下所示<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">"webpack"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//webpack配置文件</span></span><br><span class="line">    <span class="keyword">var</span> config = &#123;</span><br><span class="line">        <span class="comment">// true 表示 监听文件的变化</span></span><br><span class="line">        watch: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 加载的插件项</span></span><br><span class="line">        plugins: [</span><br><span class="line">            <span class="keyword">new</span> ExtractTextPlugin(<span class="string">"../css/[name].css"</span>)</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// 入口文件配置</span></span><br><span class="line">        entry: &#123;</span><br><span class="line">            index: __dirname + <span class="string">'/src/js/index.js'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 输出文件配置</span></span><br><span class="line">        output: &#123;</span><br><span class="line">            path: __dirname + <span class="string">'/dist/js'</span>,</span><br><span class="line">            filename: <span class="string">'[name].js'</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="built_in">module</span>: &#123;</span><br><span class="line">            <span class="comment">// 加载器配置，它告诉 Webpack 每一种文件需要采用什么加载器来处理，</span></span><br><span class="line">            <span class="comment">// 只有配置好了加载器才能处理相关的文件。</span></span><br><span class="line">            <span class="comment">// test 用来测试是什么文件，loader 表示对应的加载器</span></span><br><span class="line">            loaders: [</span><br><span class="line">                &#123;<span class="attr">test</span>: <span class="regexp">/\.vue$/</span>, <span class="attr">loader</span>: <span class="string">'vue-loader'</span>&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        resolve: &#123;</span><br><span class="line">            <span class="comment">// 模块别名定义，方便后续直接引用别名，无须多写长长的地址</span></span><br><span class="line">            <span class="comment">// 例如下面的示例，使用时只需要写 import Vue from "vue"</span></span><br><span class="line">            alias: &#123;</span><br><span class="line">                vue: path.join(__dirname, <span class="string">"/node_modules/vue/dist/vue.min.js"</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 自动扩展文件后缀名，在引入文件时只需写文件名，而不用写后缀</span></span><br><span class="line">            extensions: [<span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.less'</span>, <span class="string">'.vue'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    webpack(config, <span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(stats.toString());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>webpack 的相关配置说明可以参考前面的给出的文章，下面说一下使用 webpack 2 遇到的坑：</p><h4 id="extract-text-webpack-plugin"><a href="#extract-text-webpack-plugin" class="headerlink" title="extract-text-webpack-plugin"></a>extract-text-webpack-plugin</h4><p>extract-text-webpack-plugin 会将 css 样式打包成一个独立的 css 文件，而不是直接将样式打包到 js 文件中。下面是使用方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    plugins: [<span class="keyword">new</span> ExtractTextPlugin(<span class="string">"../css/[name].css"</span>)],</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        loaders: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            loader: ExtractTextPlugin.extract(&#123;</span><br><span class="line">                fallback: <span class="string">"style-loader"</span>,</span><br><span class="line">                use: <span class="string">"css-loader"</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">            loader: ExtractTextPlugin.extract(&#123;</span><br><span class="line">                fallback: <span class="string">"style-loader"</span>,</span><br><span class="line">                use: <span class="string">"css-loader!less-loader"</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里需要注意的地方就是，extract-text-webpack-plugin 在 webpack 1 和 webapck 2 中的安装方式不同，需要根据使用的 webpack 版本来安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># for webpack 1</span><br><span class="line">npm install --save-dev extract-text-webpack-plugin</span><br><span class="line"># for webpack 2</span><br><span class="line">npm install --save-dev extract-text-webpack-plugin@beta</span><br></pre></td></tr></table></figure></p><h4 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h4><p>使用 UglifyJsPlugin 插件可以压缩 css 和 js 文件，但是一开始时总是无法压缩文件，后来查阅了一下资料，大概是因为下面几个原因：</p><ol><li><p>uglifyjs-webpack-plugin 依赖于 uglify-js，而 uglify-js 默认不支持 ES6 语法，所以需要安装支持 ES6 语法的 uglify-js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mishoo/UglifyJS2#harmony --save</span><br></pre></td></tr></table></figure></li><li><p>webpack 2 中，UglifyJsPlugin 默认不压缩 loaders，如果要启动 loaders 压缩，需要加入下面的配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">    minimize: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ol><p>如果按上面的修改了还是不能压缩文件，可以试着将 node_modules 删除，然后重新安装依赖。</p><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>本部分主要记录一下程序中用到的 Vue 语法，如果想要系统的学习一下 Vue.js，可以参考下面的文章：</p><ul><li><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">Vue.js 教程</a></li></ul><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><p>我们首先来看一个最简单的 Vue 示例：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">            message: <span class="string">'Hello Vue!'</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>每个 Vue 应用都会创建一个 Vue 的根实例，在根实例中需要传入 html 标签的 id，用来告诉 Vue 该标签中的内容需要被 Vue 来解析。上面是一个简单的数据绑定的示例，在运行实 &#123;{ message }} 会被解析为 “Hello Vue!”。</p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><blockquote><p>本节参考自 Vue 中文文档，略有修改</p></blockquote><p>在写 Vue 应用之前，我们要熟悉一下 Vue 的基本语法，主要包括数据绑定、事件处理、条件、循环等，下面我们依次看下相关的知识。</p><h4 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h4><p>Vue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。下面是 Vue.js 数据绑定的相关语法：</p><ul><li><p><strong>文本</strong><br>  数据绑定最常见的形式就是使用 “Muestache” 语法（双大括号），如下面的形式：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  Muestache 标签会被解析为对应对象上的 msg 属性值。当 msg 属性发生改变之后，Muestache 标签处解析的内容也会随着更新。</p><p>  通过使用 <code>v-once</code> 指令，我们可以执行一次性解析，即数据改变时，解析的内容不会随着更新。需要注意的是 <code>v-once</code> 会影响该节点上的所有数据绑定</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>This will never change: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Raw HTML</strong><br>  不论属性值是什么内容，Muestache 标签里的内容都会被解析为纯文本。如果希望将绑定的值解析为 HTML 格式，就需要使用 <code>v-html</code> 指令：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">"variable"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>属性值</strong><br>  Mustache 语法不能用在 HTML 的属性中，如果想为属性绑定变量，需要使用 <code>v-bind</code> 指令：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"dynamicId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  假设 <code>dynamicId=1</code>，那么上面代码就会被解析为</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  另外 <code>v-bind</code> 指令可以被缩写为 <code>:</code>，所以我们在程序中经常看到的是下面的语法形式：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:id</span>=<span class="string">"dynamicId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等价于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"dynamicId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>表达式</strong><br>  对于所有的数据绑定， Vue.js 都提供了完全的 JavaScript 表达式支持，如下面的形式：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 加法</span><br><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">// 三元表达式</span><br><span class="line">&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;</span><br><span class="line"></span><br><span class="line">// JS 库函数</span><br><span class="line">&#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br><span class="line"></span><br><span class="line">// 指令中使用表达式</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"'list-' + id"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><p>通过使用 <code>v-on</code> 指令可以监听 DOM 事件来触发 JS 处理函数，下面是一个完整的示例：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"increase"</span>&gt;</span>增加 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line">            counter: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="actionscript">            increase: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.counter++;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>通常情况下，<code>v-on</code> 会被简写为 <code>@</code>，所以我们在程序中一般是看到下面的形式<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"increase"</span>&gt;</span>增加 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等价于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"increase"</span>&gt;</span>增加 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="条件指令-v-if"><a href="#条件指令-v-if" class="headerlink" title="条件指令 v-if"></a>条件指令 v-if</h4><p>通过 v-if 指令我们可以根据某些条件来决定是否渲染内容，如下面的形式<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span>Yes<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>我们通常将 v-if 和 v-else 结合起来使用，如下所示：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"Math.random() &gt; 0.5"</span>&gt;</span></span><br><span class="line">    Now you see me</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">      Now you don't</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在 Vue 2.1.0 中新增了一个 v-else-if 指令，可以进行链式判断：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"type === 'A'"</span>&gt;</span></span><br><span class="line">    A</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'B'"</span>&gt;</span></span><br><span class="line">      B</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'C'"</span>&gt;</span></span><br><span class="line">      C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">      Not A/B/C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="循环指令-v-for"><a href="#循环指令-v-for" class="headerlink" title="循环指令 v-for"></a>循环指令 v-for</h4><p>通过 <code>v-for</code> 指令，我们可以根据一组数据进行迭代渲染，下面是一个基本示例：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">        &#123;&#123; item.message &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#example-1'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        items: [</span><br><span class="line">              &#123;<span class="attr">message</span>: <span class="string">'Foo'</span> &#125;,</span><br><span class="line">              &#123;<span class="attr">message</span>: <span class="string">'Bar'</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面是一个简单的对数组迭代的示例，我们还可以针对对象进行迭代，如果只使用一个参数，就是针对对象的属性值进行迭代：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"repeat-object"</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"value in object"</span>&gt;</span></span><br><span class="line">        &#123;&#123; value &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果传入第二个参数，就是针对对象的属性值以及属性名进行迭代，注意这里二个参数表示的是属性名，也就是 key<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(value, key) in object"</span>&gt;</span></span><br><span class="line">    &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果再传入第三个参数，第三个参数就表示索引<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(value, key, index) in object"</span>&gt;</span></span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>组件是 Vue.js 最强大的功能之一。组件可以扩展 HTML元素，封装可重用的代码。在我们的程序中包含两个组件：project 组件和 sidebar 组件，如下图所示。这里我们主要介绍单文件组件的使用，即将组件用到 html、js 和 css 都写在一个文件里，每个组件自成一个系统。</p><p><img src="/images/project/screenshot2.png" style="border: 1px solid #ddd;"></p><h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><p>单文件组件一般使用 “.vue” 作为后缀名，一般的文件结构如下所示：</p><blockquote><p>project.vue</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        &#123;&#123; key &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">        data: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="string">"key"</span>: <span class="string">"value"</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        methods:  &#123;</span><br><span class="line"><span class="actionscript">            demoMethod: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span>&gt;</span></span><br><span class="line"><span class="css">    @<span class="keyword">import</span> <span class="string">"xxx.less"</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>export 将模块输出，default 表明使用文件名作为模块输出名，这就类似于将模块在系统中注册一下，然后其他模块才可用使用 import 引用该模块。</p><p>然后我们需要在主文件中注册该组件：</p><blockquote><p>index.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> project <span class="keyword">from</span> <span class="string">'../components/project/project.vue'</span></span><br><span class="line">Vue.component(<span class="string">"project"</span>, project);</span><br></pre></td></tr></table></figure><p>当注册完成之后，就可以 html 中使用该组件了</p><blockquote><p>index.html</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>Vue 的要给组件会经历 创建 -&gt; 编译 -&gt; 挂载 -&gt; 卸载 -&gt; 销毁 等一系列事件，这些事件发生的前后都会触发一个相关的钩子（hook）函数，通过这些钩子函数，我们可以在事件发生的前后做一些操作，下面先看下官方给出的一个 Vue 对象的生命周期图，其中红框内标出的就是对应的钩子函数</p><p><img src="/images/project/lifecycle.png" alt></p><p>下面是关于这些钩子函数的解释：</p><table><thead><tr><th style="text-align:left">hook</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">beforeCreate</td><td style="text-align:left">组件实例刚被创建，组件属性计算之前</td></tr><tr><td style="text-align:left">created</td><td style="text-align:left">组件实例创建完成，属性已绑定，但是 DOM 还未生成， <code>$el</code> 属性还不存在</td></tr><tr><td style="text-align:left">beforeMount</td><td style="text-align:left">模板编译/挂载之前</td></tr><tr><td style="text-align:left">mounted</td><td style="text-align:left">模板编译/挂载之后</td></tr><tr><td style="text-align:left">mounted</td><td style="text-align:left">模板编译/挂载之后（不保证组件已在 document 中）</td></tr><tr><td style="text-align:left">beforeUpdate</td><td style="text-align:left">组件更新之前</td></tr><tr><td style="text-align:left">updated</td><td style="text-align:left">组件更新之后</td></tr><tr><td style="text-align:left">activated</td><td style="text-align:left">for <code>keep-alive</code>，组件被激活时调用</td></tr><tr><td style="text-align:left">deactivated</td><td style="text-align:left">for <code>keep-alive</code>，组件被移除时调用</td></tr><tr><td style="text-align:left">beforeDestory</td><td style="text-align:left">组件销毁前调用</td></tr><tr><td style="text-align:left">destoryed</td><td style="text-align:left">组件销毁后调用</td></tr></tbody></table><p>下面是钩子函数的使用方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"component created"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    data &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h4><p>父子组件通信可以使用 props down 和 events up 来描述，父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息，下面示意图：</p><p><img src="/images/project/父子组件.png" alt></p><blockquote><p>图片来自 <a href="https://github.com/webplus/blog/issues/10" target="_blank" rel="noopener">https://github.com/webplus/blog/issues/10</a></p></blockquote><h5 id="父组件向子组件传递数据"><a href="#父组件向子组件传递数据" class="headerlink" title="父组件向子组件传递数据"></a>父组件向子组件传递数据</h5><p>通过使用 props，父组件可以把数据传递给子组件，这种传递是单向的，当父组件的属性发生变化时，会传递给子组件，但是不会反过来。下面是一个示例</p><blockquote><p>comp.vue</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; message &#125;&#125;&#123;&#123; shortMsg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">        props: [<span class="string">"message"</span>, <span class="string">"shortMsg"</span>],</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>index.html</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在这里将信息传递给子组件，:message 表示子组件中的变量名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">comp</span> <span class="attr">:message</span>=<span class="string">"hello"</span> <span class="attr">:short-msg</span> = <span class="string">"hi"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">            <span class="string">"hello"</span>: <span class="string">"Hello"</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="string">"hi"</span>: <span class="string">"Hi"</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的流程中，父组件首先将要传递的数据绑定到子组件的属性上，然后子组件在 props 中声明与绑定属性相同的变量名，就可以使用该变量了，需要注意的一点是如果变量采用驼峰的命名方式，在绑定属性时，就要将驼峰格式改为 <code>-</code> 连接的形式，如果上面所示 <code>shortMsg</code> -&gt; <code>short-msg</code>。</p><h5 id="子组件向父组件通信"><a href="#子组件向父组件通信" class="headerlink" title="子组件向父组件通信"></a>子组件向父组件通信</h5><p>如果子组件需要把信息传递给父组件，可以使用自定义事件：</p><ol><li>使用 $on(eventName) 监听事件</li><li>使用 $emit(eventName) 触发事件</li></ol><p>下面是一个示例：</p><blockquote><p>comp.vue</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="actionscript">            noticeParent: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 事件名，传输值</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.$emit(<span class="string">'child_change'</span>, <span class="string">"value"</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>index.html</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">comp</span> @<span class="attr">child_change</span>=<span class="string">"childChange"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="actionscript">            childChange: <span class="function"><span class="keyword">function</span><span class="params">(msg)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"child change"</span>, msg);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，父组件通过 <code>v-on</code> 绑定了 child_chagne 事件，当 child_chagne 事件被触发时候就会调用 childChange 方法。在子组件中可以通过 <code>$emit</code> 触发 child_change 事件。这里需要注意的是事件名不用采用驼峰命名，也不要用 <code>-</code> 字符，可以使用下划线 <code>_</code> 连接单词。</p><h4 id="Event-Bus-通信"><a href="#Event-Bus-通信" class="headerlink" title="Event Bus 通信"></a>Event Bus 通信</h4><p>Event Bus 通信模式是一种更加通用的通信方式，它既可以用于父子组件也可以用于非父子组件。它的原理就是使用一个空的 Vue 实例作为中央事件总线，通过自定义事件的监听和触发，来完成通信功能，下面是一个示意图：</p><p><img src="/images/project/eventbus.jpg" alt></p><blockquote><p>图片来自 <a href="https://github.com/webplus/blog/issues/10" target="_blank" rel="noopener">https://github.com/webplus/blog/issues/10</a></p></blockquote><p>下面我们来看一个具体的实例：</p><ul><li><p>首先定义一个空的 Vue 实例，作为事件总线</p><blockquote><p>EventBus.js</p></blockquote>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure></li><li><p>在组件一中针对某个事件进行监听</p><blockquote><p>comp1.vue</p></blockquote>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">"EventBus.js"</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    created: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        eventBus.$on(<span class="string">"change"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"change"</span>);</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在组件二中触发相应事件完成通信</p><blockquote><p>comp2.vue</p></blockquote>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">"EventBus.js"</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;  </span></span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="actionscript">        notice: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.$emit(<span class="string">'change'</span>, <span class="string">"value"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><blockquote><p>本节摘自 ECMAScript 6 入门</p></blockquote><p>与 ES5 相比，ES6 提供了更加完善的功能和语法，程序中我们使用部分 ES6 语法，这里做一个简单的记录，如果想要系统的学习 ES6，可以参考下面的文章：</p><ul><li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门</a></li></ul><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>ES6 新增了 let 命令，用于声明变量。使用 let 声明的变量具有块级作用域，所以在声明变量时，应该使用 let，而不是 var。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><h3 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for of 循环"></a>for of 循环</h3><p>ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for…of循环，作为遍历所有数据结构的统一的方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v); <span class="comment">// red green blue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Set-和-Map"><a href="#Set-和-Map" class="headerlink" title="Set 和 Map"></a>Set 和 Map</h3><p>ES6 引入了 Set 和 Map 结构。下面是两者的具体介绍</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><blockquote><p>属性</p></blockquote><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Set.prototype.size</td><td style="text-align:left">返回Set实例的成员总数。</td></tr></tbody></table><blockquote><p>方法</p></blockquote><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">add(value)</td><td style="text-align:left">添加某个值，返回Set结构本身。</td></tr><tr><td style="text-align:left">delete(value)</td><td style="text-align:left">删除某个值，返回一个布尔值，表示删除是否成功。</td></tr><tr><td style="text-align:left">has(value)</td><td style="text-align:left">返回一个布尔值，表示该值是否为Set的成员。</td></tr><tr><td style="text-align:left">clear()</td><td style="text-align:left">清除所有成员，没有返回值。</td></tr><tr><td style="text-align:left">&nbsp;</td><td style="text-align:left">&nbsp;</td></tr><tr><td style="text-align:left">keys()</td><td style="text-align:left">返回键名的遍历器</td></tr><tr><td style="text-align:left">values()</td><td style="text-align:left">返回键值的遍历器</td></tr><tr><td style="text-align:left">entries()</td><td style="text-align:left">返回键值对的遍历器</td></tr><tr><td style="text-align:left">forEach()</td><td style="text-align:left">使用回调函数遍历每个成员</td></tr></tbody></table><p>使用示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><blockquote><p>属性</p></blockquote><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Map.prototype.size</td><td style="text-align:left">返回 Map 实例的成员总数。</td></tr></tbody></table><blockquote><p>方法</p></blockquote><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">set(key, value)</td><td style="text-align:left">set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。</td></tr><tr><td style="text-align:left">get(key)</td><td style="text-align:left">读取 key 对应的键值，如果找不到 key，返回 undefined。</td></tr><tr><td style="text-align:left">has(key)</td><td style="text-align:left">返回一个布尔值，表示某个键是否在当前 Map 对象之中。</td></tr><tr><td style="text-align:left">delete(key)</td><td style="text-align:left">删除某个键，返回true。如果删除失败，返回false。</td></tr><tr><td style="text-align:left">clear()</td><td style="text-align:left">清除所有成员，没有返回值。</td></tr><tr><td style="text-align:left">&nbsp;</td><td style="text-align:left">&nbsp;</td></tr><tr><td style="text-align:left">keys()</td><td style="text-align:left">返回键名的遍历器</td></tr><tr><td style="text-align:left">values()</td><td style="text-align:left">返回键值的遍历器</td></tr><tr><td style="text-align:left">entries()</td><td style="text-align:left">返回所有成员的遍历器</td></tr><tr><td style="text-align:left">forEach()</td><td style="text-align:left">遍历 Map 的所有成员。</td></tr></tbody></table><p>使用示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">p</span>: <span class="string">'Hello World'</span>&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, <span class="string">'content'</span>)</span><br><span class="line">m.get(o) <span class="comment">// "content"</span></span><br><span class="line"></span><br><span class="line">m.has(o) <span class="comment">// true</span></span><br><span class="line">m.delete(o) <span class="comment">// true</span></span><br><span class="line">m.has(o) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://discipled.me/posts/troubleshooting-of-upgrading-vue" target="_blank" rel="noopener">Vue 2.0 升（cai）级（keng）之旅</a></li><li><a href="https://github.com/webplus/blog/issues/10" target="_blank" rel="noopener">Vue 2.0开发实践（组件间通讯）</a></li><li><a href="http://blog.csdn.net/DeNan_Kong/article/details/68490836" target="_blank" rel="noopener">Vuejs2.0 组件通讯总结</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;一直没有找到一个合适的展示个人项目的模板，所以自己动手使用 Vue 写了一个。该模板基于 Markdown 文件进行配置，只需要按一定规则编写 Markdown 文件，然后使用一个 &lt;a href=&quot;http://project.zhangjikai.com/generator/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在线工具&lt;/a&gt; 转为 JSON 文件即可。下面是该项目的在线地址和源码。本文主要记录一下项目中用到的相关知识。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://project.zhangjikai.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在线演示&lt;/a&gt; &amp;nbsp;&amp;nbsp; &lt;a href=&quot;https://github.com/zhangjikai/project-list-template&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://blog.zhangjikai.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://blog.zhangjikai.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>【Java 并发】详解 ThreadPoolExecutor</title>
    <link href="http://blog.zhangjikai.com/2017/04/22/%E3%80%90Java-%E5%B9%B6%E5%8F%91%E3%80%91%E8%AF%A6%E8%A7%A3-ThreadPoolExecutor/"/>
    <id>http://blog.zhangjikai.com/2017/04/22/【Java-并发】详解-ThreadPoolExecutor/</id>
    <published>2017-04-22T12:39:28.000Z</published>
    <updated>2019-09-08T06:53:07.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>线程池是并发中一项常用的优化方法，通过对线程复用，减少线程的创建，降低资源消耗，提高程序响应速度。在 Java 中我们一般通过 Exectuors 提供的工厂方法来创建线程池，但是线程池的最终实现类是 ThreadPoolExecutor，下面我们详细分析一下 ThreadPoolExecutor 的实现。<br><a id="more"></a></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>我们首先看下线程池的基本使用。在下面的代码中我们创建一个固定大小的线程池，该线程池中最多包含 5 个线程，当任务数量超过线程的数量时，就将任务添加到任务队列，等线程空闲之后再从任务队列中获取任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Jikai Zhang on 2017/4/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String command;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WorkThread</span><span class="params">(String command)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.command = command;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread-"</span> + Thread.currentThread().getId() + <span class="string">" start. Command="</span> + command);</span><br><span class="line">            processCommand();</span><br><span class="line">            System.out.println(<span class="string">"Thread-"</span> + Thread.currentThread().getId() + <span class="string">" end."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            Runnable work = <span class="keyword">new</span> WorkThread(<span class="string">""</span> + i);</span><br><span class="line">            executor.execute(work);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Finish all threads."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在分析线程池的具体实现之前，我们首先看下线程池具体的工作流程，只有先熟悉了流程，才能更好的理解线程池的实现。线程池一般都会关联一个任务队列，用来缓存任务，当线程执行完一个任务之后，会从任务队列中取下一个任务。ThreadPoolExecutor 中使用阻塞队列作为任务队列，当任务队列为空时，就会阻塞请求任务的线程。下面是 ThreadPoolExecutor 整体的图示：</p><p><img src="/images/threadpool/线程池.png" alt></p><blockquote><p>图片来自 Java 并发编程的艺术</p></blockquote><p>下面我们着重看下 ThreadPoolExecutor 添加任务和关闭线程池的流程。下图是 ThreadPoolExecutor 添加任务的流程：</p><p><img src="/images/threadpool/添加任务.png" alt></p><p>我们首先看下添加任务的具体流程：</p><ul><li>如果线程池中的线程数量少于 corePoolSize，那么直接创建一个新的线程（不论线程池中是否有空闲线程），然后把该任务分配给新建线程，同时将线程加入到线程池中。</li><li>如果线程池的线程数量大于等于 corePoolSize，就将任务添加到任务队列</li><li>如果任务队列已经饱和（对于有边界的任务队列），那么就看下线程池中的线程数量是否少于 maximumPoolSize，如果少于，就创建新的线程，将当前任务分配给新线程，同时将线程加入到线程池中。否则就对该任务执行 reject 策略。</li></ul><p>在 ThreadPoolExecutor 中通过两个量来控制线程池的大小：corePoolSize 和 maximumPoolSize。corePoolSize 表示正常状态下线程池中应该持有的存活线程数量，maximumPoolSize 表示线程池可以持有的最大线程数量。当线程池中的线程数量不超过 corePoolSize 时，位于线程池中的线程被看作 core 线程，默认情况下，线程池不对 core 线程进行超时控制，也就是 core 线程会一直存活在线程池中，直到线程池被关闭（这里忽略线程异常关闭的情况）。当线程池中的线程数量超过 corePoolSize 时，额外的线程被看作非 core 线程，线程池会对这部分线程进行超时控制，当线程空闲一段时间之后会销毁该线程。非 core 线程主要用来处理某段时间并发任务特别多的情况，即之前的线程配置无法及时处理那么多的任务量，需要额外的线程来帮助。而当这批任务处理完成之后，额外的线程就有些多余了（线程越多占的资源越多），因此需要及时销毁。</p><p>ThreadPoolExecutor 定义线程数量上限是 <code>2^29 - 1 = 536870911</code>（后面会讲到为什么是这个数），同时用户可以自定义最大线程数量，ThreadPoolExecutor 处理时会选两者之间的较小值。当线程池的线程数量等于 maximumPoolSize 时，说明线程池也已经饱和了，此时对于新来的任务就要执行 reject 策略，JDK 中定义了四种拒绝策略：</p><ul><li>AbortPolicy：直接抛出异常，默认策略</li><li>CallerRunsPolicy：使用调用者所在的线程执行任务</li><li>DiscardOldestPolicy：丢弃当前任务队列中最前面的任务，并执行 execute 方法添加新任务</li><li>DiscardPolicy：直接丢弃任务</li></ul><p>下面再看一下线程池的关闭。线程池的关闭分为两种：平缓关闭（shutdown）和立即关闭（shutdownNow）。当调用 shutdown 方法之后，线程池不再接受新的任务，但是仍然会将任务队列中已有的任务执行完毕。而调用 shutdownNow 方法之后，线程池不仅不再接受新的任务，也不会再执行任务队列中剩余的任务，同时会通过中断的方式尝试停止正在执行任务的线程（我们知道对于中断，线程可能响应也可能不响应，所以不能保证一定停止线程）。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>下面我们从源码的角度分析一下 ThreadPoolExecutor 的实现。</p><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p>ThreadPoolExecutor 中每个线程都关联一个 Worker 对象，而 ThreadPool 里实际上保存的就是线程关联的 Worker 对象。 Worker 类对线程进行包装，它除了保存关联线程的信息，还保存一些其他的信息，如线程创建时分配的首任务，线程已完成的任务数量。Worker 实现了 Runnable 接口，创建线程时往 Thread 类传的参数就是该对象，所以线程创建后会执行 Worker 的 run 方法。同时 Worker 类还继承了 AbstractQueuedSynchronizer，使自身成为一个不可重入的互斥锁（以下称为 Worker 锁，注意 Worker 锁是不可重入的，也就是说该锁只能被一个线程获取一次），因此每个线程实际上也关联了一个互斥锁。当线程执行任务时，需要首先获得关联的 Worker 锁，执行完任务之后再释放该锁。Worker 锁的主要作用是为了平缓关闭线程池时，判断线程是否空闲（根据能否获得 Worker 锁），后续会详细讲解。下面是 Worker 类的实现，我们只保留了一些必要的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 Worker 对象关联的线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">// 线程创建后的初始任务</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">// 线程完成的任务数量</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="comment">// 只有 state 为 0，线程才能获取到 Worker 锁，这里将 state 设为 -1，</span></span><br><span class="line">        <span class="comment">// 表明任何线程都无法获取锁，在 shutdown 方法中，如果要中断线程，需要首先获得线程</span></span><br><span class="line">        <span class="comment">// 关联的 Worker 锁，而 shutdownNow 中断线程之前，会首先判断 state 是否大于等于 0</span></span><br><span class="line">        <span class="comment">// 所以这里将 state 设为 -1，可以防止当前线程被中断</span></span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 创建线程时将自身传入</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="comment">// 线程创建之后会运行该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要线程启动了，就中断线程，用于 shutdownNow 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到在 Worker 的构造函数中将 state 设为了 -1，注释里给出的解释是：禁止中断直到执行了 runWorker 方法。其实这里包含了两个问题：1.为什么要等到执行了 runWorker 方法 2.怎样禁止中断。对于第一个问题，我们知道中断是针对运行的线程，当线程创建之后只有调用了 start 方法，线程才真正运行，而 start 方法的调用是在 runWorker 方法中的，也就是有只有执行了 runWorker 方法，线程才真正启动。对于第二个问题，这个主要是针对 shutdown 和 shutdownNow 方法的。在 shutdown 方法中，中断线程之前会首先尝试获取线程的 Worker 锁，只有获得了 Worker 锁才对线程进行中断。而获得 Worker 锁的前提是 Worker 的锁的状态变量 state 为 0，当 state 设为 -1 之后，任何线程都无法获得该锁，那么也就无法对线程执行中断操作。而在 shutdownNow 方法中，会调用 Worker 的 interruptIfStarted 方法来中断线程，而 interruptIfStarted 方法只有在 state &gt;= 0 时才会中断线程，所以将 state 设为 -1 可以防止线程被提前中断。当执行 runWorker 方法时，会为传入 Worker 对象执行 unlock 操作（也就是将 state 加 1），使 Worker 对象的 state 变为 0，这样就使线程处于可被中断的状态了。</p><h3 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h3><p>在 ThreadPoolExecutor 中定义了一个 AtomicInteger 类型的变量 ctl，用来保存线程池的状态和线程数量信息。下面是该变量的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure></p><p>ctl 使用低 29 位保存线程的数量（这就是线程池最大线程数量为 <code>2^29-1</code> 的原因），高 3 位保存线程池的状态。为了提取出这两个信息，ThreadPoolExecutor 定义了一个低 29 位全为 1 的变量 CAPACITY，通过和 CAPACITY 进行 &amp; 运算可以获得线程的数量，通过和 ~CAPACITY 进行 &amp; 运算可以获得线程池的状态，下面是程序中的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储线程数量的 bit 位数，这里是 29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于提取线程池的运行状态以及线程数量，低 29 位全为 1，高 3 位为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得线程池的运行状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; ~CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得线程的数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ThreadPoolExecutor 中为线程池定义了五种状态：</p><ul><li>RUNNING：正常状态，接受新的任务，并处理任务队列中的任务</li><li>SHUTDOWN：不接受新的任务，但是处理已经在任务队列中的任务</li><li>STOP： 不接受新的任务，也不处理已经在任务队列中的任务，同时会尝试停止正在执行任务的线程</li><li>TIDYING： 线程池和任务队列都为空，该状态下线程会执行 terminated() 方法</li><li>TERMINATED：terminated() 方法执行完毕</li></ul><p>下面是 JDK 中关于这 5 个变量的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 11100000000000000000000000000000  -536870912</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 00000000000000000000000000000000  0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN = <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 00100000000000000000000000000000  536870912</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP = <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 01000000000000000000000000000000  1073741824</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING = <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 01100000000000000000000000000000  1610612736</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED = <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure></p><p>下面是各状态之间的转换：</p><ul><li>RUNNING -&gt; SHUTDOWN：调用了 shutdown() 方法 （perhaps implicitly in finalize()）</li><li>(RUNNING or SHUTDOWN) -&gt; STOP：调用了shutdownNow() 方法</li><li>SHUTDOWN -&gt; TIDYING：线程池和任务队列都为空</li><li>STOP -&gt; TIDYING：线程池为空</li><li>TIDYING -&gt; TERMINATED：执行完 terminated() 方法</li></ul><p><img src="/images/threadpool/状态转换.png" alt></p><h3 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h3><p>通过 execute 或者 submit 方法都可以向线程池中添加一个任务，submit 会返回一个 Future 对象来获取线程的返回值，下面是 submit 方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future &lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture &lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们看到 submit 中只是将 Runnable 对象包装了一下，最终还是调用了 execute 方法。下面我们看下 execute 方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// command 不能为 null</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 线程数量少于 corePoolSize，会创建一个新的线程执行该任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// true 表示当前添加的线程为核心线程</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程数量大于等于 corePoolSize，首先尝试将任务添加到任务队列</span></span><br><span class="line">    <span class="comment">// workQueue.offer 会将任务添加到队列尾部</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 重新检查状态</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 如果发现当前线程池不是处于 Running 状态，就移除之前的任务</span></span><br><span class="line">        <span class="comment">// 移除任务过程有锁保护</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command)) &#123;</span><br><span class="line">            reject(command);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// workerCountOf 用来统计当前的工作线程数量，程序执行到这里，有下面两种可能：</span></span><br><span class="line">            <span class="comment">//  1. 当前线程池处于 Running 状态，但是工作线程数量为 0，</span></span><br><span class="line">            <span class="comment">//      需要创建新的线程</span></span><br><span class="line">            <span class="comment">//  2. 移除任务失败，但是工作线程数量为 0，</span></span><br><span class="line">            <span class="comment">//      需要创建新的线程来完成移除失败的任务</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">//  因为前面对任务做了判断，所以正常情况下向 addWorker 里传入的任务</span></span><br><span class="line">            <span class="comment">//  不可能为 null，这里传入 null 是告诉 addWorker 需要创建新的线程，</span></span><br><span class="line">            <span class="comment">//  在 addWorker 里对 null 有专门的处理逻辑</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 下面的 else 说明线程池不是 Running 状态或者任务队列满了，</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// 这里说明线程池不是 Running 状态或者线程池饱和了</span></span><br><span class="line">        reject(command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在前面我们提到了线程池添加任务的流程，这里再重述一下</p><ul><li>如果线程池的线程数量少于 corePoolSize，则新建一个线程，执行当前任务，并将该任务加入到线程池</li><li>如果线程池中的线程数量大于等于 corePoolSize，则首先将任务添加到任务队列</li><li>如果任务队列已满，则继续创建线程，如果线程池达到了饱和值 maximumPoolSize，则调用 reject 策略处理该任务。</li></ul><p>addWorker 方法会创建并启动线程，当线程池不处于 Running 状态并且传入的任务不为 null，addWorker 就无法成功创建线程。下面看下它的具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// retry 类似于 goto，continue retry 跳转到 retry 定义，</span></span><br><span class="line">    <span class="comment">// 而 break retry 跳出 retry</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们在下面详细讲解该条件</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span> &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 线程数量大于系统规定的最大线程数或者大于 corePoolSize/maximumPoolSize</span></span><br><span class="line">            <span class="comment">// 表明线程池中无法添加新的线程，这里 wc &gt;= CAPACITY 为了防止 corePoolSize</span></span><br><span class="line">            <span class="comment">// 或者 maximumPoolSize 大于CAPACITY</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用 CAS 方式将线程数量增加，如果成功就跳出 retry</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c)) &#123;</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            c = ctl.get(); <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 如果线程池运行状态发生了改变就从 retry（外层循环）处重新开始，</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 程序执行到这里说 CAS 没有成功，那么就再次执行 CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 work</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="comment">// t != null 说明线程创建成功了</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 程序用一个 HashSet 存储线程，而 HashSet 不是线程的安全的，</span></span><br><span class="line">            <span class="comment">// 所以将线程加入 HashSet 的过程需要加锁。</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1. rs &lt; SHUTDOWN 说明程序在运行状态</span></span><br><span class="line">                <span class="comment">// 2. rs == SHUTDOWN  说明当前线程处于平缓关闭状态，而 firstTask == null</span></span><br><span class="line">                <span class="comment">//    说明当前创建的线程是为了处理任务队列中剩余的任务（故意传入 null）</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 线程是存活状态说明线程提前开始了。</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们着重看下返回 false 的条件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span> &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">if</span>(rs &gt;= SHUTDOWN &amp;&amp; (rs != SHUTDOWN || firstTask != <span class="keyword">null</span> || workQueue.isEmpty()))</span><br></pre></td></tr></table></figure></p><p>我们依次看下上面的条件：</p><ul><li>rs &gt;= SHUTDOWN &amp;&amp; rs != SHUTDOWN：说明线程池处于 STOP，TIDYING 或者 TERMINATED 状态下，处于这三种状态说明线程池处理完了所有任务或者不再执行剩余的任务，可以直接返回</li><li>rs == SHUTDOWN &amp;&amp; firstTask != null：如果上面的条件不成立，说明当前线程池的状态一定是处于 SHUTDOWN 状态，在 execute 方法中，我们提到了如果传入 null，说明创建线程是为了执行队列中剩余的任务（此时线程池中没有工作线程），这时就不应该返回。而如果 firstTask != null，说明不是为了处理队列中剩余的任务，可以返回。</li><li>rs == SHUTDOWN &amp;&amp; workQueue.isEmpty()：说经任务队列中的任务已经全部执行完了，无需创建新的线程，可以返回。</li></ul><p>当创建了线程并成功启动之后，会执行 Worker 的 run 方法，而该方法最终调用了 ThreadPoolExecutor 的 runWorker 方法，并且将自身作为参数传进去了，下面是 runWorker 方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 这里将 Worker 中的 state 设为 0，以便其他线程可以获得锁</span></span><br><span class="line">    <span class="comment">// 从而可以中断当前线程</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">// 用来标记线程是正常退出循环还是异常退出</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果任务不为空，说明是刚创建线程，如果任务为空，则从队列中取任务</span></span><br><span class="line">        <span class="comment">// 如果队列没有任务，线程就会阻塞在这里</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 任务执行之前做一些处理，空函数，需要用户定义处理逻辑</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x;</span><br><span class="line">                    <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x;</span><br><span class="line">                    <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x;</span><br><span class="line">                    <span class="comment">// 因为 runnable 方法不能抛出 checkedException ，所以这里</span></span><br><span class="line">                    <span class="comment">// 将异常包装成 Error 抛出</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 任务执行完之后做一些处理，默认空函数</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的代码中，第一个 if 判断的逻辑有点难理解，我们将它拿出分析一下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP)))</span><br><span class="line">    &amp;&amp; !wt.isInterrupted())</span><br><span class="line">    wt.interrupt();</span><br></pre></td></tr></table></figure></p><p>这段 if 代码块的功能有两个：</p><ul><li>如果当前线程池的状态小于 STOP，也就是处于 RUNNING 或者 SHUTDOWN 状态，要保证线程池中的线程处于非中断状态</li><li>如果当前线程池的状态大于等于 STOP，也就是处于 STOP，TIDYING 或者 TERMINATED 状态，要保证线程池中的线程处于中断状态</li></ul><p>上面的 if 代码中括号比较多，我们先将其分为两个大条件：</p><ul><li>runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP)) &amp;&amp;</li><li>!wt.isInterrupted()</li></ul><p>我们先看第二个条件：!wt.isInterrupted()，该条件说明当前线程没有被中断，只有在线程没有被中断的前提下，才有可能对线程执行中断操作。然后我们将第一个大条件再进行拆分，可以分为下面两个条件：</p><ul><li>runStateAtLeast(ctl.get(), STOP) ||</li><li>Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP)</li></ul><p>我们先看第一个条件，该条件说明线程处于 STOP 以及之后的状态，线程应该被中断。如果该条件不成立，说明当前线程不应该被中断，那么会调用 Thread.interrupted() 方法，该方法会首返回线程的中断状态，然后重置线程中断状态（设为 false），如果中断状态本来就为 false，那么就可以就可以跳出 if 代码块了，但是如果中断状态是 true，说明线程被中断过了，此时我们就要判断线程的中断是不是由 shutdownNow 方法（并发调用，该方法会中断线程池的线程，并修改线程池状态为 STOP，后面会讲到）造成的，所以我们需要再检查一下线程的状态，如果发现当前线程池已经变为 STOP 或者之后的状态，说明确实是由 shutdownNow 方法造成的，需要重新对线程进行中断，如果不是那就不需要再中断线程了。</p><p>我们看到在 runWorker 里会一直循环调用 getTask 来获取任务，下面来看下 getTask 的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * getTask 返回 null，说明当前线程需要被回收了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// rs &gt;= SHUTDOWN 说明当前线程池至少处于待关闭状态，不再接受新的任务</span></span><br><span class="line">        <span class="comment">//  1. rs &gt;= STOP： 说明不需要在再处理任务了（即便有任务）</span></span><br><span class="line">        <span class="comment">//  2. workQueue.isEmpty(): 说明任务队列中剩余的任务已经处理完了</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// timed 用于判断是否需要对线程进行超时控制</span></span><br><span class="line">        <span class="comment">//  1. allowCoreThreadTimeOut: 为 true 说明可以对 core 线程进行超时控制</span></span><br><span class="line">        <span class="comment">//  2. wc &gt; corePoolSize: 说明线程池中有非 core 线程</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)</span></span><br><span class="line">        <span class="comment">//     线程数量大于 maximumPoolSize 值了 或者 允许超时控制并且超时了</span></span><br><span class="line">        <span class="comment">// 2. wc &gt; 1 || workQueue.isEmpty()</span></span><br><span class="line">        <span class="comment">//     线程中活动线程的数量大于 1 或者 任务队列为空（不需要在留线程执行剩余的任务了）</span></span><br><span class="line">        <span class="comment">// 如果上面 1 和 2 都成立，就使用 CAS 将线程数量减 1 并返回 null 回收当前线程</span></span><br><span class="line">        <span class="comment">// 如果 CAS 失败了就重试</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果允许超时控制，则执行 poll 方法，该方法响应超时，当 keepAliveTime 时间内</span></span><br><span class="line">            <span class="comment">// 仍然没有获取到任务，就返回 null。take 方法不响应超时操作，当获取不到任务时会一直等待。</span></span><br><span class="line">            <span class="comment">// 另外不管 poll 还是 take 方法都会响应中断，如果没有新的任务添加到队列中</span></span><br><span class="line">            <span class="comment">// 会直接抛出 InterruptedException</span></span><br><span class="line">            Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 执行到这里说明超时了</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当 getTask 返回 null 的时候说明线程需要被回收了，我们总结一下在 getTask 中返回 null 的情况：</p><ul><li>线程池总工作线程数量大于 maximumPoolSize（一般是由于我们调用 setMaximumPoolSize 方法重新设置了 maximumPoolSize）</li><li>线程池已经被停止 （状态 &gt;= STOP）</li><li>线程池处于 SHUTDOWN 状态，并且任务队列为空</li><li>线程在等待任务时超时</li></ul><p>我们将 runWorker 和 getTask 结合起来看，整个流程就比较明朗了：</p><ol><li>通过 while 循环不断的从任务队列中获取任务，如果当前任务队列中没有任务，就阻塞线程。如果 getTask 返回 null，表明当前线程应该被回收，执行回收线程的逻辑。</li><li>如果成功获取任务，首先判断线程池的状态，根据线程池状态设置当前线程的中断状态</li><li>在执行任务之前做一些预处理（用户实现）</li><li>执行任务</li><li>在执行任务之后做一些后处理（用户实现）</li></ol><p>上面两个方法是整个线程池中比较核心的部分，在这两个方法中，完成了任务获取与阻塞线程的工作。下面是线程 <code>提交 -&gt; 处理任务 -&gt; 回收</code> 的流程图：</p><p><img src="/images/threadpool/添加线程.png" alt></p><p>下面我们再看下 processWorkerExit 方法，该方法主要用来完成线程的回收工作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 completedAbruptly 为 true，说明线程是由于抛出异常而跳出循环的，</span></span><br><span class="line">    <span class="comment">// 没有正确执行 getTask 中减少线程数量的逻辑，所以这里要将线程数量减一</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 更新已完成的任务数量，并移除工作线程</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试终止线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果线程状态是 SHUTDOWN 或者 RUNNING，需要保证线程中的最少线程数量</span></span><br><span class="line">    <span class="comment">// 1. 如果线程是由于抛出异常而结束的，直接添加一个线程</span></span><br><span class="line">    <span class="comment">// 2. 如果线程是正常结束的</span></span><br><span class="line">    <span class="comment">//    * 如果允许对 core 线程进行超时控制，并且任务队列中有任务</span></span><br><span class="line">    <span class="comment">//      则保证线程数量大于等于 1</span></span><br><span class="line">    <span class="comment">//    * 如果不允许对 core 进行超时控制，则保证线程数量大于等于 corePoolSize</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; !workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们看到 processWorkerExit 中调用了 tryTerminate 方法，该方法主要用来终止线程池。如果线程池满足终止条件，首先将线程池状态设为 TIDYING，然后执行 terminated 方法，最后将线程池状态设为 TERMINATED。在 shutdown 和 shutdownNow 方法中也会调用该方法 。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// 如果出现下面三种情况，就不执行终止线程池的逻辑，直接返回</span></span><br><span class="line">        <span class="comment">//  1. 当前线程池处于 RUNNING 状态，不能停止</span></span><br><span class="line">        <span class="comment">//  2. 当前线程池状态为 TIDYING 或者 TERMINATED，不需要停止</span></span><br><span class="line">        <span class="comment">//  3. 当前线程池状态为 SHUTDOWN 并且任务队列不为空</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) || runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 判断工作线程的数量是否为 0</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            <span class="comment">// 如果工作线程数量不为 0，就尝试中断正在线程池中的空闲线程</span></span><br><span class="line">            <span class="comment">// ONLY_ONE 说明只尝试中断线程池中第一个线程（不管线程空不空闲）</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将线程状态设为 TIDYING，如果设置不成功说明线程池的状态发生了变化，需要重试</span></span><br><span class="line">            <span class="comment">// 这里线程池状态从 TIDYING 到 TERMINATED 状态转换是原子的</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行 terminated 方法（默认空方法）</span></span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 将线程状态设为 TERMINATED</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 tryTerminate 方法中， 如果满足下面两个条件，就将线程池状态设为 TERMINATED：</p><ol><li>线程池状态为 SHUTDOWN 并且线程池和任务队列均为空</li><li>线程池状态为 STOP 并且线程池为空</li></ol><p>如果线程池处于 SHUTDOWN 或者 STOP 状态，但是工作线程不为空，那么 tryTerminate 会尝试去中断线程池中的一个线程，这样做主要是为了防止 shutdown 的中断信号丢失（我们在 shutdown 方法处再详细讨论）。下面看下 interruptIdleWorkers 方法，该方法主要中断 <strong>空闲</strong> 线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w: workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">// 首先看当前线程是否已经中断，如果没有中断，就看线程是否处于空闲状态</span></span><br><span class="line">            <span class="comment">// 如果能获得线程关联的 Worker 锁，说明线程处于空闲状态，可以中断</span></span><br><span class="line">            <span class="comment">// 否则说明线程不能中断</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 onlyOne 为 true，只尝试中断第一个线程</span></span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>通过 shutdown 和 shutdownNow 我们可以关闭线程池，关于两者的区别在前面已经提到了，这里不再赘述。我们首先看下 shutdown 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查当前线程是否有关闭线程池的权限</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 将线程池状态设为 SHUTDOWN</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 中断线程，这里最终调用 interruptIdleWorkers(false);</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        <span class="comment">// hook 方法，默认为空，让用户在线程池关闭时可以做一些操作</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在前面我们知道 interruptIdleWorkers 会先检查线程是否是空闲状态，如果发现线程不是空闲状态，才会中断线程。而这时中断线程的主要目的是让在任务队列中阻塞的线程醒过来。考虑下面的情况，如果执行 interruptIdleWorkers 时，线程正在运行，所以没有被中断，但是线程执行完任务之后，任务队列恰好为空，线程就会处于阻塞状态，而此时 shutdown 已经执行完 interruptIdleWorkers 操作了（即线程错过了 shutdown 的中断信号），如果没有额外操作，线程会一直处于阻塞状态。所以为了防止这种情况，在 tryTerminate() 中也增加了 interruptIdleWorkers 操作，主要就是为了弥补 shutdown 中丢失的信号。</p><p>最后我们再看下 shutdownNow 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List &lt; Runnable &gt; shutdownNow() &#123;</span><br><span class="line">    List &lt; Runnable &gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查线程是否具有关闭线程池的权限</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 更改线程状态</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 中断线程</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 清除任务队列，并将任务返回</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们看下 interruptWorkers 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 不管线程是否空闲都执行中断</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w: workers)</span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的代码中我们可以看到在 interruptWorkers 方法中，只要线程开始了，就对线程执行中断，所以 shutdownNow 的中断信号不会丢失。最后我们再看下 drainQueue 方法，该方法主要作用是清空任务队列，并将队列中剩余的任务返回。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List &lt;Runnable&gt; drainQueue() &#123;</span><br><span class="line">    BlockingQueue &lt;Runnable&gt; q = workQueue;</span><br><span class="line">    ArrayList &lt;Runnable&gt; taskList = <span class="keyword">new</span> ArrayList &lt; Runnable &gt; ();</span><br><span class="line">    <span class="comment">// 该方法会将阻塞队列中的所有项添加到 taskList 中</span></span><br><span class="line">    <span class="comment">// 然后清空任务队列，该方法是线程安全的</span></span><br><span class="line">    q.drainTo(taskList);</span><br><span class="line">    <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// 将 List 转换为 数组，传入的 Runnable[0] 用来说明是转为 Runnable 数组</span></span><br><span class="line">        <span class="keyword">for</span> (Runnable r: q.toArray(<span class="keyword">new</span> Runnable[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.remove(r))</span><br><span class="line">                taskList.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> taskList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="线程池监控"><a href="#线程池监控" class="headerlink" title="线程池监控"></a>线程池监控</h2><blockquote><p>本节摘自 <a href="http://ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/" target="_blank" rel="noopener">深入理解Java线程池：ThreadPoolExecutor</a></p></blockquote><p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p><ul><li>getTaskCount：线程池已经执行的和未执行的任务总数；</li><li>getCompletedTaskCount：线程池已完成的任务数量，该值小于等于taskCount；</li><li>getLargestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了maximumPoolSize；</li><li>getPoolSize：线程池当前的线程数量；</li><li>getActiveCount：当前线程池中正在执行任务的线程数量。</li></ul><p>通过这些方法，可以对线程池进行监控，在ThreadPoolExecutor类中提供了几个空方法，如beforeExecute方法，afterExecute方法和terminated方法，可以扩展这些方法在执行前或执行后增加一些新的操作，例如统计线程池的执行任务的时间等，可以继承自ThreadPoolExecutor来进行扩展。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="http://ifeve.com/java-threadpoolexecutor/" target="_blank" rel="noopener">Java线程池架构(一)原理和源码解析</a></li><li><a href="http://www.jianshu.com/p/117571856b28" target="_blank" rel="noopener">Java线程池–原理及源码分析</a></li><li><a href="http://blog.csdn.net/qq_35101189/article/details/55804778" target="_blank" rel="noopener">http://blog.csdn.net/qq_35101189/article/details/55804778</a></li><li><a href="http://zhanjindong.com/2015/03/30/java-concurrent-package-ThreadPoolExecutor" target="_blank" rel="noopener">http://zhanjindong.com/2015/03/30/java-concurrent-package-ThreadPoolExecutor</a></li><li><a href="http://ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/" target="_blank" rel="noopener">深入理解Java线程池：ThreadPoolExecutor</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;线程池是并发中一项常用的优化方法，通过对线程复用，减少线程的创建，降低资源消耗，提高程序响应速度。在 Java 中我们一般通过 Exectuors 提供的工厂方法来创建线程池，但是线程池的最终实现类是 ThreadPoolExecutor，下面我们详细分析一下 ThreadPoolExecutor 的实现。&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="http://blog.zhangjikai.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="http://blog.zhangjikai.com/tags/Java/"/>
    
      <category term="并发" scheme="http://blog.zhangjikai.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【Java并发】详解 AbstractQueuedSynchronizer</title>
    <link href="http://blog.zhangjikai.com/2017/04/15/%E3%80%90Java-%E5%B9%B6%E5%8F%91%E3%80%91%E8%AF%A6%E8%A7%A3-AbstractQueuedSynchronizer/"/>
    <id>http://blog.zhangjikai.com/2017/04/15/【Java-并发】详解-AbstractQueuedSynchronizer/</id>
    <published>2017-04-15T12:50:58.000Z</published>
    <updated>2019-09-08T06:53:07.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>队列同步器 AbstractQueuedSynchronizer（以下简称 AQS），是用来构建锁或者其他同步组件的基础框架。它使用一个 int 成员变量来表示同步状态，通过 CAS 操作对同步状态进行修改，确保状态的改变是安全的。通过内置的 FIFO （First In First Out）队列来完成资源获取线程的排队工作。更多关于 Java 多线程的文章可以转到 <a href="http://con.zhangjikai.com/" target="_blank" rel="noopener">这里</a></p><a id="more"></a><h2 id="AQS-和-synchronized"><a href="#AQS-和-synchronized" class="headerlink" title="AQS 和 synchronized"></a>AQS 和 synchronized</h2><p>在介绍 AQS 的使用之前，需要首先说明一点，AQS 同步和 synchronized 关键字同步（以下简称 synchronized 同步）是采用的两种不同的机制。首先看下 synchronized 同步，synchronized 关键字经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码需要关联到一个监视对象，当线程执行 monitorenter 指令时，需要首先获得获得监视对象的锁，这里监视对象锁就是进入同步块的凭证，只有获得了凭证才可以进入同步块，当线程离开同步块时，会执行 monitorexit 指令，释放对象锁。</p><p>在 AQS 同步中，使用一个 int 类型的变量 state 来表示当前同步块的状态。以独占式同步（一次只能有一个线程进入同步块）为例，state 的有效值有两个 0 和 1，其中 0 表示当前同步块中没有线程，1 表示同步块中已经有线程在执行。当线程要进入同步块时，需要首先判断 state 的值是否为 0，假设为 0，会尝试将 state 修改为 1，只有<strong>修改成功</strong>了之后，线程才可以进入同步块。注意上面提到的两个条件：</p><ul><li>state 为 0，证明当前同步块中没有线程在执行，所以当前线程可以尝试获得进入同步块的凭证，而这里的凭证就是是否成功将 state 修改为 1（在 synchronized 同步中，我们说的凭证是对象锁，但是对象锁的最终实现是否和这种方式类似，没有找到相关的资料）</li><li>成功将 state 修改为 1，通过使用 CAS 操作，我们可以确保即便有多个线程同时修改 state，也只有一个线程会修改成功。关于 CAS 的具体解释会在后面提到。</li></ul><p>当线程离开同步块时，会修改 state 的值，将其设为 0，并唤醒等待的线程。所以在 AQS 同步中，我们说线程获得了锁，实际上是指线程成功修改了状态变量 state，而线程释放了锁，是指线程将状态变量置为了可修改的状态（在独占式同步中就是置为了 0），让其他线程可以再次尝试修改状态变量。在下面的表述中，我们说线程获得和释放了锁，就是上述含义， 这与 synchronized 同步中说的获得和释放锁的含义不同，需要区别理解。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><blockquote><p>本节摘自 Java 并发编程的艺术</p></blockquote><p>AQS 的设计是基于模板方法的，使用者需要继承 AQS 并重写指定的方法。在后续的流程中，AQS 提供的模板方法会调用重写的方法。一般来说，我们需要重写的方法主要有下面 5 个：</p><table><thead><tr><th style="text-align:left">方法名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">protected boolean tryAcquire(int)</td><td style="text-align:left">独占式获取锁，实现该方法需要查询当前状态并判断同步状态是否和预期值相同，然后使用 CAS 操作设置同步状态</td></tr><tr><td style="text-align:left">protected boolean tryRelease(int)</td><td style="text-align:left">独占式释放锁，实际也是修改同步变量</td></tr><tr><td style="text-align:left">protected int tryAcquireShared(int)</td><td style="text-align:left">共享式获取锁，返回大于等于 0 的值，表示获取锁成功，反之获取失败</td></tr><tr><td style="text-align:left">protected boolean tryReleaseShared(int)</td><td style="text-align:left">共享式释放锁</td></tr><tr><td style="text-align:left">protected boolean isHeldExclusively()</td><td style="text-align:left">判断调用该方法的线程是否持有互斥锁</td></tr></tbody></table><p>在自定义的同步组件中，我们一般会调用 AQS 提供的模板方法。AQS 提供的模板方法基本上分为 3 类： 独占式获取与释放锁、共享式获取与释放锁以及查询同步队列中的等待线程情况。下面是相关的模板方法：</p><table><thead><tr><th style="text-align:left">方法名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">void acquire(int)</td><td style="text-align:left">独占式获取锁，如果当前线程成功获取锁，那么方法就返回，否则会将当前线程放入同步队列等待。该方法会调用重写的 tryAcquire(int arg) 方法判断是否可以获得锁</td></tr><tr><td style="text-align:left">void acquireInterruptibly(int)</td><td style="text-align:left">和 acquire(int) 相同，但是该方法响应中断，当线程在同步队列中等待时，如果线程被中断，会抛出 InterruptedException 异常并返回。</td></tr><tr><td style="text-align:left">boolean tryAcquireNanos(int, long)</td><td style="text-align:left">在 acquireInterruptibly(int) 基础上添加了超时控制，同时支持中断和超时，当在指定时间内没有获得锁时，会返回 false，获取到了返回 true</td></tr><tr><td style="text-align:left">void acquireShared(int)</td><td style="text-align:left">共享式获得锁，如果成功获得锁就返回，否则将当前线程放入同步队列等待，与独占式获取锁的不同是，同一时刻可以有多个线程获得共享锁，该方法调用 tryAcquireShared(int)</td></tr><tr><td style="text-align:left">acquireSharedInterruptibly(int)</td><td style="text-align:left">与 acquireShared(int) 相同，该方法响应中断</td></tr><tr><td style="text-align:left">tryAcquireSharedNanos(int, long)</td><td style="text-align:left">在 acquireSharedInterruptibly(int) 基础上添加了超时控制</td></tr><tr><td style="text-align:left">boolean release(int)</td><td style="text-align:left">独占式释放锁，该方法会在释放锁后，将同步队列中第一个等待节点唤醒</td></tr><tr><td style="text-align:left">boolean releaseShared(int)</td><td style="text-align:left">共享式释放锁</td></tr><tr><td style="text-align:left">Collection<thread> getQueuedThreads()</thread></td><td style="text-align:left">获得同步队列中等待的线程集合</td></tr></tbody></table><p>自定义组件通过使用同步器提供的模板方法来实现自己的同步语义。下面我们通过两个示例，看下如何借助于 AQS 来实现锁的同步语义。我们首先实现一个独占锁（排它锁），独占锁就是说在某个时刻内，只能有一个线程持有独占锁，只有持有锁的线程释放了独占锁，其他线程才可以获取独占锁。下面是具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Created by Jikai Zhang on 2017/4/6.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 自定义独占锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过继承 AQS，自定义同步器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前线程是否被独占</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获得锁</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 只有当 state 的值为 0，并且线程成功将 state 值修改为 1 之后，线程才可以获得独占锁</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// state 为 0 说明当前同步块中没有锁了，无需释放</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将独占的线程设为 null</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 将状态变量的值设为 0，以便其他线程可以成功修改状态变量从而获得锁</span></span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将操作代理到 Sync 上</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">withoutMutex</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Without mutex: "</span>);</span><br><span class="line">        <span class="keyword">int</span> threadCount = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> Thread threads[] = <span class="keyword">new</span> Thread[threadCount];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (j % <span class="number">20000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"Thread-"</span> + index + <span class="string">": j ="</span> + j);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">withMutex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"With mutex: "</span>);</span><br><span class="line">        <span class="keyword">final</span> Mutex mutex = <span class="keyword">new</span> Mutex();</span><br><span class="line">        <span class="keyword">int</span> threadCount = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> Thread threads[] = <span class="keyword">new</span> Thread[threadCount];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    mutex.lock();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (j % <span class="number">20000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                                System.out.println(<span class="string">"Thread-"</span> + index + <span class="string">": j ="</span> + j);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        mutex.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        withoutMutex();</span><br><span class="line">        System.out.println();</span><br><span class="line">        withMutex();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序的运行结果如下面所示。我们看到使用了 Mutex 之后，线程 0 和线程 1 不会再交替执行，而是当一个线程执行完，另外一个线程再执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Without mutex:</span><br><span class="line">Thread-0: j =0</span><br><span class="line">Thread-1: j =0</span><br><span class="line">Thread-0: j =20000</span><br><span class="line">Thread-1: j =20000</span><br><span class="line">Thread-0: j =40000</span><br><span class="line">Thread-1: j =40000</span><br><span class="line">Thread-0: j =60000</span><br><span class="line">Thread-1: j =60000</span><br><span class="line">Thread-1: j =80000</span><br><span class="line">Thread-0: j =80000</span><br><span class="line"></span><br><span class="line">With mutex:</span><br><span class="line">Thread-0: j =0</span><br><span class="line">Thread-0: j =20000</span><br><span class="line">Thread-0: j =40000</span><br><span class="line">Thread-0: j =60000</span><br><span class="line">Thread-0: j =80000</span><br><span class="line">Thread-1: j =0</span><br><span class="line">Thread-1: j =20000</span><br><span class="line">Thread-1: j =40000</span><br><span class="line">Thread-1: j =60000</span><br><span class="line">Thread-1: j =80000</span><br></pre></td></tr></table></figure></p><p>下面在看一个共享锁的示例。在该示例中，我们定义两个共享资源，即同一时间内允许两个线程同时执行。我们将同步变量的初始状态 state 设为 2，当一个线程获取了共享锁之后，将 state 减 1，线程释放了共享锁后，将 state 加 1。状态的合法范围是 0、1 和 2，其中 0 表示已经资源已经用光了，此时线程再要获得共享锁就需要进入同步序列等待。下面是具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Jikai Zhang on 2017/4/9.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 自定义共享锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwinsLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Sync</span><span class="params">(<span class="keyword">int</span> resourceCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (resourceCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"resourceCount must be larger than zero."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置可以共享的资源总数</span></span><br><span class="line">            setState(resourceCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> reduceCount)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 使用尝试获得资源，如果成功修改了状态变量（获得了资源）</span></span><br><span class="line">            <span class="comment">// 或者资源的总量小于 0（没有资源了），则返回。</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> lastCount = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = lastCount - reduceCount;</span><br><span class="line">                <span class="keyword">if</span> (newCount &lt; <span class="number">0</span> || compareAndSetState(lastCount, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> newCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> returnCount)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 释放共享资源，因为可能有多个线程同时执行，所以需要使用 CAS 操作来修改资源总数。</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> lastCount = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = lastCount + returnCount;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(lastCount, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义两个共享资源，说明同一时间内可以有两个线程同时运行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireShared(<span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> TwinsLock();</span><br><span class="line">        <span class="keyword">int</span> threadCounts = <span class="number">10</span>;</span><br><span class="line">        Thread threads[] = <span class="keyword">new</span> Thread[threadCounts];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCounts; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                        lock.lock();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                            System.out.println(Thread.currentThread().getName());</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            lock.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCounts; i++) &#123;</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行程序，我们会发现程序每次都会同时打印两条语句，如下面的形式，证明同时有两个线程在执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread-0</span><br><span class="line">Thread-1</span><br><span class="line">Thread-3</span><br><span class="line">Thread-2</span><br><span class="line">Thread-8</span><br><span class="line">Thread-4</span><br><span class="line">Thread-3</span><br><span class="line">Thread-6</span><br></pre></td></tr></table></figure></p><h2 id="CAS-操作"><a href="#CAS-操作" class="headerlink" title="CAS 操作"></a>CAS 操作</h2><p>CAS（Compare and Swap），比较并交换，通过利用底层硬件平台的特性，实现原子性操作。CAS 操作涉及到3个操作数，内存值 V，旧的期望值 A，需要修改的新值 B。当且仅当预期值 A 和 内存值 V 相同时，才将内存值 V 修改为 B，否则什么都不做。CAS 操作类似于执行了下面流程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(oldValue == memory[valueAddress]) &#123;</span><br><span class="line">    memory[valueAddress] = newValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的流程中，其实涉及到了两个操作，比较以及替换，为了确保程序正确，需要确保这两个操作的原子性（也就是说确保这两个操作同时进行，中间不会有其他线程干扰）。现在的 CPU 中，提供了相关的底层 CAS 指令，即 CPU 底层指令确保了比较和交换两个操作作为一个原子操作进行（其实在这一点上还是有排他锁的. 只是比起用synchronized, 这里的排他时间要短的多.），Java 中的 CAS 函数是借助于底层的 CAS 指令来实现的。更多关于 CPU 底层实现的原理可以参考 <a href="http://zl198751.iteye.com/blog/1848575" target="_blank" rel="noopener">这篇文章</a>。我们来看下 Java 中对于 CAS 函数的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically update Java variable to x if it is currently</span></span><br><span class="line"><span class="comment"> * holding expected.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object expected, Object x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically update Java variable to x if it is currently</span></span><br><span class="line"><span class="comment"> * holding expected.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> expected, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically update Java variable to x if it is currently</span></span><br><span class="line"><span class="comment"> * holding expected.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> expected, <span class="keyword">long</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p>上面三个函数定义在 sun.misc.Unsafe 类中，使用该类可以进行一些底层的操作，例如直接操作原生内存，更多关于 Unsafe 类的文章可以参考 <a href="http://ifeve.com/sun-misc-unsafe/" target="_blank" rel="noopener">这篇</a>。以 compareAndSwapInt 为例，我们看下如何使用 CAS 函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Jikai Zhang on 2017/4/8.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASIntTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得 count 属性在 CASIntTest 中的偏移量（内存地址偏移）</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            offset = unsafe.objectFieldOffset(CASIntTest.class.getDeclaredField(<span class="string">"count"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过反射的方式获得 Unsafe 类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Unsafe unsafe = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unsafe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> previous = count;</span><br><span class="line">        unsafe.compareAndSwapInt(<span class="keyword">this</span>, offset, previous, previous + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CASIntTest casIntTest = <span class="keyword">new</span> CASIntTest();</span><br><span class="line">        casIntTest.increment();</span><br><span class="line">        System.out.println(casIntTest.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 CASIntTest 类中，我们定义一个 count 变量，其中 increment 方法是将 count 的值加 1。下面是 increase 方法的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> previous = count;</span><br><span class="line">unsafe.compareAndSwapInt(<span class="keyword">this</span>, offset, previous, previous + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>在没有线程竞争的条件下，该代码执行的结果是将 count 变量的值加 1（多个线程竞争可能会有线程执行失败），但是在 compareAndSwapInt 函数中，我们并没有传入 count 变量，那么函数是如何修改的 count 变量值？其实我们往 compareAndSwapInt 函数中传入了 count 变量在堆内存中的地址，函数直接修改了 count 变量所在内存区域。count 属性在堆内存中的地址是由 CASIntTest 实例的起始内存地址和 count 属性相对于起始内存的偏移量决定的。其中对象属性在对象中的偏移量通过 <code>objectFieldOffset</code> 函数获得，函数原型如下所示。该函数接受一个 Filed 类型的参数，返回该 Filed 属性在对象中的偏移量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Report the location of a given static field, in conjunction with &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #staticFieldBase&#125;.</span></span><br><span class="line"><span class="comment"> * Do not expect to perform any sort of arithmetic on this offset;</span></span><br><span class="line"><span class="comment"> * it is just a cookie which is passed to the unsafe heap memory accessors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Any given field will always have the same offset, and no two distinct</span></span><br><span class="line"><span class="comment"> * fields of the same class will ever have the same offset.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * As of 1.4.1, offsets for fields are represented as long values,</span></span><br><span class="line"><span class="comment"> * although the Sun JVM does not use the most significant 32 bits.</span></span><br><span class="line"><span class="comment"> * It is hard to imagine a JVM technology which needs more than</span></span><br><span class="line"><span class="comment"> * a few bits to encode an offset within a non-array object,</span></span><br><span class="line"><span class="comment"> * However, for consistency with other methods in this class,</span></span><br><span class="line"><span class="comment"> * this method reports its result as a long value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">objectFieldOffset</span><span class="params">(Field f)</span></span>;</span><br></pre></td></tr></table></figure><p>下面我们再看一下 compareAndSwapInt 的函数原型。我们知道 CAS 操作需要知道 3 个信息：内存中的值，期望的旧值以及要修改的新值。通过前面的分析，我们知道通过 o 和 offset 我们可以确定属性在内存中的地址，也就是知道了属性在内存中的值。expected 对应期望的旧址，而 x 就是要修改的新值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> expected, <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p>compareAndSwapInt 函数首先比较一下 expected 是否和内存中的值相同，如果不同证明其他线程修改了属性值，那么就不会执行更新操作，但是程序如果就此返回了，似乎不太符合我们的期望，我们是希望程序可以执行更新操作的，如果其他线程先进行了更新，那么就在更新后的值的基础上进行修改，所以我们一般使用循环配合 CAS 函数，使程序在更新操作完成之后再返回，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> before = counter;</span><br><span class="line"><span class="keyword">while</span> (!unsafe.compareAndSwapLong(<span class="keyword">this</span>, offset, before, before + <span class="number">1</span>)) &#123;</span><br><span class="line">    before = counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是使用 CAS 函数实现计数器的一个实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Jikai Zhang on 2017/4/8.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASCounter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反射的方式获得 Unsafe 类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Unsafe unsafe = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unsafe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> offset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = getUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            offset = unsafe.objectFieldOffset(CASCounter.class.getDeclaredField(<span class="string">"counter"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> before = counter;</span><br><span class="line">        <span class="keyword">while</span> (!unsafe.compareAndSwapLong(<span class="keyword">this</span>, offset, before, before + <span class="number">1</span>)) &#123;</span><br><span class="line">            before = counter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> intCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threadCount = <span class="number">10</span>;</span><br><span class="line">        Thread threads[] = <span class="keyword">new</span> Thread[threadCount];</span><br><span class="line">        <span class="keyword">final</span> CASCounter casCounter = <span class="keyword">new</span> CASCounter();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        casCounter.increment();</span><br><span class="line">                        intCounter++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"CASCounter is %d \nintCounter is %d\n"</span>, casCounter.getCounter(), intCounter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 AQS 中，对原始的 CAS 函数封装了一下，省去了获得变量地址的步骤，如下面的形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> waitStatusOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        waitStatusOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(<span class="string">"waitStatus"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetWaitStatus</span><span class="params">(Node node, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(node, waitStatusOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2><p>AQS 依赖内部的同步队列（一个 FIFO的双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把队列中第一个等待节点线程唤醒（下图中的 Node1），使其再次尝试获取同步状态。同步队列的结构如下所示：</p><p><img src="/images/aqs/同步队列.png" alt></p><blockquote><p>图片来自 <a href="http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer</a></p></blockquote><p>Head 节点本身不保存等待线程的信息，它通过 next 变量指向第一个保存线程等待信息的节点（Node1）。当线程被唤醒之后，会删除 Head 节点，而唤醒线程所在的节点会设置为 Head 节点（Node1 被唤醒之后，Node1会被置为 Head 节点）。下面我们看下 JDK 中同步队列的实现。</p><h3 id="Node-类"><a href="#Node-类" class="headerlink" title="Node 类"></a>Node 类</h3><p>首先看在节点所对应的 Node 类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标志是独占式模式还是共享模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程等待状态的有效值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程状态，合法值为上面 4 个值中的一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前节点的前置节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前节点的后置节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前节点所关联的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向下一个在某个条件上等待的节点，或者指向 SHARE 节点，表明当前处于共享模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123; <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123; <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 Node 类中定义了四种等待状态：</p><ul><li>CANCELED： 1，因为等待超时 （timeout）或者中断（interrupt），节点会被置为取消状态。处于取消状态的节点不会再去竞争锁，也就是说不会再被阻塞。节点会一直保持取消状态，而不会转换为其他状态。处于 CANCELED 的节点会被移出队列，被 GC 回收。</li><li>SIGNAL： -1，表明当前的后继结点正在或者将要被阻塞（通过使用 LockSupport.pack 方法），因此当前的节点被释放（release）或者被取消时（cancel）时，要唤醒它的后继结点（通过 LockSupport.unpark 方法）。</li><li>CONDITION： -2，表明当前节点在条件队列中，因为等待某个条件而被阻塞。</li><li>PROPAGATE： -3，在共享模式下，可以认为资源有多个，因此当前线程被唤醒之后，可能还有剩余的资源可以唤醒其他线程。该状态用来表明后续节点会传播唤醒的操作。需要注意的是只有头节点才可以设置为该状态（This is set (for head node only) in doReleaseShared to ensure propagation continues, even if other operations have since intervened.）。</li><li>0：新创建的节点会处于这种状态</li></ul><h3 id="独占锁的获取和释放"><a href="#独占锁的获取和释放" class="headerlink" title="独占锁的获取和释放"></a>独占锁的获取和释放</h3><p>我们首先看下独占锁的获取和释放过程</p><p><strong>独占锁获取</strong></p><p>下面是获取独占锁的流程图：<br><img src="/images/aqs/获取独占锁.png" alt></p><p>我们通过 acquire 方法来获取独占锁，下面是方法定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先尝试获取锁，如果获取失败，会先调用 addWaiter 方法创建节点并追加到队列尾部</span></span><br><span class="line">    <span class="comment">// 然后调用 acquireQueued 阻塞或者循环尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))&#123;</span><br><span class="line">        <span class="comment">// 在 acquireQueued 中，如果线程是因为中断而退出的阻塞状态会返回 true</span></span><br><span class="line">        <span class="comment">// 这里的 selfInterrupt 主要是为了恢复线程的中断状态</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>acquire 会首先调用 tryAcquire 方法来获得锁，该方法需要我们来实现，这个在前面已经提过了。如果没有获取锁，会调用 addWaiter 方法创建一个和当前线程关联的节点追加到同步队列的尾部，我们调用 addWaiter 时传入的是 Node.EXCLUSIVE，表明当前是独占模式。下面是 addWaiter 的具体实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// tail 指向同步队列的尾节点</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>addWaiter 方法会首先调用 if 方法，来判断能否成功将节点添加到队列尾部，如果添加失败，再调用 enq 方法（使用循环不断重试）进行添加，下面是 enq 方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">// 同步队列采用的懒初始化（lazily initialized）的方式，</span></span><br><span class="line">        <span class="comment">// 初始时 head 和 tail 都会被设置为 null，当一次被访问时</span></span><br><span class="line">        <span class="comment">// 才会创建 head 对象，并把尾指针指向 head。</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>addWaiter 仅仅是将节点加到了同步队列的末尾，并没有阻塞线程，线程阻塞的操作是在 acquireQueued 方法中完成的，下面是 acquireQueued 的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果当前节点的前继节点是 head，就使用自旋（循环）的方式不断请求锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 成功获得锁，将当前节点置为 head 节点，同时删除原 head 节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// shouldParkAfterFailedAcquire 检查是否可以挂起线程，</span></span><br><span class="line">            <span class="comment">// 如果可以挂起进程，会调用 parkAndCheckInterrupt 挂起线程，</span></span><br><span class="line">            <span class="comment">// 如果 parkAndCheckInterrupt 返回 true，表明当前线程是因为中断而退出挂起状态的，</span></span><br><span class="line">            <span class="comment">// 所以要将 interrupted 设为 true，表明当前线程被中断过</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>acquireQueued 会首先检查当前节点的前继节点是否为 head，如果为 head，将使用自旋的方式不断的请求锁，如果不是 head，则调用 shouldParkAfterFailedAcquire 查看是否应该挂起当前节点关联的线程，下面是 shouldParkAfterFailedAcquire 的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前节点的前继节点的等待状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 如果前继节点的等待状态为 SIGNAL 我们就可以将当前节点对应的线程挂起</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ws 大于 0，表明当前线程的前继节点处于 CANCELED 的状态，</span></span><br><span class="line">        <span class="comment">// 所以我们需要从当前节点开始往前查找，直到找到第一个不为</span></span><br><span class="line">        <span class="comment">// CAECELED  状态的节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>shouldParkAfterFailedAcquire 会检查前继节点的等待状态，如果前继节点状态为 SIGNAL，则可以将当前节点关联的线程挂起，如果不是 SIGNAL，会做一些其他的操作，在当前循环中不会挂起线程。如果确定了可以挂起线程，就调用 parkAndCheckInterrupt 方法对线程进行阻塞：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 挂起当前线程</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 可以通过调用 interrupt 方法使线程退出 park 状态，</span></span><br><span class="line">    <span class="comment">// 为了使线程在后面的循环中还可以响应中断，会重置线程的中断状态。</span></span><br><span class="line">    <span class="comment">// 这里使用 interrupted 会先返回线程当前的中断状态，然后将中断状态重置为 false，</span></span><br><span class="line">    <span class="comment">// 线程的中断状态会返回给上层调用函数，在线程获得锁后，</span></span><br><span class="line">    <span class="comment">// 如果发现线程曾被中断过，会将中断状态重新设为 true</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>独占锁释放</strong></p><p>下面是释放独占锁的流程：<br><img src="/images/aqs/释放独占锁.png" alt></p><p>通过 release 方法，我们可以释放互斥锁。下面是 release 方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// waitStatus 为 0，证明是初始化的空队列或者后继结点已经被唤醒了</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在独占模式下释放锁时，是没有其他线程竞争的，所以处理会简单一些。首先尝试释放锁，如果失败就直接返回（失败不是因为多线程竞争，而是线程本身就不拥有锁）。如果成功的话，会检查 h 的状态，然后调用 unparkSuccessor 方法来唤醒后续线程。下面是 unparkSuccessor 的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 将 head 节点的状态置为 0，表明当前节点的后续节点已经被唤醒了，</span></span><br><span class="line">    <span class="comment">// 不需要再次唤醒，修改 ws 状态主要作用于 release 的判断</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 unparkSuccessor 方法中，如果发现头节点的后继结点为 null 或者处于 CANCELED 状态，会从尾部往前找（在节点存在的前提下，这样一定能找到）离头节点最近的需要唤醒的节点，然后唤醒该节点。</p><h3 id="共享锁获取和释放"><a href="#共享锁获取和释放" class="headerlink" title="共享锁获取和释放"></a>共享锁获取和释放</h3><p>独占锁的流程和原理比较容易理解，因为只有一个锁，但是共享锁的处理就相对复杂一些了。在独占锁中，只有在释放锁之后，才能唤醒等待的线程，而在共享模式中，获取锁和释放锁之后，都有可能唤醒等待的线程。如果想要理清共享锁的工作过程，必须将共享锁的获取和释放结合起来看。这里我们先看一下共享锁的释放过程，只有明白了释放过程做了哪些工作，才能更好的理解获取锁的过程。</p><p><strong>共享锁释放</strong></p><p>下面是释放共享锁的流程：<br><img src="/images/aqs/释放共享锁.png" alt></p><p>通过 releaseShared 方法会释放共享锁，下面是具体的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>releases 是要释放的共享资源数量，其中 tryReleaseShared 的方法由我们自己重写，该方法的主要功能就是修改共享资源的数量（state + releases），因为可能会有多个线程同时释放资源，所以实现的时候，一般采用循环加 CAS 操作的方式，如下面的形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 释放共享资源，因为可能有多个线程同时执行，所以需要使用 CAS 操作来修改资源总数。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> lastCount = getState();</span><br><span class="line">        <span class="keyword">int</span> newCount = lastCount + releases;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(lastCount, newCount)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当共享资源数量修改了之后，会调用 doReleaseShared 方法，该方法主要唤醒同步队列中的第一个等待节点（head.next），下面是具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// head = null 说明没有初始化，head = tail 说明同步队列中没有等待节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="comment">// 查看当前节点的等待状态</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// 我们在前面说过，SIGNAL说明有后续节点需要唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 将当前节点的值设为 0，表明已经唤醒了后继节点</span></span><br><span class="line"><span class="comment">                 * 可能会有多个线程同时执行到这一步，所以使用 CAS 保证只有一个线程能修改成功，</span></span><br><span class="line"><span class="comment">                 * 从而执行 unparkSuccessor，其他的线程会执行 continue 操作</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * ws 等于 0，说明无需唤醒后继结点（后续节点已经被唤醒或者当前节点没有被阻塞的后继结点），</span></span><br><span class="line"><span class="comment">                 * 也就是这一次的调用其实并没有执行唤醒后继结点的操作。就类似于我只需要一张优惠券，</span></span><br><span class="line"><span class="comment">                 * 但是我的两个朋友，他们分别给我了一张，因此我就剩余了一张。然后我就将这张剩余的优惠券</span></span><br><span class="line"><span class="comment">                 * 送（传播）给其他人使用，因此这里将节点置为可传播的状态（PROPAGATE）</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head) <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的实现中，doReleaseShared 的主要作用是用来唤醒阻塞的节点并且一次只唤醒一个，让该节点关联的线程去重新竞争锁，它既不修改同步队列，也不修改共享资源。</p><p>当多个线程同时释放资源时，可以确保两件事：</p><ol><li>共享资源的数量能正确的累加</li><li>至少有一个线程被唤醒，其实只要确保有一个线程被唤醒就可以了，即便唤醒了多个线程，在同一时刻，也只能有一个线程能得到竞争锁的资格，在下面我们会看到。</li></ol><p>所以释放锁做的主要工作还是修改共享资源的数量。而有了多个共享资源后，如何确保同步队列中的多个节点可以获取锁，是由获取锁的逻辑完成的。下面看下共享锁的获取。</p><p><strong>共享锁的获取</strong></p><p>下面是获取共享锁的流程<br><img src="/images/aqs/获取共享锁.png" alt></p><p>通过 acquireShared 方法，我们可以申请共享锁，下面是具体的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果返回结果小于 0，证明没有获取到共享资源</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果没有获取到共享资源，就会执行 doAcquireShared 方法，下面是该方法的具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的代码中可以看到，只有前置节点为 head 的节点才有可能去竞争锁，这点和独占模式的处理是一样的，所以即便唤醒了多个线程，也只有一个线程能进入竞争锁的逻辑，其余线程会再次进入 park 状态，当线程获取到共享锁之后，会执行 setHeadAndPropagate 方法，下面是具体的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">long</span> propagate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 备份一下头节点</span></span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 移除头节点，并将当前节点置为头节点</span></span><br><span class="line"><span class="comment">     * 当执行完这一步之后，其实队列的头节点已经发生改变，</span></span><br><span class="line"><span class="comment">     * 其他被唤醒的线程就有机会去获取锁，从而并发的执行该方法，</span></span><br><span class="line"><span class="comment">     * 所以上面备份头节点，以便下面的代码可以正确运行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    setHead(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">     *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">     *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">     *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">     *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">     *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">     * and</span></span><br><span class="line"><span class="comment">     *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">     *     or we don't know, because it appears null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">     * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">     * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">     * anyway.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 判断是否需要唤醒后继结点，propagate &gt; 0 说明共享资源有剩余，</span></span><br><span class="line"><span class="comment">      * h.waitStatus &lt; 0，表明当前节点状态可能为 SIGNAL，CONDITION，PROPAGATE</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 只有 s 不处于独占模式时，才去唤醒后继结点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>判断后继结点是否需要唤醒的条件是十分宽松的，也就是一定包含必要的唤醒，但是也有可能会包含不必要的唤醒。从前面我们可以知道 doReleaseShared 函数的主要作用是唤醒后继结点，它既不修改共享资源，也不修改同步队列，所以即便有不必要的唤醒也是不影响程序正确性的。如果没有共享资源，节点会再次进入等待状态。</p><p>到了这里，脉络就比较清晰了，当一个节点获取到共享锁之后，它除了将自身设为 head 节点之外，还会判断一下是否满足唤醒后继结点的条件，如果满足，就唤醒后继结点，后继结点获取到锁之后，会重复这个过程，直到判断条件不成立。就类似于考试时从第一排往最后一排传卷子，第一排先留下一份，然后将剩余的传给后一排，后一排会重复这个过程。如果传到某一排卷子没了，那么位于这排的人就要等待，直到老师又给了他新的卷子。</p><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>在获取锁时还可以设置响应中断，独占锁和共享锁的处理逻辑类似，这里我们以独占锁为例。使用 acquireInterruptibly 方法，在获取独占锁时可以响应中断，下面是具体的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) &#123;</span><br><span class="line">                <span class="comment">// 这里会抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的代码中我们可以看出，acquireInterruptibly 和 acquire 的逻辑类似，只是在下面的代码处有所不同：当线程因为中断而退出阻塞状态时，会直接抛出 InterruptedException 异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) &#123;</span><br><span class="line">    <span class="comment">// 这里会抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们知道，不管是抛出异常还是方法返回，程序都会执行 finally 代码，而 failed 肯定为 true，所以抛出异常之后会执行 cancelAcquire 方法，cancelAcquire 方法主要将节点从同步队列中移除。下面是具体的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn't exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过前面的已经取消的节点</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存下 pred 的后继结点，以便 CAS 操作使用</span></span><br><span class="line">    <span class="comment">// 因为可能存在已经取消的节点，所以 pred.next 不一等于 node</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">    <span class="comment">// 将节点状态设为 CANCELED</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred's next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的代码可以看出，节点的删除分为三种情况：</p><ul><li>删除节点为尾节点，直接将该节点的第一个有效前置节点置为尾节点</li><li>删除节点的前置节点为头节点，则对该节点执行 unparkSuccessor 操作</li><li>删除节点为中间节点，结果如下图所示。下图中（1）表示同步队列的初始状态，假设删除 node2， node1 是正常节点（非 CANCELED），（2）就是删除 node2 后同步队列的状态，此时 node1 节点的后继已经变为 node3，也就是说当 node1 变为 head 之后，会直接唤醒 node3。当另外的一个节点中断之后再次执行 cancelAcquire，在执行下面的代码时，会使同步队列的状态由（2）变为（3），此时 node2 已经没有外界指针了，可以被回收了。如果一直没有另外一个节点中断，也就是同步队列一直处于（2）状态，那么需要等 node3 被回收之后，node2 才可以被回收。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node pred = node.prev;</span><br><span class="line"><span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">    node.prev = pred = pred.prev;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/aqs/删除节点.png" alt></p><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>超时是在中断的基础上加了一层时间的判断，这里我们还是以独占锁为例。 tryAcquireNanos 支持获取锁的超时处理，下面是具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当获取锁失败之后，会执行 doAcquireNanos 方法，下面是具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span> L)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程最晚结束时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否超时，如果超时就返回</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span> L)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里如果设定了一个阈值，如果超时的时间比阈值小，就认为</span></span><br><span class="line">            <span class="comment">// 当前线程没必要阻塞，再执行几次 for 循环估计就超时了</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当线程超时返回时，还是会执行 cancelAcquire 方法，cancelAcquire 的逻辑已经在前面说过了，这里不再赘述。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="http://download.csdn.net/detail/u011898232/9548575" target="_blank" rel="noopener">Java 并发编程的艺术</a></li><li><a href="http://ifeve.com/sun-misc-unsafe/" target="_blank" rel="noopener">Java Magic. Part 4: sun.misc.Unsafe</a></li><li><a href="http://www.blogjava.net/mstar/archive/2013/04/24/398351.html" target="_blank" rel="noopener">Java里的CompareAndSet(CAS)</a></li><li><a href="http://blog.csdn.net/luonanqin/article/details/41871909" target="_blank" rel="noopener">ReentrantLock的lock-unlock流程详解</a></li><li><a href="http://blog.csdn.net/chen77716/article/details/6641477" target="_blank" rel="noopener">深入JVM锁机制2-Lock</a></li><li><a href="http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer" target="_blank" rel="noopener">深度解析Java 8：JDK1.8 AbstractQueuedSynchronizer的实现分析（上）</a></li><li><a href="http://www.cnblogs.com/zhanjindong/p/java-concurrent-package-aqs-AbstractQueuedSynchronizer.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码分析</a></li><li><a href="https://my.oschina.net/xianggao/blog/532709" target="_blank" rel="noopener">聊聊并发（十二）—AQS分析</a></li><li><a href="http://www.javarticles.com/2012/10/abstractqueuedsynchronizer-aqs.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer (AQS)</a></li><li><a href="http://blog.csdn.net/tomato__/article/details/24774465" target="_blank" rel="noopener">并发编程实践二：AbstractQueuedSynchronizer</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;队列同步器 AbstractQueuedSynchronizer（以下简称 AQS），是用来构建锁或者其他同步组件的基础框架。它使用一个 int 成员变量来表示同步状态，通过 CAS 操作对同步状态进行修改，确保状态的改变是安全的。通过内置的 FIFO （First In First Out）队列来完成资源获取线程的排队工作。更多关于 Java 多线程的文章可以转到 &lt;a href=&quot;http://con.zhangjikai.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="http://blog.zhangjikai.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="http://blog.zhangjikai.com/tags/Java/"/>
    
      <category term="并发" scheme="http://blog.zhangjikai.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【Java 并发】详解 ThreadLocal</title>
    <link href="http://blog.zhangjikai.com/2017/03/29/%E3%80%90Java-%E5%B9%B6%E5%8F%91%E3%80%91%E8%AF%A6%E8%A7%A3-ThreadLocal/"/>
    <id>http://blog.zhangjikai.com/2017/03/29/【Java-并发】详解-ThreadLocal/</id>
    <published>2017-03-29T12:44:27.000Z</published>
    <updated>2019-09-08T06:53:07.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ThreadLocal 主要用来提供线程局部变量，也就是变量只对当前线程可见，本文主要记录一下对于 ThreadLocal 的理解。更多关于 Java 多线程的文章可以转到 <a href="http://con.zhangjikai.com/" target="_blank" rel="noopener">这里</a>。</p><h2 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h2><p>在多线程环境下，之所以会有并发问题，就是因为不同的线程会同时访问同一个共享变量，例如下面的形式<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            value = <span class="number">10</span>;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            System.out.println(<span class="string">"increase value: "</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrease</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            value = -<span class="number">10</span>;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            System.out.println(<span class="string">"decrease value: "</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Number number = <span class="keyword">new</span> Number();</span><br><span class="line">        Thread increaseThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    number.increase();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread decreaseThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    number.decrease();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        increaseThread.start();</span><br><span class="line">        decreaseThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的代码中，increase 线程和 decrease 线程会操作同一个 number 中 value，那么输出的结果是不可预测的，因为当前线程修改变量之后但是还没输出的时候，变量有可能被另外一个线程修改，下面是一种可能的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">increase value: 10</span><br><span class="line">decrease value: 10</span><br></pre></td></tr></table></figure></p><p>一种解决方法是在 <code>increase()</code> 和 <code>decrease()</code> 方法上加上 synchronized 关键字进行同步，这种做法其实是将 value 的 <strong>赋值</strong> 和 <strong>打印</strong> 包装成了一个原子操作，也就是说两者要么同时进行，要不都不进行，中间不会有额外的操作。我们换个角度考虑问题，如果 value 只属于 increase 线程或者 decrease 线程，而不是被两个线程共享，那么也不会出现竞争问题。一种比较常见的形式就是局部（local）变量（这里排除局部变量引用指向共享对象的情况），如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    System.out.println(<span class="string">"increase value: "</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不论 value 值如何改变，都不会影响到其他线程，因为在每次调用 increase 方法时，都会创建一个 value 变量，该变量只对当前调用 increase 方法的线程可见。借助于这种思想，我们可以对每个线程创建一个共享变量的副本，该副本只对当前线程可见（可以认为是线程私有的变量），那么修改该副本变量时就不会影响到其他的线程。一个简单的思路是使用 Map 存储每个变量的副本，将当前线程的 id 作为 key，副本变量作为 value 值，下面是一个实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomThreadLocal</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;Long, Integer&gt; cacheMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> defaultValue ;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomThreadLocal</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            defaultValue = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> id = Thread.currentThread().getId();</span><br><span class="line">            <span class="keyword">if</span> (cacheMap.containsKey(id)) &#123;</span><br><span class="line">                <span class="keyword">return</span> cacheMap.get(id);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> defaultValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> id = Thread.currentThread().getId();</span><br><span class="line">            cacheMap.put(id, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CustomThreadLocal value = <span class="keyword">new</span> CustomThreadLocal(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            value.set(<span class="number">10</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            System.out.println(<span class="string">"increase value: "</span> + value.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrease</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            value.set(-<span class="number">10</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            System.out.println(<span class="string">"decrease value: "</span> + value.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Number number = <span class="keyword">new</span> Number();</span><br><span class="line">        Thread increaseThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    number.increase();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread decreaseThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    number.decrease();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        increaseThread.start();</span><br><span class="line">        decreaseThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是上面的实现会存在下面的问题：</p><ul><li>每个线程对应的副本变量的生命周期不是由线程决定的，而是由共享变量的生命周期决定的。在上面的例子中，即便线程执行完，只要 <code>number</code> 变量存在，线程的副本变量依然会存在（存放在 number 的 cacheMap 中）。但是作为特定线程的副本变量，该变量的生命周期应该由线程决定，线程消亡之后，该变量也应该被回收。</li><li>多个线程有可能会同时操作 cacheMap，需要对 cacheMap 进行同步处理。</li></ul><p>为了解决上面的问题，我们换种思路，每个线程创建一个 Map，存放当前线程中副本变量，用 CustomThreadLocal 的实例作为 key 值，下面是一个示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleImpl2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; cacheMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomThreadLocal</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> defaultValue;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomThreadLocal</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            defaultValue = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Integer id = <span class="keyword">this</span>.hashCode();</span><br><span class="line">            Map&lt;Integer, Integer&gt; cacheMap = getMap();</span><br><span class="line">            <span class="keyword">if</span> (cacheMap.containsKey(id)) &#123;</span><br><span class="line">                <span class="keyword">return</span> cacheMap.get(id);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> defaultValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            Integer id = <span class="keyword">this</span>.hashCode();</span><br><span class="line">            Map&lt;Integer, Integer&gt; cacheMap = getMap();</span><br><span class="line">            cacheMap.put(id, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Map&lt;Integer, Integer&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            CommonThread thread = (CommonThread) Thread.currentThread();</span><br><span class="line">            <span class="keyword">return</span> thread.cacheMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CustomThreadLocal value = <span class="keyword">new</span> CustomThreadLocal(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            value.set(<span class="number">10</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            System.out.println(<span class="string">"increase value: "</span> + value.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrease</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            value.set(-<span class="number">10</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            System.out.println(<span class="string">"decrease value: "</span> + value.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Number number = <span class="keyword">new</span> Number();</span><br><span class="line">        Thread increaseThread = <span class="keyword">new</span> CommonThread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    number.increase();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread decreaseThread = <span class="keyword">new</span> CommonThread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    number.decrease();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        increaseThread.start();</span><br><span class="line">        decreaseThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的实现中，当线程消亡之后，线程中 cacheMap 也会被回收，它当中存放的副本变量也会被全部回收，并且 cacheMap 是线程私有的，不会出现多个线程同时访问一个 cacheMap 的情况。在 Java 中，ThreadLocal 类的实现就是采用的这种思想，注意只是思想，实际的实现和上面的并不一样。</p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>Java 使用 ThreadLocal 类来实现线程局部变量模式，ThreadLocal 使用 set 和 get 方法设置和获取变量，下面是函数原型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>下面是使用 ThreadLocal 的一个完整示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            threadLocal.set((<span class="keyword">int</span>)(Math.random() * <span class="number">100</span>));</span><br><span class="line">            value = (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.printf(Thread.currentThread().getName() + <span class="string">": threadLocal=%d, value=%d\n"</span>, threadLocal.get(), value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadLocalThread());</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadLocalThread());</span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是一种可能的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread-0: threadLocal=87, value=15</span><br><span class="line">Thread-1: threadLocal=69, value=15</span><br></pre></td></tr></table></figure></p><p>我们看到虽然 <code>threadLocal</code> 是静态变量，但是每个线程都有自己的值，不会受到其他线程的影响。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>ThreadLocal 的实现思想，我们在前面已经说了，每个线程维护一个 ThreadLocalMap 的映射表，映射表的 key 是 ThreadLocal 实例本身，value 是要存储的副本变量。ThreadLocal 实例本身并不存储值，它只是提供一个在当前线程中找到副本值的 key。 如下图所示：</p><p><img src="/images/threadlocal/threadlocal.jpg" alt></p><blockquote><p>图片来自 <a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/" target="_blank" rel="noopener">http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/</a></p></blockquote><p>我们从下面三个方面看下 ThreadLocal 的实现：</p><ul><li>存储线程副本变量的数据结构</li><li>如何存取线程副本变量</li><li>如何对 ThreadLocal 的实例进行 Hash</li></ul><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>线程使用 ThreadLocalMap 来存储每个线程副本变量，它是 ThreadLocal 里的一个静态内部类。ThreadLocalMap 也是采用的散列表（Hash）思想来实现的，但是实现方式和 HashMap 不太一样。我们首先看下散列表的相关知识：</p><h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><p>理想状态下，散列表就是一个包含关键字的固定大小的数组，通过使用散列函数，将关键字映射到数组的不同位置。下面是理想散列表的一个示意图：</p><p><img src="/images/threadlocal/理想散列表.png" alt></p><blockquote><p>图片来自 数据结构与算法分析: C语法描述</p></blockquote><p>在理想状态下，哈希函数可以将关键字均匀的分散到数组的不同位置，不会出现两个关键字散列值相同（假设关键字数量小于数组的大小）的情况。但是在实际使用中，经常会出现多个关键字散列值相同的情况（被映射到数组的同一个位置），我们将这种情况称为散列冲突。为了解决散列冲突，主要采用下面两种方式：</p><ul><li>分离链表法（separate chaining）</li><li>开放定址法（open addressing）</li></ul><p><strong>分离链表法</strong><br>分散链表法使用链表解决冲突，将散列值相同的元素都保存到一个链表中。当查询的时候，首先找到元素所在的链表，然后遍历链表查找对应的元素。下面是一个示意图：</p><p><img src="/images/threadlocal/hash-chain.gif" alt></p><blockquote><p>图片来自 <a href="http://faculty.cs.niu.edu/~freedman/340/340notes/340hash.htm" target="_blank" rel="noopener">http://faculty.cs.niu.edu/~freedman/340/340notes/340hash.htm</a></p></blockquote><p><strong>开放定址法</strong><br>开放定址法不会创建链表，当关键字散列到的数组单元已经被另外一个关键字占用的时候，就会尝试在数组中寻找其他的单元，直到找到一个空的单元。探测数组空单元的方式有很多，这里介绍一种最简单的 – 线性探测法。线性探测法就是从冲突的数组单元开始，依次往后搜索空单元，如果到数组尾部，再从头开始搜索（环形查找）。如下图所示：</p><p><img src="/images/threadlocal/linear.jpg" alt></p><blockquote><p>图片来自 <a href="http://alexyyek.github.io/2014/12/14/hashCollapse/" target="_blank" rel="noopener">http://alexyyek.github.io/2014/12/14/hashCollapse/</a></p></blockquote><p>关于两种方式的比较，可以参考 <a href="http://www.nowamagic.net/academy/detail/3008060" target="_blank" rel="noopener">这篇文章</a>。ThreadLocalMap 中使用开放地址法来处理散列冲突，而 HashMap 中使用的分离链表法。之所以采用不同的方式主要是因为：在 ThreadLocalMap 中的散列值分散的十分均匀，很少会出现冲突。并且 ThreadLocalMap 经常需要清除无用的对象，使用纯数组更加方便。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>我们知道 Map 是一种 key-value 形式的数据结构，所以在散列数组中存储的元素也是 key-value 的形式。ThreadLocalMap 使用 Entry 类来存储数据，下面是该类的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span> &lt;<span class="title">ThreadLocal</span> &lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal &lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Entry 将 ThreadLocal 实例作为 key，副本变量作为 value 存储起来。注意 Entry 中对于 ThreadLocal 实例的引用是一个弱引用，该引用定义在 Reference 类（WeakReference的父类）中，下面是 <code>super(k)</code> 最终调用的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Reference(T referent) &#123;</span><br><span class="line">    <span class="keyword">this</span>(referent, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reference(T referent, ReferenceQueue &lt;? <span class="keyword">super</span> T&gt; queue) &#123;</span><br><span class="line">    <span class="keyword">this</span>.referent = referent;</span><br><span class="line">    <span class="keyword">this</span>.queue = (queue == <span class="keyword">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于弱引用和为什么使用弱引用可以参考 <a href="https://www.ibm.com/developerworks/cn/java/j-jtp11225/" target="_blank" rel="noopener">Java 理论与实践: 用弱引用堵住内存泄漏</a> 和 <a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/" target="_blank" rel="noopener">深入分析 ThreadLocal 内存泄漏问题</a>。下面看一下 ThreadLocalMap 的 set 函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal &lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用线性探测法查找元素</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal &lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// ThreadLocal 对应的 key 存在，直接覆盖之前的值</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key为 null，但是值不为 null，说明之前的 ThreadLocal 对象已经被回收了，当前数组中的 Entry 是一个陈旧（stale）的元素</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 用新元素替换陈旧的元素，这个方法进行了不少的垃圾清理动作，防止内存泄漏，具体可以看源代码，没看太懂</span></span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ThreadLocal 对应的 key 不存在并且没有找到陈旧的元素，则在空元素的位置创建一个新的 Entry。</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">// cleanSomeSlot 清理陈旧的 Entry（key == null），具体的参考源码。如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash。</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于 set 方法，有几点需要地方：</p><ul><li><code>int i = key.threadLocalHashCode &amp; (len - 1);</code>，这里实际上是对 len-1 进行了取余操作。之所以能这样取余是因为 len 的值比较特殊，是 2 的 n 次方，减 1 之后低位变为全 1，高位变为全 0。例如 16，减 1 之后对应的二进制为: 00001111，这样其他数字中大于 16 的部分就会被 0 与掉，小于 16 的部分就会保留下来，就相当于取余了。</li><li>在 replaceStaleEntry 和 cleanSomeSlots 方法中都会清理一些陈旧的 Entry，防止内存泄漏</li><li>threshold 的值大小为 <code>threshold = len * 2 / 3;</code></li><li>rehash 方法中首先会清理陈旧的 Entry，如果清理完之后元素数量仍然大于 threshold 的 3/4，则进行扩容操作（数组大小变为原来的 2倍）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>我们再看一下 getEntry （没有 get 方法，就叫 getEntry）方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal &lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为 ThreadLocalMap 中采用开放定址法，所以当前 key 的散列值和元素在数组中的索引并不一定完全对应。所以在 get 的时候，首先会看 key 的散列值对应的数组元素是否为要查找的元素，如果不是，再调用 <code>getEntryAfterMiss</code> 方法查找后面的元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal &lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal &lt; ? &gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后看一下删除操作。删除其实就是将 Entry 的键值设为 null，变为陈旧的 Entry。然后调用 <code>expungeStaleEntry</code> 清理陈旧的 Entry。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal &lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="副本变量存取"><a href="#副本变量存取" class="headerlink" title="副本变量存取"></a>副本变量存取</h3><p>前面说完了 ThreadLocalMap，副本变量的存取操作就很好理解了。下面是 ThreadLocal 中的 set 和 get 方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T) e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>存取的基本流程就是首先获得当前线程的 ThreadLocalMap，将 ThreadLocal 实例作为键值传入 Map，然后就是进行相关的变量存取工作了。线程中的 ThreadLocalMap 是懒加载的，只有真正的要存变量时才会调用 createMap 创建，下面是 createMap 的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果想要给 ThreadLocal 的副本变量设置初始值，需要重写 initialValue 方法，如下面的形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal &lt;Integer&gt; threadLocal = <span class="keyword">new</span> ThreadLocal() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="ThreadLocal-散列值"><a href="#ThreadLocal-散列值" class="headerlink" title="ThreadLocal 散列值"></a>ThreadLocal 散列值</h3><p>当创建了一个 ThreadLocal 的实例后，它的散列值就已经确定了，下面是 ThreadLocal 中的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadLocals rely on per-thread linear-probe hash maps attached</span></span><br><span class="line"><span class="comment"> * to each thread (Thread.threadLocals and</span></span><br><span class="line"><span class="comment"> * inheritableThreadLocals).  The ThreadLocal objects act as keys,</span></span><br><span class="line"><span class="comment"> * searched via threadLocalHashCode.  This is a custom hash code</span></span><br><span class="line"><span class="comment"> * (useful only within ThreadLocalMaps) that eliminates collisions</span></span><br><span class="line"><span class="comment"> * in the common case where consecutively constructed ThreadLocals</span></span><br><span class="line"><span class="comment"> * are used by the same threads, while remaining well-behaved in</span></span><br><span class="line"><span class="comment"> * less common cases.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next hash code to be given out. Updated atomically. Starts at</span></span><br><span class="line"><span class="comment"> * zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">    <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The difference between successively generated hash codes - turns</span></span><br><span class="line"><span class="comment"> * implicit sequential thread-local IDs into near-optimally spread</span></span><br><span class="line"><span class="comment"> * multiplicative hash values for power-of-two-sized tables.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the next hash code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们看到 threadLocalHashCode 是一个常量，它通过 <code>nextHashCode()</code> 函数产生。<code>nextHashCode()</code> 函数其实就是在一个 AtomicInteger 变量（初始值为0）的基础上每次累加 0x61c88647，使用 AtomicInteger 为了保证每次的加法是原子操作。而 0x61c88647 这个就比较神奇了，它可以使 hashcode 均匀的分布在大小为 2 的 N 次方的数组里。下面写个程序测试一下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AtomicInteger hashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">int</span> hash_increment = <span class="number">0x61c88647</span>;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">16</span>;</span><br><span class="line">    List &lt;Integer&gt; list = <span class="keyword">new</span> ArrayList &lt;&gt; ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        list.add(hashCode.getAndAdd(hash_increment) &amp; (size - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"original:"</span> + list);</span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    System.out.println(<span class="string">"sort:    "</span> + list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们将 size 设为 16，32 和 64 分别测试一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// size=16</span><br><span class="line">original:[0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9]</span><br><span class="line">sort:    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]</span><br><span class="line"></span><br><span class="line">// size=32</span><br><span class="line">original:[0, 7, 14, 21, 28, 3, 10, 17, 24, 31, 6, 13, 20, 27, 2, 9, 16, 23, 30, 5, 12, 19, 26, 1, 8, 15, 22, 29, 4, 11, 18, 25]</span><br><span class="line">sort:    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]</span><br><span class="line"></span><br><span class="line">// size=64</span><br><span class="line">original:[0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 6, 13, 20, 27, 34, 41, 48, 55, 62, 5, 12, 19, 26, 33, 40, 47, 54, 61, 4, 11, 18, 25, 32, 39, 46, 53, 60, 3, 10, 17, 24, 31, 38, 45, 52, 59, 2, 9, 16, 23, 30, 37, 44, 51, 58, 1, 8, 15, 22, 29, 36, 43, 50, 57]</span><br><span class="line">sort:    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63]</span><br></pre></td></tr></table></figure></p><p>可以看到随着 size 的变化，hashcode 总能均匀的分布。其实这就是 Fibonacci Hashing，具体可以参考 <a href="http://hehaiqian.com/2015/07/25/hash1-0x61c88647/" target="_blank" rel="noopener">这篇文章</a>。所以虽然 ThreadLocal 的 hashcode 是固定的，当 ThreadLocalMap 中的散列表调整大小（变为原来的 2 倍）之后重新散列，hashcode 仍能均匀的分布在散列表中。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><blockquote><p>摘自 <a href="http://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="noopener">Java并发编程：深入剖析ThreadLocal</a></p></blockquote><p>最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal &lt; Connection &gt; connectionHolder = <span class="keyword">new</span> ThreadLocal &lt; Connection &gt; () &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> connectionHolder.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;</span><br><span class="line">    Session s = (Session) threadSession.get();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            s = getSessionFactory().openSession();</span><br><span class="line">            threadSession.set(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="http://www.iteye.com/topic/103804" target="_blank" rel="noopener">http://www.iteye.com/topic/103804</a></li><li><a href="http://www.jianshu.com/p/529c03d9b67e" target="_blank" rel="noopener">http://www.jianshu.com/p/529c03d9b67e</a></li><li><a href="http://stackoverflow.com/questions/38994306/what-is-the-meaning-of-0x61c88647-constant-in-threadlocal-java" target="_blank" rel="noopener">http://stackoverflow.com/questions/38994306/what-is-the-meaning-of-0x61c88647-constant-in-threadlocal-java</a></li><li><a href="http://jerrypeng.me/2013/06/thread-local-and-magical-0x61c88647/" target="_blank" rel="noopener">http://jerrypeng.me/2013/06/thread-local-and-magical-0x61c88647/</a></li><li><a href="http://www.cnblogs.com/softidea/p/4819866.html" target="_blank" rel="noopener">ThreadLocal是否会引发内存泄露的分析（转）</a></li><li><a href="http://qifuguang.me/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/" target="_blank" rel="noopener">[Java并发包学习七]解密ThreadLocal</a></li><li><a href="https://github.com/Bzhnja/ebooks/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9AC%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0_%E5%8E%9F%E4%B9%A6%E7%AC%AC2%E7%89%88_%E9%AB%98%E6%B8%85%E7%89%88.pdf" target="_blank" rel="noopener">数据结构与算法分析: C语法描述</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;ThreadLocal 主要用来提供线程局部变量，也就是变量只对当前线程可见，本文主要记录一下对于 ThreadLocal 的理解。更多关于 Java 多线程的文章可以转到 &lt;a href=&quot;http://con.zhangjikai.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;线程局部变量&quot;&gt;&lt;a href=&quot;#线程局部变量&quot; class=&quot;headerlink&quot; title=&quot;线程局部变量&quot;&gt;&lt;/a&gt;线程局部变量&lt;/h2&gt;&lt;p&gt;在多线程环境下，之所以会有并发问题，就是因为不同的线程会同时访问同一个共享变量，例如下面的形式&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="http://blog.zhangjikai.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="http://blog.zhangjikai.com/tags/Java/"/>
    
      <category term="并发" scheme="http://blog.zhangjikai.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【应用】Markdown 在线阅读器</title>
    <link href="http://blog.zhangjikai.com/2017/01/09/%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91Markdown-%E5%9C%A8%E7%BA%BF%E9%98%85%E8%AF%BB%E5%99%A8/"/>
    <id>http://blog.zhangjikai.com/2017/01/09/【应用】Markdown-在线阅读器/</id>
    <published>2017-01-09T08:56:16.000Z</published>
    <updated>2019-09-08T06:53:07.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一款在线的 Markdown 阅读器，主要用来展示 Markdown 内容。支持 HTML 导出，同时可以方便的添加扩展功能。在这个阅读器的基础又做了一款在线 Github Pages 页面生成器，可以方便的生成不同主题风格的 GitHub Page 页面。</p><a id="more"></a><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="阅读器"><a href="#阅读器" class="headerlink" title="阅读器"></a>阅读器</h3><ul><li>支持文件拖拽</li><li>兼容移动端</li><li><code>Prism.js</code> / <code>Highlight.js</code> 代码高亮</li><li>自动生成目录</li><li>本地图片显示</li><li>导出 Html （包含样式）</li><li>扩展功能<ul><li>Toto 列表</li><li><a href="https://github.com/mathjax/MathJax" target="_blank" rel="noopener">MathJax</a> </li><li><a href="https://github.com/bramp/js-sequence-diagrams" target="_blank" rel="noopener">时序图 (Js sequence diagrams)</a></li><li><a href="https://github.com/Ranks/emojify.js" target="_blank" rel="noopener">Emoji (Emojify.js)</a></li><li><a href="http://echarts.baidu.com/" target="_blank" rel="noopener">图表 (ECharts)</a></li></ul></li></ul><h3 id="Github-Page-生成器"><a href="#Github-Page-生成器" class="headerlink" title="Github Page 生成器"></a>Github Page 生成器</h3><p>在上面的基础上加上了下面的功能</p><ul><li>支持多种页面主题<ul><li><a href="https://github.com/jasonlong/architect-theme" target="_blank" rel="noopener">Architect</a></li><li><a href="https://github.com/jasonlong/cayman-theme" target="_blank" rel="noopener">Cayman</a></li><li><a href="https://github.com/orderedlist/minimal" target="_blank" rel="noopener">Minimal</a></li><li><a href="https://github.com/orderedlist/modernist" target="_blank" rel="noopener">Modernist</a></li><li><a href="https://github.com/jasoncostello/slate" target="_blank" rel="noopener">Slate</a></li><li><a href="https://github.com/jonrohan/time-machine-theme" target="_blank" rel="noopener">Time machine</a></li></ul></li><li>评论<ul><li><a href="http://duoshuo.com/" target="_blank" rel="noopener">多说</a></li><li><a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a></li></ul></li></ul><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p><strong>阅读器</strong><br><a href="http://markdown.zhangjikai.com/" target="_blank" rel="noopener">在线地址</a>　　<a href="http://zhangjikai.com/markdown/sample.html" target="_blank" rel="noopener">效果预览</a>　　<a href="https://github.com/zhangjikai/online-markdown-reader" target="_blank" rel="noopener">源码</a></p><p><strong>生成器</strong><br><a href="http://page.zhangjikai.com" target="_blank" rel="noopener">在线地址</a>　　<a href="http://zhangjikai.com/page/index.html" target="_blank" rel="noopener">效果预览</a>　　<a href="https://github.com/zhangjikai/online-ghpages-generator" target="_blank" rel="noopener">源码</a> </p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><strong>阅读器</strong>  </p><p><img src="/images/markdown/002.png" alt></p><p><strong>生成器</strong></p><p><img src="/images/markdown/003.png" alt></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="文件解析"><a href="#文件解析" class="headerlink" title="文件解析"></a>文件解析</h3><p>程序使用 <a href="https://github.com/chjj/marked" target="_blank" rel="noopener">marked</a> 将 markdown 格式转为 html 格式，这是一个 js 的库，可以直接在浏览器端使用。下面是一个基本的示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> htmlContent = marked(mdContent);</span><br><span class="line">$(<span class="string">"#content"</span>).html(htmlContent);</span><br></pre></td></tr></table></figure></p><p>同时 marked 提供了一些接口，让我们可以方便的定制自己的功能。具体的可以参考它的 <a href="https://github.com/chjj/marked" target="_blank" rel="noopener">说明文件</a> 。在下面我们会介绍我们是如何利用这些接口来实现扩展功能。</p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><h4 id="自定义上传按钮样式"><a href="#自定义上传按钮样式" class="headerlink" title="自定义上传按钮样式"></a>自定义上传按钮样式</h4><p>原始的上传按钮太丑了，所以我们需要自定义自己的样式。这里使用的方式是使用在 <code>input</code> 上面覆盖一个 <code>button</code>，用 <code>button</code> 来显示样式。同时我们将 <code>button</code> 的 <code>pointer-events</code> 设为 <code>none</code>，就可以阻止 <code>button</code> 的事件响应（具体可以参考<a href="http://www.zhangxinxu.com/wordpress/2011/12/css3-pointer-events-none-javascript/" target="_blank" rel="noopener">这里</a>）。下面是具体的实现代码：<br>html:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"upload-area"</span> <span class="attr">id</span>=<span class="string">"upload-area"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"select-file"</span> <span class="attr">class</span>=<span class="string">"select-file"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"select-file-style"</span> <span class="attr">id</span>=<span class="string">"drop"</span>&gt;</span>选择或者拖拽 Markdown 文件到此<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>css<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.upload-area</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: auto;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">2.6em</span> <span class="number">0</span> <span class="number">0.4em</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  <span class="attribute">transition</span>: height <span class="number">0.5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.upload-area</span> <span class="selector-class">.select-file</span> &#123;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.upload-area</span> <span class="selector-class">.select-file-style</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#F5F7FA</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">pointer-events</span>: none;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#AAB2BD</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">"Microsoft YaHei"</span>, <span class="string">"Tahoma"</span>, arial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是效果图</p><p><img src="/images/markdown/004.png" alt></p><h4 id="读取文件内容"><a href="#读取文件内容" class="headerlink" title="读取文件内容"></a>读取文件内容</h4><p>因为程序完全是运行在浏览器端，所以我们使用 html5 的 <code>FileReader</code> 来读取本地文件。<code>FileReader</code> 提供 4 种读取文件的方式</p><ul><li><code>readAsBinaryString(Blob|File)</code></li><li><code>readAsText(Blob|File, opt_encoding)</code></li><li><code>readAsDataURL(Blob|File)</code></li><li><code>readAsArrayBuffer(Blob|File)</code></li></ul><p>其中 <code>readAsText</code> 用来读取文本文件，<code>readAsDataUrl</code> 可以用来读取图片。具体的介绍可以参考 <a href="https://www.html5rocks.com/zh/tutorials/file/dndfiles/" target="_blank" rel="noopener">这里</a> 。<code>FileReader</code> 一般结合文件选择事件或者拖拽事件使用，因为通过这两个事件可以获得源文件。另外 <code>FileReader</code> 是异步读取的，通过 <code>onload</code> 事件可以监听文件是否读取完毕。下面是一个示例, 通过点击 <code>&lt;input type= &quot;file&quot;&gt;</code> 选择文件，然后读取文件内容。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"file-select"</span>).addEventListener(<span class="string">"change"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    reader.readAsText(<span class="keyword">this</span>.files[<span class="number">0</span>]);</span><br><span class="line">    reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> content = e.target.result;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p><h4 id="拖拽文件"><a href="#拖拽文件" class="headerlink" title="拖拽文件"></a>拖拽文件</h4><p>为了方便用户操作，我们提供了点击和拖拽两种方式来上传文件。现在的主流浏览器都支持文件拖拽功能，下面是拖拽过程中触发的事件</p><table><thead><tr><th style="text-align:left">事件</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">dragstart</td><td style="text-align:left">用户开始拖动对象时触发。</td></tr><tr><td style="text-align:left">dragenter</td><td style="text-align:left">鼠标初次移到目标元素并且正在进行拖动时触发。这个事件的监听器应该之指出这个位置是否允许放置元素。如果没有监听器或者监听器不执行任何操作，默认情况下不允许放置。</td></tr><tr><td style="text-align:left">dragover</td><td style="text-align:left">拖动时鼠标移到某个元素上的时候触发。</td></tr><tr><td style="text-align:left">dragleave</td><td style="text-align:left">拖动时鼠标离开某个元素的时候触发。</td></tr><tr><td style="text-align:left">drag</td><td style="text-align:left">对象被拖拽时每次鼠标移动都会触发。</td></tr><tr><td style="text-align:left">drop</td><td style="text-align:left">拖动操作结束，放置元素时触发。</td></tr><tr><td style="text-align:left">dragend</td><td style="text-align:left">拖动对象时用户释放鼠标按键的时候触发。</td></tr></tbody></table><p>另外在拖拽过程中是不触发鼠标事件的。文件读取完后文件信息会保存在 <code>DataTransfer</code> 对象中。详细的介绍可以参考 <a href="http://wiki.jikexueyuan.com/project/html5/drag-drop.html" target="_blank" rel="noopener">这里</a> 。下面是添加事件的示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fileSelect.addEventListener(<span class="string">"dragenter"</span>, dragMdEnter, <span class="literal">false</span>);</span><br><span class="line">fileSelect.addEventListener(<span class="string">"dragleave"</span>, dragMdLeave, <span class="literal">false</span>);</span><br><span class="line">fileSelect.addEventListener(<span class="string">'drop'</span>, dropMdFile, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p><p>读取拖拽的文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dropMdFile</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 取消浏览器默认行为</span></span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    reader.readAsText(e.dataTransfer.files[<span class="number">0</span>]);</span><br><span class="line">    reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> content = e.target.result;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="本地图片显示"><a href="#本地图片显示" class="headerlink" title="本地图片显示"></a>本地图片显示</h3><p>因为没有服务器，所以为了显示本地图片，使用了替换图片 <code>src</code> 的方式。首先读取本地文件，然后将 <code>&lt;img&gt;</code> 的 <code>src</code> 路径替换为图片内容 。如下所示：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"path"</span>&gt;</span></span><br><span class="line">// 替换为</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgI..."</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>下面是具体的代码实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取选择或者拖拽的文件（多个文件）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processImages</span>(<span class="params">imgFiles</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; imgFiles.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> file = imgFiles[i];</span><br><span class="line">        <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">        reader.readAsDataURL(file);</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params">reader, file</span>) </span>&#123;</span><br><span class="line">            reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">                cacheImages[file.name] = e.target.result;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">if</span> (index == length) &#123;</span><br><span class="line">                    replaceImage();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(reader, file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将路径替换为图片内容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceImage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> images = $(<span class="string">"img"</span>);</span><br><span class="line">    <span class="keyword">var</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; images.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> imgSrc = images[i].src;</span><br><span class="line">        <span class="keyword">var</span> imgName = getImgName(imgSrc);</span><br><span class="line">        <span class="keyword">if</span> (cacheImages.hasOwnProperty(imgName)) &#123;</span><br><span class="line">            images[i].src = cacheImages[imgName];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果图片过大，我们可以将图片压缩一下，具体方法就是创建一个 <code>canvas</code> 元素，将图片绘制到 <code>canvas</code> 上，然后将 <code>canvas</code> 转为图片。这种方式对 <code>jpg</code> 文件压缩效果较好，对 <code>png</code> 文件压缩效果不太好。下面是代码实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compressImage</span>(<span class="params">img, format</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> max_width = <span class="number">862</span>;</span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> width = img.width;</span><br><span class="line">    <span class="keyword">var</span> height = img.height;</span><br><span class="line">    <span class="keyword">if</span> (format == <span class="literal">null</span> || format == <span class="string">""</span>) &#123;</span><br><span class="line">        format = <span class="string">"image/png"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (width &gt; max_width) &#123;</span><br><span class="line">        height = <span class="built_in">Math</span>.round(height *= max_width / width);</span><br><span class="line">        width = max_width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resize the canvas and draw the image data into it</span></span><br><span class="line">    canvas.width = width;</span><br><span class="line">    canvas.height = height;</span><br><span class="line">    <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line">    ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    <span class="keyword">return</span> canvas.toDataURL(format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="循环中使用异步回调函数"><a href="#循环中使用异步回调函数" class="headerlink" title="循环中使用异步回调函数"></a>循环中使用异步回调函数</h4><p>为了方便使用，我们可以同时上传多个图片，我们使用 <code>for</code> 循环来读取多个文件，但是有个问题是文件的读取是异步的，也就是说在 <code>for</code> 循环执行完之后，图片可能仍在读取中，当图片读取完后，再调用 <code>onload</code> 回调函数进行处理。简单一点就是说如何在 <code>for</code> 循环中正确使用延迟调用的回调函数。看下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">value, callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"value in print"</span>, value);</span><br><span class="line">    setTimeout(callback, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = i;</span><br><span class="line">    print(value, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"value in callback"</span>, value);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面打的代码和我们读取图片文件的逻辑类似，<code>callback</code> 函数会在调用 <code>print</code> 函数1秒后执行，下面是输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">value in print 0</span><br><span class="line">value in print 1</span><br><span class="line">value in print 2</span><br><span class="line">value in print 3</span><br><span class="line">value in callback 3</span><br><span class="line">value in callback 3</span><br><span class="line">value in callback 3</span><br><span class="line">value in callback 3</span><br></pre></td></tr></table></figure></p><p>最后在 <code>callback</code> 中 <code>value</code> 值都是3，这是因为在 js 中没有块级作用域，只有函数作用域，也就是说下面的两段代码是等同的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = i;</span><br><span class="line">    <span class="comment">// do someting</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> value;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    value = i;</span><br><span class="line">    <span class="comment">// do someting</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此，为了解决这个问题，我们只需要为循环中的回调函数添加一个单独的作用域即可，我们使用闭包来实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = i;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        print(value, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"value in callback"</span>, value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>我们使用两款代码高亮插件 – <a href="https://highlightjs.org/" target="_blank" rel="noopener">highlight.js</a> 和 <a href="http://prismjs.com/" target="_blank" rel="noopener">prism.js</a>，根据喜好可以自由切换。这两款插件对代码块的 html 格式有不同的要求，我们重写了 <code>marked</code> 中解析代码块的方法，根据高亮方式来生成不同的 html 代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">renderer.code = <span class="function"><span class="keyword">function</span> (<span class="params">code, lang</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Setting.highlight == Constants.highlight) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;pre&gt;&lt;code class='"</span> + lang + <span class="string">"'&gt;"</span> + code + <span class="string">"&lt;/code&gt;&lt;/pre&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;pre&gt;&lt;code class='language-"</span> + lang + <span class="string">"'&gt;"</span> + code + <span class="string">"&lt;/code&gt;&lt;/pre&gt;"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然后调用 highlight.js 和 prism.js 的代码高亮方法即可<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Setting.highlight == Constants.highlight) &#123;</span><br><span class="line">    $(<span class="string">'pre code'</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params">i, block</span>) </span>&#123;</span><br><span class="line">        hljs.highlightBlock(block);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 添加行号支持</span></span><br><span class="line">    $(<span class="string">"pre"</span>).addClass(<span class="string">"line-numbers"</span>);</span><br><span class="line">    Prism.highlightAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>为了生成文件的目录，我们需要首先获得目录信息，因此我们重写 <code>marked</code> 的 <code>heading</code> 方法， 将目录信息保存起来，同时为每个标题添加链接图标（仿照 github），下面是代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">renderer.heading = <span class="function"><span class="keyword">function</span> (<span class="params">text, level</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> slug = text.toLowerCase().replace(<span class="regexp">/[\s]+/g</span>, <span class="string">'-'</span>);</span><br><span class="line">    <span class="keyword">if</span> (tocStr.indexOf(slug) != <span class="number">-1</span>) &#123;</span><br><span class="line">        slug += <span class="string">"-"</span> + tocDumpIndex;</span><br><span class="line">        tocDumpIndex++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tocStr += slug;</span><br><span class="line">    toc.push(&#123;</span><br><span class="line">        level: level,</span><br><span class="line">        slug: slug,</span><br><span class="line">        title: text</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;h"</span> + level + <span class="string">" id=\""</span> + slug + <span class="string">"\"&gt;&lt;a href=\"#"</span> + slug + <span class="string">"\" class=\"anchor\"&gt;"</span> + <span class="string">''</span> +</span><br><span class="line">        <span class="string">'&lt;svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;'</span> +</span><br><span class="line">        <span class="string">''</span> + <span class="string">"&lt;/a&gt;"</span> + text + <span class="string">"&lt;/h"</span> + level + <span class="string">"&gt;"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>同时需要加入下面的 css，以是标题的链接图片正常显示：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.anchor</span>, <span class="selector-tag">h2</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.anchor</span>, <span class="selector-tag">h3</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.anchor</span>, <span class="selector-tag">h4</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.anchor</span>, <span class="selector-tag">h5</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.anchor</span>, <span class="selector-tag">h6</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.anchor</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.anchor</span> <span class="selector-class">.octicon-link</span>, <span class="selector-tag">h2</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.anchor</span> <span class="selector-class">.octicon-link</span>, <span class="selector-tag">h3</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.anchor</span> <span class="selector-class">.octicon-link</span>, <span class="selector-tag">h4</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.anchor</span> <span class="selector-class">.octicon-link</span>, <span class="selector-tag">h5</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.anchor</span> <span class="selector-class">.octicon-link</span>, <span class="selector-tag">h6</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.anchor</span> <span class="selector-class">.octicon-link</span> &#123;</span><br><span class="line">    <span class="attribute">visibility</span>: visible</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.octicon</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>: text-top;</span><br><span class="line">    <span class="attribute">fill</span>: currentColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.anchor</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了生成目录，我们只需按照保存的目录信息，生成 <code>&lt;ul&gt;</code> 和 <code>&lt;li&gt;</code> 标签即可，具体的可以参考源码中的实现。</p><h4 id="配置页面锚链接"><a href="#配置页面锚链接" class="headerlink" title="配置页面锚链接"></a>配置页面锚链接</h4><p>目录使用的是页内锚链接的方式进行跳转，如下面所示：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#h1"</span>&gt;</span>跳转到 H1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"h1"</span>&gt;</span>我是 H1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>默认情况下，页内锚链接跳转之后，目标标签（上面代码中的 <code>&lt;h1&gt;</code> ）会移动到页面的最顶部，但是在我们的程序中有一个固定的 header，如果跳转到最顶部，目标标签会被 header 遮挡住，所以我们希望目标标签移动到距离页面顶部 <code>header-height</code> 的地方。为了实现我们的需要，只要加入下面的 css 代码即可。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:target</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50px</span>; <span class="comment">/* fixed header height*/</span></span><br><span class="line">    <span class="attribute">margin</span>:-<span class="number">50px</span> <span class="number">0</span> <span class="number">0</span>; <span class="comment">/* negative fixed header height */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Todo-列表"><a href="#Todo-列表" class="headerlink" title="Todo 列表"></a>Todo 列表</h3><p>Todo 列表实际上就是 checkbox 的列表，完成的工作用选中的 checkbox 表示，未完成的工作用喂选中的列表表示，如下图所示：</p><p><img src="/images/markdown/005.png" alt></p><p>一般来说，会将下面形式的 markdown 代码解析为 todo 列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- [x] 完成</span><br><span class="line">- [ ] 未完成</span><br><span class="line">- [ ] 未完成</span><br></pre></td></tr></table></figure></p><p>为了实现这个功能，我们重写 <code>marked</code> 中解析列表的方法，加入对 todo 列表的支持。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">renderer.listitem = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/^\s*\[[x ]\]\s*/</span>.test(text)) &#123;</span><br><span class="line">        text = text</span><br><span class="line">            .replace(<span class="regexp">/^\s*\[ \]\s*/</span>, <span class="string">'&lt;input type="checkbox" class="task-list-item-checkbox" disabled&gt; '</span>)</span><br><span class="line">            .replace(<span class="regexp">/^\s*\[x\]\s*/</span>, <span class="string">'&lt;input type="checkbox" class="task-list-item-checkbox" disabled checked&gt; '</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;li style="list-style: none"&gt;'</span> + text + <span class="string">'&lt;/li&gt;'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;li&gt;'</span> + text + <span class="string">'&lt;/li&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>同时加入下面的样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.task-list-item-checkbox</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0.2em</span> <span class="number">0.25em</span> -<span class="number">2.3em</span>;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[type="checkbox"]</span>, <span class="selector-attr">[type="radio"]</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>现在的浏览器都已经支持 <code>localStorage</code>，可以方便的存储数据。<code>localStorage</code> 就是一个对象。我们存储数据就是直接给它添加一个属性，可以通过 <code>localStoage[&quot;a&quot;]=1</code> 或者 <code>localStorage.a = 1</code> 的方式来存储数据，但是看起来总觉的不太优雅，因为一般使用下面的方式来操作 <code>localStorage</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(key, vlaue);</span><br><span class="line">localStorage.getItem(key);</span><br><span class="line">localStorage.removeItem(key);</span><br></pre></td></tr></table></figure></p><p>另外 <code>localStorage</code> 也有一些局限，使用时需要注意：</p><ul><li>存储空间有限制，一般是 <code>5M</code>  左右，和浏览器有关</li><li>用户清除浏览器缓存之后有可能丢失本地缓存的数据</li><li>不能直接存对象，要先使用 <code>JSON.stringfy</code> 方法将对象进行序列化处理之后再保存。使用时需要使用 <code>JSON.parse</code> 方法将字符串转为对象。</li></ul><h3 id="导出文件"><a href="#导出文件" class="headerlink" title="导出文件"></a>导出文件</h3><p>通过使用 <a href="https://github.com/eligrey/FileSaver.js/" target="_blank" rel="noopener">FileSaver.js</a>，我们可以方便的在浏览器端生成文件，并提供给用户下载。使用方法也很简单：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([htmlContent], &#123;<span class="attr">type</span>: <span class="string">"text/html;charset=utf-8"</span>&#125;);</span><br><span class="line">saveAs(blob, name);</span><br></pre></td></tr></table></figure></p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>我们提供了一些扩展功能，用来更好的展示 markdown 内容。在现在的程序中我们可以很方便的添加扩展功能，下面会具体介绍。</p><h4 id="自定义扩展"><a href="#自定义扩展" class="headerlink" title="自定义扩展"></a>自定义扩展</h4><p>为了添加扩展，我们首先需要确定哪些内容需要作为扩展处理。因为在将 markdown 文件转为 html 的过程中，一般是不处理代码块中的内容的，所以我们使用代码块来存放扩展内容，通过代码块的语言来确定是哪种扩展。以添加序列图扩展为例：</p><ul><li><p>确定时序图的代码标记<br><img src="/images/markdown/006.png" alt></p></li><li><p>修改 <code>marked</code> 中对于代码块的解析函数，添加对于时序图标记的支持</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> renderer = <span class="keyword">new</span> marked.Renderer();</span><br><span class="line"><span class="keyword">var</span> originalCodeFun = <span class="function"><span class="keyword">function</span> (<span class="params">code, lang</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Setting.highlight == Constants.highlight) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;pre&gt;&lt;code class='"</span> + lang + <span class="string">"'&gt;"</span> + code + <span class="string">"&lt;/code&gt;&lt;/pre&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;pre&gt;&lt;code class='language-"</span> + lang + <span class="string">"'&gt;"</span> + code + <span class="string">"&lt;/code&gt;&lt;/pre&gt;"</span>;</span><br><span class="line">&#125;;</span><br><span class="line">renderer.code = <span class="function"><span class="keyword">function</span> (<span class="params">code, language</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (language == <span class="string">"seq"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;div class='diagram' id='diagram'&gt;"</span> + code + <span class="string">"&lt;/div&gt;"</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> originalCodeFun.call(<span class="keyword">this</span>, code, language);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">marked.setOptions(&#123;</span><br><span class="line">    renderer: renderer</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>引入 <code>js-sequence-diagrams</code> 相关文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; bower directory &#125;&#125;/js-sequence-diagrams/dist/sequence-diagram-min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"&#123;&#123; bower directory &#125;&#125;/bower-webfontloader/webfont.js"</span> /&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; bower directory &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">/snap.svg/dist/snap.svg-min.js"</span> /&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; bower directory &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">/underscore/underscore-min.js"</span> /&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; bower directory &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">/js-sequence-diagrams/dist/sequence-diagram-min.js"</span> /&gt;</span></span></span></span><br></pre></td></tr></table></figure></li><li><p>渲染 Markdown 文件时，调用相关函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">".diagram"</span>).sequenceDiagram(&#123;<span class="attr">theme</span>: <span class="string">'simple'</span>&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>添加扩展会影响文件的渲染速度，如果不需要某个扩展可以手动关闭。</p><h4 id="Mathjax"><a href="#Mathjax" class="headerlink" title="Mathjax"></a>Mathjax</h4><p>使用<a href="https://github.com/mathjax/MathJax" target="_blank" rel="noopener">Mathjax</a> 对数学公式进行支持。关于Mathjax 语法，请参考<a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference/5044" target="_blank" rel="noopener">这里</a>。下面是添加扩展的流程：</p><ul><li><p>引入文件并配置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-mathjax-config"</span>&gt;</span></span><br><span class="line"><span class="actionscript">  MathJax.Hub.Config(&#123;tex2jax: &#123;inlineMath: [[<span class="string">'$'</span>,<span class="string">'$'</span>], [<span class="string">'\\('</span>,<span class="string">'\\)'</span>]]&#125;,</span></span><br><span class="line">    TeX: &#123;</span><br><span class="line">      equationNumbers: &#123;</span><br><span class="line"><span class="actionscript">        autoNumber: [<span class="string">"AMS"</span>],</span></span><br><span class="line"><span class="actionscript">        useLabelIds: <span class="literal">true</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="string">"HTML-CSS"</span>: &#123;</span></span><br><span class="line">      linebreaks: &#123;</span><br><span class="line"><span class="actionscript">        automatic: <span class="literal">true</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SVG: &#123;</span><br><span class="line">      linebreaks: &#123;</span><br><span class="line"><span class="actionscript">        automatic: <span class="literal">true</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>将 markdown 文件转为 html 之后，调用 Mathjax 中的方法将对应标记转为数学公式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// content 是需要处理的 html 标签的 id</span></span><br><span class="line">MathJax.Hub.Queue([<span class="string">"Typeset"</span>, MathJax.Hub, <span class="string">"content"</span>]);</span><br></pre></td></tr></table></figure></li></ul><h4 id="Emoji"><a href="#Emoji" class="headerlink" title="Emoji"></a>Emoji</h4><p>使用 <a href="https://github.com/Ranks/emojify.js" target="_blank" rel="noopener">emojify.js</a> 来提供对 Emoji 标签的支持。Emoji表情参见 <a href="http://www.webpagefx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">EMOJI CHEAT SHEET</a>。下面是添加扩展的流程</p><ul><li><p>引用文件并配置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://cdn.bootcss.com/emojify.js/1.1.0/js/emojify.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">trueemojify.setConfig(&#123;</span><br><span class="line"><span class="actionscript">        emojify_tag_type: <span class="string">'div'</span>,           <span class="comment">// Only run emojify.js on this element</span></span></span><br><span class="line"><span class="actionscript">        only_crawl_id: <span class="literal">null</span>,            <span class="comment">// Use to restrict where emojify.js applies</span></span></span><br><span class="line"><span class="actionscript">        img_dir: <span class="string">'http://cdn.bootcss.com/emojify.js/1.0/images/basic'</span>,  <span class="comment">// Directory for emoji images</span></span></span><br><span class="line"><span class="actionscript">        ignored_tags: &#123;                <span class="comment">// Ignore the following tags</span></span></span><br><span class="line"><span class="actionscript">            <span class="string">'SCRIPT'</span>: <span class="number">1</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="string">'TEXTAREA'</span>: <span class="number">1</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="string">'A'</span>: <span class="number">1</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="string">'PRE'</span>: <span class="number">1</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="string">'CODE'</span>: <span class="number">1</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>将 markdown 文件转为 html 之后，调用 emojify 中的方法将对应标记转换 emoji 表情。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emojify.run(<span class="built_in">document</span>.getElementById(<span class="string">'content'</span>))</span><br></pre></td></tr></table></figure></li></ul><h4 id="图表-（ECharts）"><a href="#图表-（ECharts）" class="headerlink" title="图表 （ECharts）"></a>图表 （ECharts）</h4><p>使用 <a href="https://github.com/ecomfe/echarts" target="_blank" rel="noopener">ECharts</a> 来提供对图表的支持。ECharts 的语法可以参考 <a href="http://echarts.baidu.com/examples.html" target="_blank" rel="noopener">官网的示例</a>。下面是使用方法：</p><ul><li><p>确定 ECharts 在 markdown 中的语法标签<br><img src="/images/markdown/007.png" alt></p></li><li><p>在 code 方法解析中添加对 echarts 的支持</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">renderer.code = <span class="function"><span class="keyword">function</span> (<span class="params">code, language</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (language) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"echarts"</span>:</span><br><span class="line">            <span class="keyword">if</span> (Setting.echarts) &#123;</span><br><span class="line">                <span class="keyword">return</span> loadEcharts(code);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> originalCodeFun.call(<span class="keyword">this</span>, code, language);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadEcharts</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="string">"100%"</span>;</span><br><span class="line">    <span class="keyword">var</span> height = <span class="string">"400px"</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> options = <span class="built_in">eval</span>(<span class="string">"("</span> + text + <span class="string">")"</span>);</span><br><span class="line">        <span class="keyword">if</span> (options.hasOwnProperty(<span class="string">"width"</span>)) &#123;</span><br><span class="line">            width = options[<span class="string">"width"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (options.hasOwnProperty(<span class="string">"height"</span>)) &#123;</span><br><span class="line">            height = options[<span class="string">"height"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        echartIndex++;</span><br><span class="line">        echartData.push(&#123;</span><br><span class="line">            id: echartIndex,</span><br><span class="line">            option: options,</span><br><span class="line">            previousOption: text</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;div id="echarts-'</span> + echartIndex + <span class="string">'" style="width: '</span> + width + <span class="string">';height:'</span> + height + <span class="string">';"&gt;&lt;/div&gt;'</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将 markdown 文件转为 html 之后，调用 echarts 中的方法，将对应的 div 转为图表：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chart;</span><br><span class="line">echartData.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.option.theme) &#123;</span><br><span class="line">        chart = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">'echarts-'</span> + data.id), data.option.theme);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        chart = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">'echarts-'</span> + data.id));</span><br><span class="line">    &#125;</span><br><span class="line">    chart.setOption(data.option);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h4><p>在生成Github Page页面时，我们可以选择添加 <a href="http://duoshuo.com/" target="_blank" rel="noopener">多说</a> 或者 <a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a> 评论，其中多说就是在导出的页面中加入下面的代码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ds-thread"</span> <span class="attr">data-thread-key</span>=<span class="string">""</span> <span class="attr">data-title</span>=<span class="string">""</span> <span class="attr">data-url</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> duoshuoQuery = &#123;</span></span><br><span class="line"><span class="actionscript">        short_name: <span class="string">""</span></span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="actionscript">    (<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ds = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span></span><br><span class="line"><span class="actionscript">        ds.type = <span class="string">"text/javascript"</span>;</span></span><br><span class="line"><span class="actionscript">        ds.async = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">        ds.src = (<span class="built_in">document</span>.location.protocol == <span class="string">"https:"</span> ? <span class="string">"https:"</span> : <span class="string">"http:"</span>) + <span class="string">"//static.duoshuo.com/embed.js"</span>;</span></span><br><span class="line"><span class="actionscript">        ds.charset = <span class="string">"UTF-8"</span>;</span></span><br><span class="line"><span class="javascript">        (<span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>] || <span class="built_in">document</span>.getElementsByTagName(<span class="string">"body"</span>)[<span class="number">0</span>]).appendChild(ds);</span></span><br><span class="line">    &#125;)();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>其中 <code>data-thread-key</code>, <code>data-title</code>, <code>data-url</code> 和 <code>short_name</code> 是需要我们自定义的东西。而Disqus 需要在导出时插入下面的代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"disqus_thread"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> disqus_shortname = <span class="string">''</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> prefix = <span class="built_in">document</span>.location.protocol == <span class="string">"https:"</span> ? <span class="string">"https:"</span> : <span class="string">"http:"</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> disqus_config = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.page.url = <span class="string">""</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.page.identifier = <span class="string">""</span></span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="actionscript">    (<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> d = <span class="built_in">document</span>,</span></span><br><span class="line"><span class="actionscript">                s = d.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="actionscript">        s.src = prefix + <span class="string">'//'</span> + disqus_shortname + <span class="string">'.disqus.com/embed.js'</span>;</span></span><br><span class="line"><span class="javascript">        s.setAttribute(<span class="string">'data-timestamp'</span>, +<span class="keyword">new</span> <span class="built_in">Date</span>());</span></span><br><span class="line">        (d.head || d.body).appendChild(s);</span><br><span class="line">    &#125;)();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>其中 <code>disqus_shortname</code>, <code>page.url</code> 和 <code>page.indertifier</code> 是需要我们自定义的东西。这里需要注意的是 <code>page.url</code> 要使用绝对路径。</p><p>具体的插入逻辑可参考源码的实现，这里不再赘述。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;一款在线的 Markdown 阅读器，主要用来展示 Markdown 内容。支持 HTML 导出，同时可以方便的添加扩展功能。在这个阅读器的基础又做了一款在线 Github Pages 页面生成器，可以方便的生成不同主题风格的 GitHub Page 页面。&lt;/p&gt;
    
    </summary>
    
      <category term="应用" scheme="http://blog.zhangjikai.com/categories/%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="应用" scheme="http://blog.zhangjikai.com/tags/%E5%BA%94%E7%94%A8/"/>
    
      <category term="Markdown" scheme="http://blog.zhangjikai.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>【HTML5】Canvas 内部元素添加事件处理</title>
    <link href="http://blog.zhangjikai.com/2016/12/06/%E3%80%90HTML5%E3%80%91Canvas%E5%85%83%E7%B4%A0%E6%B7%BB%E5%8A%A0%E4%BA%8B%E4%BB%B6/"/>
    <id>http://blog.zhangjikai.com/2016/12/06/【HTML5】Canvas元素添加事件/</id>
    <published>2016-12-06T01:58:34.000Z</published>
    <updated>2019-09-08T06:53:07.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>canvas 没有提供为其内部元素添加事件监听的方法，因此如果要使 canvas 内的元素能够响应事件，需要自己动手实现。实现方法也很简单，首先获得鼠标在 canvas 上的坐标，计算当前坐标在哪些元素内部，然后对元素进行相应的操作。配合自定义事件，我们就可以实现为 canvas 内的元素添加事件监听的效果。</p><p><a href="https://github.com/zhangjikai/canvas-element-event" target="_blank" rel="noopener">源码</a> &nbsp;&nbsp;&nbsp;<a href="http://zhangjikai.com/canvas-event/" target="_blank" rel="noopener">演示</a><br><a id="more"></a></p><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>为了实现javascript对象的自定义事件，我们可以创建一个管理事件的对象，该对象中包含一个内部对象（当作map使用，事件名作为属性名，事件处理函数作为属性值，因为可能有个多个事件处理函数，所以使用数组存储事件处理函数），存储相关的事件。然后提供一个激发事件的函数，通过使用 <code>call</code> 方法来调用之前绑定的函数。下面是代码示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    cce.EventTarget = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>._listeners = &#123;&#125;;</span><br><span class="line">        <span class="keyword">this</span>.inBounds = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cce.EventTarget.prototype = &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: cce.EventTarget,</span><br><span class="line"></span><br><span class="line">        // 查看某个事件是否有监听</span><br><span class="line">        hasListener: function (type) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>._listeners.hasOwnProperty(type)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为事件添加监听函数</span></span><br><span class="line">        addListener: <span class="function"><span class="keyword">function</span> (<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>._listeners.hasOwnProperty(type)) &#123;</span><br><span class="line">                <span class="keyword">this</span>._listeners[type] = [];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>._listeners[type].push(listener);</span><br><span class="line">            cce.EventManager.addTarget(type, <span class="keyword">this</span>);</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发事件</span></span><br><span class="line">        fire: <span class="function"><span class="keyword">function</span> (<span class="params">type, event</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (event == <span class="literal">null</span> || event.type == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>._listeners[event.type] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> listeners = <span class="keyword">this</span>._listeners[event.type];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = listeners.length; i &lt; len; i++) &#123;</span><br><span class="line">                    listeners[i].call(<span class="keyword">this</span>, event);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果listener 为null，则清除当前事件下的全部事件监听</span></span><br><span class="line">        removeListener: <span class="function"><span class="keyword">function</span> (<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (listener == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>._listeners.hasOwnProperty(type)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>._listeners[type] = [];</span><br><span class="line">                    cce.EventManager.removeTarget(type, <span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>._listeners[type] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> listeners = <span class="keyword">this</span>._listeners[type];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = listeners.length; i &lt; len; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (listeners[i] === listener) &#123;</span><br><span class="line">                        listeners.splice(i, <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span> (listeners.length == <span class="number">0</span>)</span><br><span class="line">                            cce.EventManager.removeTarget(type, <span class="keyword">this</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p><p>在上面的代码中，<code>EventManager</code> 用来存储所有绑定了事件监听的对象，便于后面判断鼠标是否位于某个对象内部。如果一个自定义对象需要添加事件监听，只需要继承 <code>EventTarget</code>。</p><h2 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h2><p>在判断触发某个事件的元素时，需要遍历所有绑定了该事件的元素，判断鼠标位置是否位于元素内部。为了减少不必要的比较，这里使用了一个有序数组，使用元素区域的最小 x 值作为比较值，按照升序排列。如果一个元素区域的最小 x 值大于鼠标的 x 值，那么就无需比较数组中该元素后面的元素。具体实现可以看 <a href="https://github.com/zhangjikai/canvas-element-event/tree/master/js" target="_blank" rel="noopener">SortArray.js</a></p><h2 id="元素父类"><a href="#元素父类" class="headerlink" title="元素父类"></a>元素父类</h2><p>这里设计了一个抽象类，来作为所有元素对象的父类，该类继承了 <code>EventTarget</code>，并且定义了三个函数，所有子类都应该实现这三个函数。 具体代码如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象类，该类继承了事件处理类，所有元素对象应该继承这个类</span></span><br><span class="line">    <span class="comment">// 为了实现对象比较，继承该类时应该同时实现compareTo, comparePointX 以及 hasPoint 方法。</span></span><br><span class="line">    cce.DisplayObject = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        cce.EventTarget.call(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.canvas = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.context = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cce.DisplayObject.prototype = <span class="built_in">Object</span>.create(cce.EventTarget.prototype);</span><br><span class="line">    cce.DisplayObject.prototype.constructor = cce.DisplayObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在有序数组中会根据这个方法的返回结果将对象排序</span></span><br><span class="line">    cce.DisplayObject.prototype.compareTo = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较目标点的x值与当前区域的最小 x 值，结合有序数组使用，如果 point 的 x 小于当前区域的最小 x 值，那么有序数组中剩余</span></span><br><span class="line">    <span class="comment">// 元素的最小 x 值也会大于目标点的 x 值，就可以停止比较。在事件判断时首先使用该函数过滤一下。</span></span><br><span class="line">    cce.DisplayObject.prototype.comparePointX = <span class="function"><span class="keyword">function</span> (<span class="params">point</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断目标点是否在当前区域内</span></span><br><span class="line">    cce.DisplayObject.prototype.hasPoint = <span class="function"><span class="keyword">function</span> (<span class="params">point</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p><h2 id="事件判断"><a href="#事件判断" class="headerlink" title="事件判断"></a>事件判断</h2><p>以鼠标事件为例，这里我们实现了 <code>mouseover</code>, <code>mousemove</code>, <code>mouseout</code> 三种鼠标事件。首先对 canvas 添加 <code>mouseover</code>事件，当鼠标在 canvas 上移动时，会时时对比当前鼠标位置与绑定了上述三种事件的元素的位置，如果满足了触发条件就调用元素的 <code>fire</code> 方法触发对应的事件。下面是示例代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">_handleMouseMove: <span class="function"><span class="keyword">function</span> (<span class="params">event, container</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里传入container 主要是为了使用 _windowToCanvas函数</span></span><br><span class="line">    <span class="keyword">var</span> point = container._windowToCanvas(event.clientX, event.clientY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得绑定了 mouseover, mousemove, mouseout 事件的元素对象</span></span><br><span class="line">    <span class="keyword">var</span> array = cce.EventManager.getTargets(<span class="string">"mouse"</span>);</span><br><span class="line">    <span class="keyword">if</span> (array != <span class="literal">null</span>) &#123;</span><br><span class="line">        array.search(point);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 鼠标所在的元素</span></span><br><span class="line">        <span class="keyword">var</span> selectedElements = array.selectedElements;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 鼠标不在的元素</span></span><br><span class="line">        <span class="keyword">var</span> unSelectedElements = array.unSelectedElements;</span><br><span class="line">        selectedElements.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ele.hasListener(<span class="string">"mousemove"</span>)) &#123;</span><br><span class="line">                <span class="keyword">var</span> event = <span class="keyword">new</span> cce.Event(point.x, point.y, <span class="string">"mousemove"</span>, ele);</span><br><span class="line">                ele.fire(<span class="string">"mousemove"</span>, event);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 之前不在区域内，现在在了，说明鼠标进入了</span></span><br><span class="line">            <span class="keyword">if</span> (!ele.inBounds) &#123;</span><br><span class="line">                ele.inBounds = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (ele.hasListener(<span class="string">"mouseover"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">var</span> event = <span class="keyword">new</span> cce.Event(point.x, point.y, <span class="string">"mouseover"</span>, ele);</span><br><span class="line">                    ele.fire(<span class="string">"mouseover"</span>, event);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        unSelectedElements.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 之前在区域内，现在不在了，说明鼠标离开了</span></span><br><span class="line">            <span class="keyword">if</span> (ele.inBounds) &#123;</span><br><span class="line">                ele.inBounds = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (ele.hasListener(<span class="string">"mouseout"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">var</span> event = <span class="keyword">new</span> cce.Event(point.x, point.y, <span class="string">"mouseout"</span>, ele);</span><br><span class="line">                    ele.fire(<span class="string">"mouseout"</span>, event);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>诸如下面形式的函数称之为立即执行函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p><p>使用立即执行函数的好处就是它限定了变量的作用域，使在立即执行函数中定义变量不会污染其他作用域，更加详细的讲解请看<a href="http://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html" target="_blank" rel="noopener">这里</a></p><h3 id="apply-call-bind"><a href="#apply-call-bind" class="headerlink" title="apply, call, bind"></a>apply, call, bind</h3><p>这三个函数的使用类似于java 反射中的 <code>Method.invoke</code>，方法作为一个主体，将执行方法的对象作为参数传入到方法里。其中 apply 和 call 作用一样，调用后都会立即执行，只是接受参数的形式不同。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func.call(<span class="keyword">this</span>, arg1, arg2);</span><br><span class="line">func.apply(<span class="keyword">this</span>, [arg1, arg2])</span><br></pre></td></tr></table></figure></p><p>而 bind 会返回对应函数，不会立即执行，便于以后调用。 看下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bb = aa.bind(<span class="built_in">Math</span>);</span><br><span class="line">bb();</span><br></pre></td></tr></table></figure></p><p>更加详细的讲解请看<a href="http://www.cnblogs.com/coco1s/p/4833199.html" target="_blank" rel="noopener">这里</a></p><h3 id="addEventListener-传参"><a href="#addEventListener-传参" class="headerlink" title="addEventListener 传参"></a>addEventListener 传参</h3><p>如果给某个元素添加事件监听时需要传递参数，可以使用下面的方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">aa.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    bb(i);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p><h3 id="调用父类的构造函数"><a href="#调用父类的构造函数" class="headerlink" title="调用父类的构造函数"></a>调用父类的构造函数</h3><p>使用 <code>call</code> 即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Child = function() &#123;</span><br><span class="line">    Parent.call(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="对象检测"><a href="#对象检测" class="headerlink" title="对象检测"></a>对象检测</h3><ul><li><p>判断对象为 null 或者 undefined</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `null == undefined` 为true</span></span><br><span class="line"><span class="keyword">if</span> (variable == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断对象是否有某个属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(myObj.hasOwnProperty(<span class="string">"&lt;property name&gt;"</span>))&#123;</span><br><span class="line">    alert(<span class="string">"yes, i have that property"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">"&lt;property name&gt;"</span> <span class="keyword">in</span> myObj) &#123;</span><br><span class="line">    alert(<span class="string">"yes, i have that property"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="isPointInPath"><a href="#isPointInPath" class="headerlink" title="isPointInPath"></a>isPointInPath</h3><p>canvas中判断点是否在某个路径内部，可以用于多边形的检测。不过 <code>isPointInPath</code> 使用路径是最后一次绘制的图形，如果有多个图形需要判断，需要将前面的图形路径保存下来，判断时需要重新构造路径，不过不需要绘制，如下面<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.context.save();</span><br><span class="line"><span class="keyword">this</span>.context.beginPath();</span><br><span class="line"></span><br><span class="line"><span class="comment">//console.log(this.points);</span></span><br><span class="line"><span class="keyword">this</span>.context.moveTo(<span class="keyword">this</span>.points[<span class="number">0</span>].x, <span class="keyword">this</span>.points[<span class="number">0</span>].y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.points.length; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>.context.lineTo(<span class="keyword">this</span>.points[i].x, <span class="keyword">this</span>.points[i].y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.context.isPointInPath(target.x, target.y)) &#123;</span><br><span class="line">    isIn = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.context.closePath();</span><br><span class="line"><span class="keyword">this</span>.context.restore();</span><br></pre></td></tr></table></figure></p><hr><p><strong>参考文章：</strong></p><ul><li><a href="https://www.nczonline.net/blog/2010/03/09/custom-events-in-javascript/" target="_blank" rel="noopener">Custom events in JavaScript</a></li><li><a href="http://www.ghugo.com/javascript-constructor/" target="_blank" rel="noopener">javascript中constructor的作用</a></li><li><a href="http://www.cnblogs.com/coco1s/p/4833199.html" target="_blank" rel="noopener">【优雅代码】深入浅出 妙用Javascript中apply、call、bind</a></li><li><a href="http://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html" target="_blank" rel="noopener">深入理解JavaScript系列（4）：立即调用的函数表达式</a></li><li><a href="https://www.bennadel.com/blog/1566-using-super-constructors-is-critical-in-prototypal-inheritance-in-javascript.htm" target="_blank" rel="noopener">Using Super Constructors Is Critical In Prototypal Inheritance In Javascript</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;canvas 没有提供为其内部元素添加事件监听的方法，因此如果要使 canvas 内的元素能够响应事件，需要自己动手实现。实现方法也很简单，首先获得鼠标在 canvas 上的坐标，计算当前坐标在哪些元素内部，然后对元素进行相应的操作。配合自定义事件，我们就可以实现为 canvas 内的元素添加事件监听的效果。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zhangjikai/canvas-element-event&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码&lt;/a&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;http://zhangjikai.com/canvas-event/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;演示&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="HTML5" scheme="http://blog.zhangjikai.com/categories/HTML5/"/>
    
    
      <category term="HTML5" scheme="http://blog.zhangjikai.com/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>【CSS 学习笔记】CSS元素和布局</title>
    <link href="http://blog.zhangjikai.com/2016/11/29/%E3%80%90CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91CSS%E5%85%83%E7%B4%A0%E5%92%8C%E5%B8%83%E5%B1%80/"/>
    <id>http://blog.zhangjikai.com/2016/11/29/【CSS学习笔记】CSS元素和布局/</id>
    <published>2016-11-29T12:49:18.000Z</published>
    <updated>2019-09-08T06:53:07.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文绝大部分摘自 <code>CSS 权威指南 第三版</code></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><strong>正常流 (Normal Flow)：</strong> 有时会被翻译为 <strong>文档流</strong> 或者 <strong>普通流</strong>，指文档从左至右、从上至下的显示内容，是传统的 HTML 文档布局。如果使元素不在正常流中，可以使用浮动（<code>float</code>）或者定位（<code>absolute</code>, <code>fixed</code>）。</li><li><strong>块级元素 (Block-level)：</strong> 块级元素在<strong>普通流</strong>中会独占一行，即在其框之前和之后生成“换行”，因此处于<strong>普通流</strong>中的块级元素会按照从上到下的顺序垂直（vertically）排列。常见的 block 元素有 <code>div</code>, <code>p</code>, <code>h1-h6</code>, <code>ul</code>, <code>li</code>, <code>canvas</code>, <code>table</code> 等。完整的元素可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements" target="_blank" rel="noopener">这里</a>。通过使用 <code>display:block</code>，可以将元素生成块级框。</li><li><strong>内联元素 (Inline)：</strong> 或者称为 <strong>行内元素</strong>。在<strong>普通流</strong>中的内联元素之间不会生成“行分割符”，因此处于<strong>普通流</strong>中的内联元素会首先按照从左至右的顺序水平（horizontally）排列，当父容器水平方向上的剩余宽度不足以放下新的内联元素时，会往下换行，在新行的中继续按照水平顺序排列元素。常见的 inline 元素有：<code>a</code>, <code>img</code>, <code>button</code>, <code>br</code>, <code>input</code>, <code>label</code>, <code>select</code>, <code>textarea</code>。完整的可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements" target="_blank" rel="noopener">这里</a>通过使用 <code>display:inline</code> 可以让元素变成内联元素。</li><li><strong>非替换元素 (non-replaced)：</strong> 如果元素的内容包含在文档中，就成为非替换元素。 例如段落 <code>&lt;p&gt;</code>。</li><li><strong>替换元素 (replaced)：</strong> 可以理解为嵌入元素，相当于一个占位符，解析时会被其他内容替换。例如 <code>&lt;img&gt;</code> 和大部分表单元素 <code>&lt;input type=&quot;radio&quot;&gt;</code>。</li><li><code>em</code>: 1em等于 <code>font-size</code> 的设置值</li></ul><a id="more"></a><h2 id="盒模型-Box-Model"><a href="#盒模型-Box-Model" class="headerlink" title="盒模型 (Box-Model)"></a>盒模型 (Box-Model)</h2><p><img src="/images/css_layout/box-model.png" alt>  </p><p>在盒子模型中，水平和垂直方向上各有7个属性:</p><ul><li>水平方向 - <code>margin-left</code>, <code>border-left</code>, <code>padding-left</code>, <code>width</code>,  <code>padding-right</code>,  <code>border-right</code>,  <code>margin-right</code></li><li>垂直方向 - <code>margin-top</code>,  <code>border-top</code>,  <code>padding-top</code>,  <code>height</code>, <code>padding-bottom</code>, <code>border-bottom</code>, <code>margin-bottom</code></li></ul><p>其中 <code>margin</code> 称为外边距，在计算元素整体宽高的时候一般不包括它。CSS3 中新增了一个属性 <code>box-sizing</code>，可以用来指定使用的盒模型计算方式。下面是 CSS3 中支持的盒模型计算方式（CSS2种只支持默认的）</p><ul><li><code>content-box</code>（默认值）: <code>width</code> 和 <code>height</code> 属性只作用到 Content Area 的长宽，在 Content Area 外面绘制内边距和边框，见图 (1)。<ul><li><code>Width = width + padding-left + padding-right + border-left + border-right</code></li><li><code>Height = height + padding-top + padding-bottom + border-top + border-bottom</code></li></ul></li><li><code>border-box</code>: <code>width</code> 和 <code>height</code> 属性设置的值就为元素整体的宽高，内边距和边框在已设定的宽度和高度内进行绘制，见图 (2)。<ul><li><code>Width = width</code></li><li><code>Height = height</code></li></ul></li><li><code>inherit</code>: 继承父类的属性</li></ul><p><img src="/images/css_layout/box-model-1.png" alt="图 (1) : content-box">  </p><p><img src="/images/css_layout/box-model-2.png" alt="图 (2) : border-box">  </p><h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2><!--### 水平属性通过上面的盒子模型，我们可以看到水平方向上对应7个属性 `margin-left`, `border-left`, `padding-left`, `width`, `padding-right`, `border-right`, `margin-right`。默认的盒模型计算方式为`content-box`（CSS3 新增了两个盒模型计算方式：`padding-box` 和 `border-box`，具体可以参考[这里](https://leohxj.gitbooks.io/front-end-database/content/html-and-css-basic/box-module.html)）。--><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>在上面提到的几个属性中，只有<code>margin</code>, <code>width</code>, <code>height</code> 可以设为 <code>auto</code>，<code>padding</code> 和 <code>border</code> 必须设定为特定值或者使用默认值。</p><h4 id="水平属性"><a href="#水平属性" class="headerlink" title="水平属性"></a>水平属性</h4><p>在上面提到的7个水平属性中，只有3个值可以设置为 <code>auto</code>：<code>width</code>, <code>margin-left</code>, <code>margin-right</code>。其余属性必须设置为特定的值或者使用默认值。下面是使用 <code>auto</code> 的几种情形：</p><ul><li>没有一个属性设为 <code>auto</code>： 如果 <code>width</code>, <code>margin-left</code>, <code>margin-right</code> 这三个属性都设为非 <code>auto</code> 的特定值，那么会将 <code>margin-right</code> 强制为 <code>auto</code>。</li><li>有且只有一个属性设为 <code>auto</code>： 如果三个属性中某个值设为 <code>auto</code>，而余下的两个属性设为特定的值，那么设置为 <code>auto</code> 的属性值会自动确定所需长度，从而使元素框的总宽度（上面提到的7种属性相加）等于父容器的 <code>width</code>。</li><li>两个外边距都设为 <code>auto</code>，<code>width</code> 设为特定值： 元素会居中（常用的居中方式），<code>margin-left</code> 和 <code>margin-right</code> 会设为相等的长度</li><li><code>width</code> 设为 <code>auto</code>，外边距有一个或者两个均设为 <code>auto</code>： 设为 <code>auto</code> 的外边距会变成0，如果两个外边距都设为 <code>auto</code>，会都变为0。</li></ul><h4 id="垂直属性"><a href="#垂直属性" class="headerlink" title="垂直属性"></a>垂直属性</h4><ul><li>如果 <code>margin-top</code> 和 <code>margin-bottom</code> 都设为 <code>auto</code>（对于定位元素会有不同），会将它们计算为0。</li><li><code>height</code> 设为 <code>auto</code>，一般等于其包含的子元素的总高度。</li></ul><h3 id="外边距合并"><a href="#外边距合并" class="headerlink" title="外边距合并"></a>外边距合并</h3><p>针对垂直外边距（<code>margin-top</code> 和 <code>margin-bottom</code>），两个相邻的垂直外边距会合并成一个外边距，两个外边距中较小的一个会被较大的一个合并。详细内容可以参考 <a href="http://www.w3school.com.cn/css/css_margin_collapsing.asp" target="_blank" rel="noopener">这里</a> 。</p><p><img src="/images/css_layout/margin-collapse.gif" alt>  </p><p>如果外边距中有负值：</p><ul><li>如果相邻的垂直外边距都设为负值，会取外边距中绝对值较大的那个外边距。例如一个外边距为：<code>margin-bottom:-10px</code>，和它相邻的另外一个为：<code>margin-top:-20px</code>，会保留 <code>margin-top:-20px</code>。</li><li>如果一个正外边距和一个负外边距，会从正外边距减去负外边距的绝对值。例如一个外边距为: <code>margin-bottom:20px</code>，另外一个为: <code>margin-top:-10px</code>，最终的效果相当于 <code>margin-bottom:10px</code>。</li></ul><h3 id="负外边距"><a href="#负外边距" class="headerlink" title="负外边距"></a>负外边距</h3><p>外边距可以是负的，即 <code>margin</code> 可以设为负值，此时子元素的 <code>width</code> 或者 <code>height</code> 就有可能大于父元素的 <code>width</code>。只有外边距能小于0，内边距、边框和内容的宽高都不能设为负值。</p><h2 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h2><p>东西比较多，先附一些文章链接：</p><ul><li><a href="https://segmentfault.com/a/1190000003038583" target="_blank" rel="noopener">CSS 中的line-height</a></li><li><a href="http://www.zhangxinxu.com/wordpress/2009/11/css%E8%A1%8C%E9%AB%98line-height%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">CSS 行高line-height的一些深入理解及应用</a></li><li><a href="http://www.slideshare.net/daemao/line-height-2470819" target="_blank" rel="noopener">CSS line-height 中文版</a></li><li><a href="http://blog.doyoe.com/2015/03/09/css/%E8%A7%86%E8%A7%89%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A1%86/" target="_blank" rel="noopener">视觉格式化模型中的各种框</a></li><li><strong>CSS权威指南</strong></li></ul><h3 id="行内框（inline-box）"><a href="#行内框（inline-box）" class="headerlink" title="行内框（inline-box）"></a>行内框（inline-box）</h3><p><a href="http://meyerweb.com/eric/css/inline-format.html" target="_blank" rel="noopener">http://meyerweb.com/eric/css/inline-format.html</a><br><a href="https://www.w3.org/TR/CSS21/visuren.html#inline-box" target="_blank" rel="noopener">https://www.w3.org/TR/CSS21/visuren.html#inline-box</a>  </p><p>行内框通过向内容区（context-area）增加行间距（leading）来描述。对于非替换元素来说，元素行内框的高度刚好等于 <code>line-height</code> 的值。对于替换元素来说，元素行内框的高度等于元素的 <code>height + margin-top + margin-bottom + padding-top + padding-bottom + border-top + border-bottom</code>。<br>浏览器会根据行内元素行内框的大小来对元素布局。假设行内元素的内容区高 <code>20px</code>，但是 <code>line-height</code> 只有 <code>14px</code>，那么为该元素分配的高度只有 <code>14px</code>，就会出现内容去溢出的情况（覆盖其他的行元素）。</p><h4 id="非替换元素"><a href="#非替换元素" class="headerlink" title="非替换元素"></a>非替换元素</h4><ul><li>margin, border, padding 不影响行内框的高度，但是会影响行内框的宽度。</li><li><code>width</code> 和 <code>height</code> 属性不会作用于行内非替换元素，即不能设置宽高。</li></ul><h4 id="替换元素"><a href="#替换元素" class="headerlink" title="替换元素"></a>替换元素</h4><ul><li>替换元素的 margin, border. padding 会影响行内框的宽度和高度</li><li>可以对替换元素设置 <code>width</code> 和 <code>height</code>。如果不设置宽高，会使用元素本来的宽度和高度。</li></ul><h4 id="设置line-height的几种方式"><a href="#设置line-height的几种方式" class="headerlink" title="设置line-height的几种方式"></a>设置line-height的几种方式</h4><p><code>line-height</code> 只作用于内联元素或者其他的内联内容。</p><ul><li><code>normal</code> - 默认值，设置合理的行间距（1.2）</li><li>具体的长度 - <code>12px</code> 、<code>1em</code> 等等</li><li>纯数字 - 和当前 <code>font-size</code> 的比值</li><li>百分比 - 和当前 <code>font-size</code> 的百分比</li><li><code>inherit</code> - 从父类中继承</li></ul><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul><li>内联非替换元素的 <code>width</code> 和 <code>height</code> 是不起作用的</li><li>padding 和 border 不改变 <code>line-height</code></li><li><code>margin-top</code> 和 <code>margin-bottom</code> 不作用于行内非替换元素，比如 <code>span</code></li></ul><h2 id="修改显示类别"><a href="#修改显示类别" class="headerlink" title="修改显示类别"></a>修改显示类别</h2><p>使用 <code>display:value</code> 可以修改元素的类别。有效值如下：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>此元素不会被显示。</td></tr><tr><td>block</td><td>此元素将显示为块级元素，此元素前后会带有换行符。</td></tr><tr><td>inline</td><td>默认。此元素会被显示为内联元素，元素前后没有换行符。</td></tr><tr><td>inline-block</td><td>行内块元素。（CSS2.1 新增的值）</td></tr><tr><td>list-item</td><td>此元素会作为列表显示。</td></tr><tr><td>run-in</td><td>此元素会根据上下文作为块级元素或内联元素显示。</td></tr><tr><td>compact</td><td>CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</td></tr><tr><td>marker</td><td>CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</td></tr><tr><td>table</td><td>此元素会作为块级表格来显示（类似 table），表格前后带有换行符。</td></tr><tr><td>inline-table</td><td>此元素会作为内联表格来显示（类似 table），表格前后没有换行符。</td></tr><tr><td>table-row-group</td><td>此元素会作为一个或多个行的分组来显示（类似 tbody）。</td></tr><tr><td>table-header-group</td><td>此元素会作为一个或多个行的分组来显示（类似 thead）。</td></tr><tr><td>table-footer-group</td><td>此元素会作为一个或多个行的分组来显示（类似 tfoot）。</td></tr><tr><td>table-row</td><td>此元素会作为一个表格行显示（类似 tr）。</td></tr><tr><td>table-column-group</td><td>此元素会作为一个或多个列的分组来显示（类似 colgroup）。</td></tr><tr><td>table-column</td><td>此元素会作为一个单元格列显示（类似 col）</td></tr><tr><td>table-cell</td><td>此元素会作为一个表格单元格显示（类似 td 和 th）</td></tr><tr><td>table-caption</td><td>此元素会作为一个表格标题显示（类似 caption）</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 display 属性的值。</td></tr></tbody></table><ul><li><code>inline-block</code>：会使元素表现的像行内非替换元素一样，是行内元素，但是可以设置宽高，margin, border, padding 会影响行内框的高度</li><li><code>run-in</code>：使某些块级元素成为下一个元素的行内元素(chrome不支持)。</li></ul><h2 id="浮动-float"><a href="#浮动-float" class="headerlink" title="浮动(float)"></a>浮动(float)</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float" target="_blank" rel="noopener">MDN float</a><br><a href="https://www.w3.org/TR/CSS2/visuren.html#floats" target="_blank" rel="noopener">w3 float</a></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>下面是MDN上关于 <code>float</code> 的定义</p><blockquote><p>The float CSS property specifies that an element should <strong>be taken from the normal flow</strong> and placed along the <strong>left or right side of its container</strong>, where <strong>text and inline elements will wrap around it</strong>.</p></blockquote><p>根据定义需要注意的有下面三点：</p><ol><li>浮动元素会脱离正常流。</li><li>浮动元素会被放置在所在容器的左侧或者右侧。</li><li>文字和行内元素会环绕浮动元素，所以会影响布局。</li></ol><h3 id="其他注意点"><a href="#其他注意点" class="headerlink" title="其他注意点"></a>其他注意点</h3><ul><li>浮动元素会生成一个块级框，即便元素本身是行内元素，也会生成块级框。所以不需要为浮动元素声明 <code>display:block</code>。</li><li>浮动元素的外边距不会合并。</li><li>浮动元素之间一般不会重叠（外边距设为负值就可能会重叠），会按照顺序排序，如果当前行剩余的宽度不足以放下新的元素，会另起一行。</li><li>浮动元素会延伸，从而包含其所有的代浮动元素。</li></ul><h3 id="重叠"><a href="#重叠" class="headerlink" title="重叠"></a>重叠</h3><p>如果浮动元素和正常流中的内容发生重叠（浮动元素的外边距为负值），会按照以下规则显示内容：</p><ul><li>行内框和一个浮动元素重叠时，其边框、背景和内容都会在该浮动元素 <strong>之上</strong> 显示</li><li>框框与一个浮动元素重叠时，其边框和背景在该浮动元素 <strong>之下</strong> 显示，内容在浮动元素 <strong>之上</strong> 显示</li></ul><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>清除浮动就是让元素的左边或者右边或者两边不会有浮动元素出现。清除浮动的一个主要的原因就是增加父容器的高度，当子元素浮动时，会脱离正常流，因此父元素计算高度时不会加上浮动子元素的高度，就会造成父元素的高度小于浮动子元素。当清除浮动之后，父容器就可以正确高度。下面是清除浮动的几种方式，更多方式可以参考 <a href="http://lightcss.com/all-about-clear-float/" target="_blank" rel="noopener">这里</a> ：</p><ul><li><p>使用带clear元素的空属性</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.clear&#123;</span><br><span class="line">    clear:both;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>:after</code> 伪元素</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">'\20'</span>;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">visibility</span>:hidden</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class="clearfix"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>在父容器里添加 <code>overflow:auto</code> 或者 <code>overflow:hidden</code></p></li></ul><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>CSS 有三种基本的定位机制: 正常流、浮动和绝对定位。使用 <code>position</code> 可以设置不同类型的定位方式。下面是 <code>position</code> 属性值的定义:</p><ul><li><code>static</code>：默认值，元素框正常生成，不会被特殊的定位。块级元素生成块级块，行内元素生成一个或者多个行框，置于其父元素中。</li><li><code>relative</code>: 元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。<code>relative</code> 的表现和 <code>static</code> 十分类似，不同的是相对于定位参考的是它<strong>应该在的位置</strong>(或者说它自身的位置)，通过使用偏移属性 <code>top</code>, <code>bottom</code>, <code>left</code> 和 <code>right</code> 属性会使元素<strong>相对于</strong> 它的<strong>起点</strong>进行移动。<strong>其他元素的位置不会受到影响</strong>。</li><li><code>absolute</code>: 元素会脱离正常流，相对于其最近的非 static 定位的祖先元素定位，如果没有满足条件的祖先元素，则会相对于文档的 <code>body</code> 元素。元素在正常流中的所占的位置会被清除，就好像该元素不存在一样。<code>absolute</code> 元素会生成一个块级框。</li><li><code>fixed</code>: 和 <code>absolute</code> 类似，不过其定位的参考元素是视窗，当页面滚动时还是会停留在原先的位置。 <code>absolute</code> 会跟随父元素滚动。</li></ul><h3 id="其他注意点-1"><a href="#其他注意点-1" class="headerlink" title="其他注意点"></a>其他注意点</h3><ul><li>一般称 <code>relative</code>, <code>absolute</code> 以及 <code>fixed</code> 为定位元素 (positioned)</li><li>除了 <code>static</code>，其他三种定位都可以使用偏移属性 <code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code>。</li><li><code>absolute</code> 定位里 <code>left</code>,  <code>right</code>, <code>width</code>，有一个值设为 <code>auto</code>，会自动调整其大小，使总长度相加等于父容器宽度。如果有没有auto，会重置 <code>right</code>。<code>top</code> 和 <code>bottom</code> 类似。</li></ul><h3 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h3><p>利用 <code>z-index</code> 可以修改元素相互的覆盖顺序。所有数都可以作为 <code>z-index</code> 的值，包括负数。需要注意的是</p><ul><li><code>z-index</code> 只能作用于定位元素，<code>static</code> 元素会失效</li><li>子元素会继承父元素的 <code>z-index</code>，子元素设置的 <code>z-index</code> 是相对于父元素的局部 <code>z-index</code>。比如下面的代码：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.p1</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">z-index</span>:<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.p2</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">z-index</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.p1</span> <span class="selector-class">.c</span> &#123;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.p2</span> <span class="selector-class">.c</span>&#123;</span><br><span class="line">    <span class="attribute">z-index</span>:<span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>.p2 .c</code> 会在 <code>.p1 .c</code> 的下面</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文绝大部分摘自 &lt;code&gt;CSS 权威指南 第三版&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;正常流 (Normal Flow)：&lt;/strong&gt; 有时会被翻译为 &lt;strong&gt;文档流&lt;/strong&gt; 或者 &lt;strong&gt;普通流&lt;/strong&gt;，指文档从左至右、从上至下的显示内容，是传统的 HTML 文档布局。如果使元素不在正常流中，可以使用浮动（&lt;code&gt;float&lt;/code&gt;）或者定位（&lt;code&gt;absolute&lt;/code&gt;, &lt;code&gt;fixed&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;块级元素 (Block-level)：&lt;/strong&gt; 块级元素在&lt;strong&gt;普通流&lt;/strong&gt;中会独占一行，即在其框之前和之后生成“换行”，因此处于&lt;strong&gt;普通流&lt;/strong&gt;中的块级元素会按照从上到下的顺序垂直（vertically）排列。常见的 block 元素有 &lt;code&gt;div&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;h1-h6&lt;/code&gt;, &lt;code&gt;ul&lt;/code&gt;, &lt;code&gt;li&lt;/code&gt;, &lt;code&gt;canvas&lt;/code&gt;, &lt;code&gt;table&lt;/code&gt; 等。完整的元素可以参考&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。通过使用 &lt;code&gt;display:block&lt;/code&gt;，可以将元素生成块级框。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内联元素 (Inline)：&lt;/strong&gt; 或者称为 &lt;strong&gt;行内元素&lt;/strong&gt;。在&lt;strong&gt;普通流&lt;/strong&gt;中的内联元素之间不会生成“行分割符”，因此处于&lt;strong&gt;普通流&lt;/strong&gt;中的内联元素会首先按照从左至右的顺序水平（horizontally）排列，当父容器水平方向上的剩余宽度不足以放下新的内联元素时，会往下换行，在新行的中继续按照水平顺序排列元素。常见的 inline 元素有：&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;img&lt;/code&gt;, &lt;code&gt;button&lt;/code&gt;, &lt;code&gt;br&lt;/code&gt;, &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;label&lt;/code&gt;, &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;textarea&lt;/code&gt;。完整的可以参考&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;通过使用 &lt;code&gt;display:inline&lt;/code&gt; 可以让元素变成内联元素。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非替换元素 (non-replaced)：&lt;/strong&gt; 如果元素的内容包含在文档中，就成为非替换元素。 例如段落 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;替换元素 (replaced)：&lt;/strong&gt; 可以理解为嵌入元素，相当于一个占位符，解析时会被其他内容替换。例如 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 和大部分表单元素 &lt;code&gt;&amp;lt;input type=&amp;quot;radio&amp;quot;&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;em&lt;/code&gt;: 1em等于 &lt;code&gt;font-size&lt;/code&gt; 的设置值&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://blog.zhangjikai.com/categories/CSS/"/>
    
    
      <category term="学习笔记" scheme="http://blog.zhangjikai.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="CSS" scheme="http://blog.zhangjikai.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>【HTML5】Canvas 实现放大镜效果</title>
    <link href="http://blog.zhangjikai.com/2016/10/09/%E3%80%90HTML5%E3%80%91Canvas-%E6%94%BE%E5%A4%A7%E9%95%9C/"/>
    <id>http://blog.zhangjikai.com/2016/10/09/【HTML5】Canvas-放大镜/</id>
    <published>2016-10-09T01:58:34.000Z</published>
    <updated>2019-09-08T06:53:07.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图片放大镜"><a href="#图片放大镜" class="headerlink" title="图片放大镜"></a>图片放大镜</h2><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="/images/glass/002.png" alt><br><a href="http://zhangjikai.com/demo/html5-magnifying-glass/image.html" target="_blank" rel="noopener">在线演示</a> &nbsp;&nbsp; <a href="https://github.com/zhangjikai/samples/tree/master/html5-magnifying-glass" target="_blank" rel="noopener">源码</a></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>首先选择图片的一块区域，然后将这块区域放大，然后再绘制到原先的图片上，保证两块区域的中心点一致, 如下图所示:<br><img src="/images/glass/001.png" alt></p><a id="more"></a><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span> <span class="attr">width</span>=<span class="string">"500"</span> <span class="attr">height</span>=<span class="string">"500"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image.png"</span> <span class="attr">style</span>=<span class="string">"display: none"</span> <span class="attr">id</span>=<span class="string">"img"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>获得 canvas 和 image 对象，这里使用 <code>&lt;img&gt;</code> 标签预加载图片, 关于图片预加载可以看<a href="http://blog.zhangjikai.com/2015/06/22/%E3%80%90HTML5%E3%80%91%E5%9B%BE%E7%89%87%E9%A2%84%E5%8A%A0%E8%BD%BD/">这里</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>);</span><br><span class="line"><span class="keyword">var</span> context = canvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">"img"</span>);</span><br></pre></td></tr></table></figure></p><p>设置相关变量<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图片被放大区域的中心点，也是放大镜的中心点</span></span><br><span class="line"><span class="keyword">var</span> centerPoint = &#123;&#125;;</span><br><span class="line"><span class="comment">// 图片被放大区域的半径</span></span><br><span class="line"><span class="keyword">var</span> originalRadius = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 图片被放大区域</span></span><br><span class="line"><span class="keyword">var</span> originalRectangle = &#123;&#125;;</span><br><span class="line"><span class="comment">// 放大倍数</span></span><br><span class="line"><span class="keyword">var</span> scale = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 放大后区域</span></span><br><span class="line"><span class="keyword">var</span> scaleGlassRectangle</span><br></pre></td></tr></table></figure></p><h3 id="画背景图片"><a href="#画背景图片" class="headerlink" title="画背景图片"></a>画背景图片</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawBackGround</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    context.drawImage(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算图片被放大的区域的范围"><a href="#计算图片被放大的区域的范围" class="headerlink" title="计算图片被放大的区域的范围"></a>计算图片被放大的区域的范围</h3><p>这里我们使用鼠标的位置作为被放大区域的中心点(放大镜随着鼠标移动而移动)，因为 canvas 在画图片的时候，需要知道左上角的坐标以及区域的宽高，所以这里我们计算区域的范围<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calOriginalRectangle</span>(<span class="params">point</span>) </span>&#123;</span><br><span class="line">    originalRectangle.x = point.x - originalRadius;</span><br><span class="line">    originalRectangle.y = point.y - originalRadius;</span><br><span class="line">    originalRectangle.width = originalRadius * <span class="number">2</span>;</span><br><span class="line">    originalRectangle.height = originalRadius * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="绘制放大镜区域"><a href="#绘制放大镜区域" class="headerlink" title="绘制放大镜区域"></a>绘制放大镜区域</h3><h4 id="裁剪区域"><a href="#裁剪区域" class="headerlink" title="裁剪区域"></a>裁剪区域</h4><p>放大镜一般是圆形的，这里我们使用 <code>clip</code> 函数裁剪出一个圆形区域，然后在该区域中绘制放大后的图。一旦裁减了某个区域，以后所有的绘图都会被限制的这个区域里，这里我们使用 <code>save</code> 和 <code>restore</code> 方法清除裁剪区域的影响。<code>save</code> 保存当前画布的一次状态，包含 canvas 的上下文属性，例如 <code>style</code>，<code>lineWidth</code> 等，然后会将这个状态压入一个堆栈。<code>restore</code> 用来恢复上一次 save 的状态，从堆栈里弹出最顶层的状态。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context.save();</span><br><span class="line">context.beginPath();</span><br><span class="line">context.arc(centerPoint.x, centerPoint.y, originalRadius, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">false</span>);</span><br><span class="line">context.clip();</span><br><span class="line">......</span><br><span class="line">context.restore();</span><br></pre></td></tr></table></figure></p><h4 id="计算放大镜区域"><a href="#计算放大镜区域" class="headerlink" title="计算放大镜区域"></a>计算放大镜区域</h4><p>通过中心点、被放大区域的宽高以及放大倍数，获得区域的左上角坐标以及区域的宽高。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scaleGlassRectangle = &#123;</span><br><span class="line">    x: centerPoint.x - originalRectangle.width * scale / <span class="number">2</span>,</span><br><span class="line">    y: centerPoint.y - originalRectangle.height * scale / <span class="number">2</span>,</span><br><span class="line">    width: originalRectangle.width * scale,</span><br><span class="line">    height: originalRectangle.height * scale</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h4><p>在这里我们使用 <code>context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);</code> 方法，将 canvas 自身作为一副图片，然后取被放大区域的图像，将其绘制到放大镜区域里。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context.drawImage(canvas,</span><br><span class="line">    originalRectangle.x, originalRectangle.y,</span><br><span class="line">    originalRectangle.width, originalRectangle.height,</span><br><span class="line">    scaleGlassRectangle.x, scaleGlassRectangle.y,</span><br><span class="line">    scaleGlassRectangle.width, scaleGlassRectangle.height</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h4 id="绘制放大边缘"><a href="#绘制放大边缘" class="headerlink" title="绘制放大边缘"></a>绘制放大边缘</h4><p><code>createRadialGradient</code> 用来绘制渐变图像<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">context.beginPath();</span><br><span class="line"><span class="keyword">var</span> gradient = context.createRadialGradient(</span><br><span class="line">    centerPoint.x, centerPoint.y, originalRadius - <span class="number">5</span>,</span><br><span class="line">    centerPoint.x, centerPoint.y, originalRadius);</span><br><span class="line">gradient.addColorStop(<span class="number">0</span>, <span class="string">'rgba(0,0,0,0.2)'</span>);</span><br><span class="line">gradient.addColorStop(<span class="number">0.80</span>, <span class="string">'silver'</span>);</span><br><span class="line">gradient.addColorStop(<span class="number">0.90</span>, <span class="string">'silver'</span>);</span><br><span class="line">gradient.addColorStop(<span class="number">1.0</span>, <span class="string">'rgba(150,150,150,0.9)'</span>);</span><br><span class="line"></span><br><span class="line">context.strokeStyle = gradient;</span><br><span class="line">context.lineWidth = <span class="number">5</span>;</span><br><span class="line">context.arc(centerPoint.x, centerPoint.y, originalRadius, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">false</span>);</span><br><span class="line">context.stroke();</span><br></pre></td></tr></table></figure></p><h3 id="添加鼠标事件"><a href="#添加鼠标事件" class="headerlink" title="添加鼠标事件"></a>添加鼠标事件</h3><p>为 canvas 添加鼠标移动事件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canvas.onmousemove = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="转换坐标"><a href="#转换坐标" class="headerlink" title="转换坐标"></a>转换坐标</h4><p>鼠标事件获得坐标一般为屏幕的或者 window 的坐标，我们需要将其装换为 canvas 的坐标。<code>getBoundingClientRect</code> 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">windowToCanvas</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bbox = canvas.getBoundingClientRect();</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">x</span>: x - bbox.left, <span class="attr">y</span>: y - bbox.top&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="修改鼠标样式"><a href="#修改鼠标样式" class="headerlink" title="修改鼠标样式"></a>修改鼠标样式</h4><p>我们可以通过 css 来修改鼠标样式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#canvas</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">cursor</span>: crosshair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="图表放大镜"><a href="#图表放大镜" class="headerlink" title="图表放大镜"></a>图表放大镜</h2><p>我们可能基于 canvas 绘制一些图表或者图像，如果两个元素的坐标离得比较近，就会给元素的选择带来一些影响，例如我们画两条线，一个线的坐标是<code>(200.5, 400) -&gt; (200.5, 200)</code>，另一个线的坐标为 <code>(201.5, 400) -&gt; (201.5, 20)</code>，那么这两条线几乎就会重叠在一起，如下图所示：<br><img src="/images/glass/003.png" alt><br>使用图表放大镜的效果<br><img src="/images/glass/004.png" alt></p><p><a href="http://zhangjikai.com/demo/html5-magnifying-glass/chart.html" target="_blank" rel="noopener">在线演示</a> &nbsp;&nbsp; <a href="https://github.com/zhangjikai/samples/tree/master/html5-magnifying-glass" target="_blank" rel="noopener">源码</a></p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>类似于地图中的图例，放大镜使用较为精确的图例，如下图所示：</p><p><img src="/images/glass/005.png" alt></p><p>在放大镜坐标系统中，原始的区域会变大，如下图所示</p><p><img src="/images/glass/006.png" alt></p><h3 id="绘制原始线段"><a href="#绘制原始线段" class="headerlink" title="绘制原始线段"></a>绘制原始线段</h3><p>首先创建一个线段对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Line</span>(<span class="params">xStart, yStart, xEnd, yEnd, index, color</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 起点x坐标</span></span><br><span class="line">    <span class="keyword">this</span>.xStart = xStart;</span><br><span class="line">    <span class="comment">// 起点y坐标</span></span><br><span class="line">    <span class="keyword">this</span>.yStart = yStart;</span><br><span class="line">    <span class="comment">// 终点x坐标</span></span><br><span class="line">    <span class="keyword">this</span>.xEnd = xEnd;</span><br><span class="line">    <span class="comment">// 终点y坐标</span></span><br><span class="line">    <span class="keyword">this</span>.yEnd = yEnd;</span><br><span class="line">    <span class="comment">// 用来标记是哪条线段</span></span><br><span class="line">    <span class="keyword">this</span>.index = index;</span><br><span class="line">    <span class="comment">// 线段颜色</span></span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>初始化线段<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始线段</span></span><br><span class="line"><span class="keyword">var</span> chartLines = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="comment">// 处于放大镜中的原始线段</span></span><br><span class="line"><span class="keyword">var</span> glassLines;</span><br><span class="line"><span class="comment">// 放大后的线段</span></span><br><span class="line"><span class="keyword">var</span> scaleGlassLines;</span><br><span class="line"><span class="comment">// 位于放大镜中的线段数量</span></span><br><span class="line"><span class="keyword">var</span> glassLineSize;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initLines</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> line;</span><br><span class="line">    line = <span class="keyword">new</span> Line(<span class="number">200.5</span>, <span class="number">400</span>, <span class="number">200.5</span>, <span class="number">200</span>, <span class="number">0</span>, <span class="string">"#888"</span>);</span><br><span class="line">    chartLines.push(line);</span><br><span class="line">    line = <span class="keyword">new</span> Line(<span class="number">201.5</span>, <span class="number">400</span>, <span class="number">201.5</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="string">"#888"</span>);</span><br><span class="line">    chartLines.push(line);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    glassLineSize = chartLines.length;</span><br><span class="line">    glassLines = <span class="keyword">new</span> <span class="built_in">Array</span>(glassLineSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; glassLineSize; i++) &#123;</span><br><span class="line">        line = <span class="keyword">new</span> Line(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, i);</span><br><span class="line">        glassLines[i] = line;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scaleGlassLines = <span class="keyword">new</span> <span class="built_in">Array</span>(glassLineSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; glassLineSize; i++) &#123;</span><br><span class="line">        line = <span class="keyword">new</span> Line(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, i);</span><br><span class="line">        scaleGlassLines[i] = line;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>绘制线段<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawLines</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> line;</span><br><span class="line">    context.lineWidth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; chartLines.length; i++) &#123;</span><br><span class="line">        line = chartLines[i];</span><br><span class="line">        context.beginPath();</span><br><span class="line">        context.strokeStyle = line.color;</span><br><span class="line">        context.moveTo(line.xStart, line.yStart);</span><br><span class="line">        context.lineTo(line.xEnd, line.yEnd);</span><br><span class="line">        context.stroke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="计算原始区域和放大镜区域"><a href="#计算原始区域和放大镜区域" class="headerlink" title="计算原始区域和放大镜区域"></a>计算原始区域和放大镜区域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calGlassRectangle</span>(<span class="params">point</span>) </span>&#123;</span><br><span class="line">    originalRectangle.x = point.x - originalRadius;</span><br><span class="line">    originalRectangle.y = point.y - originalRadius;</span><br><span class="line">    originalRectangle.width = originalRadius * <span class="number">2</span>;</span><br><span class="line">    originalRectangle.height = originalRadius * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    scaleGlassRectangle.width = originalRectangle.width * scale;</span><br><span class="line">    scaleGlassRectangle.height = originalRectangle.height * scale;</span><br><span class="line">    scaleGlassRectangle.x = originalRectangle.x + originalRectangle.width / <span class="number">2</span> - scaleGlassRectangle.width / <span class="number">2</span>;</span><br><span class="line">    scaleGlassRectangle.y = originalRectangle.y + originalRectangle.height / <span class="number">2</span> - scaleGlassRectangle.height / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将值装换为整数</span></span><br><span class="line">    scaleGlassRectangle.width = <span class="built_in">parseInt</span>(scaleGlassRectangle.width);</span><br><span class="line">    scaleGlassRectangle.height = <span class="built_in">parseInt</span>(scaleGlassRectangle.height);</span><br><span class="line">    scaleGlassRectangle.x = <span class="built_in">parseInt</span>(scaleGlassRectangle.x);</span><br><span class="line">    scaleGlassRectangle.y = <span class="built_in">parseInt</span>(scaleGlassRectangle.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算线段在新坐标系统的位置"><a href="#计算线段在新坐标系统的位置" class="headerlink" title="计算线段在新坐标系统的位置"></a>计算线段在新坐标系统的位置</h3><p>由原理图我们知道，放大镜中使用坐标系的图例要比原始坐标系更加精确，比如原始坐标系使用 <code>1:100</code>，那么放大镜坐标系使用 <code>1:10</code>，因此我们需要重新计算线段在放大镜坐标系中的位置。同时为了简便，我们将线段的原始坐标进行了转化，减去原始区域起始的x值和y值，即将原始区域左上角的点看做为<code>(0,0)</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calScaleLines</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xStart = originalRectangle.x;</span><br><span class="line">    <span class="keyword">var</span> xEnd = originalRectangle.x + originalRectangle.width;</span><br><span class="line">    <span class="keyword">var</span> yStart = originalRectangle.y;</span><br><span class="line">    <span class="keyword">var</span> yEnd = originalRectangle.y + originalRectangle.height;</span><br><span class="line">    <span class="keyword">var</span> line, gLine, sgLine;</span><br><span class="line">    <span class="keyword">var</span> glassLineIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; chartLines.length; i++) &#123;</span><br><span class="line">        line = chartLines[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断线段是否在放大镜中</span></span><br><span class="line">        <span class="keyword">if</span> (line.xStart &lt; xStart || line.xEnd &gt; xEnd) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (line.yEnd &gt; yEnd || line.yStart &lt; yStart) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gLine = glassLines[glassLineIndex];</span><br><span class="line">        sgLine = scaleGlassLines[glassLineIndex];</span><br><span class="line">        <span class="keyword">if</span> (line.yEnd &gt; yEnd) &#123;</span><br><span class="line">            gLine.yEnd = yEnd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (line.yStart &lt; yStart) &#123;</span><br><span class="line">            gLine.yStart = yStart;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gLine.xStart = line.xStart - xStart;</span><br><span class="line">        gLine.yStart = line.yStart - yStart;</span><br><span class="line">        gLine.xEnd = line.xEnd - xStart;</span><br><span class="line">        gLine.yEnd = line.yEnd - yStart;</span><br><span class="line"></span><br><span class="line">        sgLine.xStart = <span class="built_in">parseInt</span>(gLine.xStart * scale);</span><br><span class="line">        sgLine.yStart = <span class="built_in">parseInt</span>(gLine.yStart * scale);</span><br><span class="line">        sgLine.xEnd = <span class="built_in">parseInt</span>(gLine.xEnd * scale);</span><br><span class="line">        sgLine.yEnd = <span class="built_in">parseInt</span>(gLine.yEnd * scale);</span><br><span class="line">        sgLine.color = line.color;</span><br><span class="line">        glassLineIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    glassLineSize = glassLineIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="绘制放大镜中心点"><a href="#绘制放大镜中心点" class="headerlink" title="绘制放大镜中心点"></a>绘制放大镜中心点</h3><p>绘制放大镜中心的瞄准器<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawAnchor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.lineWidth = <span class="number">2</span>;</span><br><span class="line">    context.fillStyle = <span class="string">"#fff"</span>;</span><br><span class="line">    context.strokeStyle = <span class="string">"#000"</span>;</span><br><span class="line">    context.arc(<span class="built_in">parseInt</span>(centerPoint.x), <span class="built_in">parseInt</span>(centerPoint.y), <span class="number">10</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> radius = <span class="number">15</span>;</span><br><span class="line">    context.moveTo(<span class="built_in">parseInt</span>(centerPoint.x - radius), <span class="built_in">parseInt</span>(centerPoint.y));</span><br><span class="line">    context.lineTo(<span class="built_in">parseInt</span>(centerPoint.x + radius), <span class="built_in">parseInt</span>(centerPoint.y));</span><br><span class="line">    context.moveTo(<span class="built_in">parseInt</span>(centerPoint.x), <span class="built_in">parseInt</span>(centerPoint.y - radius));</span><br><span class="line">    context.lineTo(<span class="built_in">parseInt</span>(centerPoint.x), <span class="built_in">parseInt</span>(centerPoint.y + radius));</span><br><span class="line">    <span class="comment">//context.fill();</span></span><br><span class="line">    context.stroke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="绘制放大镜"><a href="#绘制放大镜" class="headerlink" title="绘制放大镜"></a>绘制放大镜</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawMagnifyingGlass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    calScaleLines();</span><br><span class="line"></span><br><span class="line">    context.save();</span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.arc(centerPoint.x, centerPoint.y, originalRadius, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">false</span>);</span><br><span class="line">    context.clip();</span><br><span class="line"></span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.fillStyle = <span class="string">"#fff"</span>;</span><br><span class="line">    context.arc(centerPoint.x, centerPoint.y, originalRadius, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">false</span>);</span><br><span class="line">    context.fill();</span><br><span class="line"></span><br><span class="line">    context.lineWidth = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; glassLineSize; i++) &#123;</span><br><span class="line">        context.beginPath();</span><br><span class="line">        context.strokeStyle = scaleGlassLines[i].color;</span><br><span class="line">        context.moveTo(scaleGlassRectangle.x + scaleGlassLines[i].xStart, scaleGlassRectangle.y + scaleGlassLines[i].yStart);</span><br><span class="line">        context.lineTo(scaleGlassRectangle.x + scaleGlassLines[i].xEnd, scaleGlassRectangle.y + scaleGlassLines[i].yEnd);</span><br><span class="line">        context.stroke();</span><br><span class="line">    &#125;</span><br><span class="line">    context.restore();</span><br><span class="line"></span><br><span class="line">    context.beginPath();</span><br><span class="line">    <span class="keyword">var</span> gradient = context.createRadialGradient(</span><br><span class="line">        <span class="built_in">parseInt</span>(centerPoint.x), <span class="built_in">parseInt</span>(centerPoint.y), originalRadius - <span class="number">5</span>,</span><br><span class="line">        <span class="built_in">parseInt</span>(centerPoint.x), <span class="built_in">parseInt</span>(centerPoint.y), originalRadius);</span><br><span class="line"></span><br><span class="line">    gradient.addColorStop(<span class="number">0.50</span>, <span class="string">'silver'</span>);</span><br><span class="line">    gradient.addColorStop(<span class="number">0.90</span>, <span class="string">'silver'</span>);</span><br><span class="line">    gradient.addColorStop(<span class="number">1</span>, <span class="string">'black'</span>);</span><br><span class="line">    context.strokeStyle = gradient;</span><br><span class="line">    context.lineWidth = <span class="number">5</span>;</span><br><span class="line">    context.arc(<span class="built_in">parseInt</span>(centerPoint.x), <span class="built_in">parseInt</span>(centerPoint.y), originalRadius, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">false</span>);</span><br><span class="line">    context.stroke();</span><br><span class="line"></span><br><span class="line">    drawAnchor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加事件"><a href="#添加事件" class="headerlink" title="添加事件"></a>添加事件</h3><h4 id="鼠标拖动"><a href="#鼠标拖动" class="headerlink" title="鼠标拖动"></a>鼠标拖动</h4><p>鼠标移动到放大镜上，然后按下鼠标左键，可以拖动放大镜，不按鼠标左键或者不在放大镜区域都不可以拖动放大镜。<br>为了实现上面的效果，我们要实现3种事件 <code>mousedown</code>, <code>mousemove</code>, ‘mouseup’, 当鼠标按下时，检测是否在放大镜区域，如果在，设置放大镜可以移动。鼠标移动时更新放大镜中兴点的坐标。鼠标松开时，设置放大镜不可以被移动。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">canvas.onmousedown = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> point = windowToCanvas(e.clientX, e.clientY);</span><br><span class="line">    <span class="keyword">var</span> x1, x2, y1, y2, dis;</span><br><span class="line"></span><br><span class="line">    x1 = point.x;</span><br><span class="line">    y1 = point.y;</span><br><span class="line">    x2 = centerPoint.x;</span><br><span class="line">    y2 = centerPoint.y;</span><br><span class="line">    dis = <span class="built_in">Math</span>.pow(x2 - x1, <span class="number">2</span>) + <span class="built_in">Math</span>.pow(y2 - y1, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (dis &lt; <span class="built_in">Math</span>.pow(originalRadius, <span class="number">2</span>)) &#123;</span><br><span class="line">        lastPoint.x = point.x;</span><br><span class="line">        lastPoint.y = point.y;</span><br><span class="line">        moveGlass = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">canvas.onmousemove = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (moveGlass) &#123;</span><br><span class="line">        <span class="keyword">var</span> xDis, yDis;</span><br><span class="line">        <span class="keyword">var</span> point = windowToCanvas(e.clientX, e.clientY);</span><br><span class="line">        xDis = point.x - lastPoint.x;</span><br><span class="line">        yDis = point.y - lastPoint.y;</span><br><span class="line">        centerPoint.x += xDis;</span><br><span class="line">        centerPoint.y += yDis;</span><br><span class="line">        lastPoint.x = point.x;</span><br><span class="line">        lastPoint.y = point.y;</span><br><span class="line">        draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">canvas.onmouseup = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    moveGlass = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="鼠标双击"><a href="#鼠标双击" class="headerlink" title="鼠标双击"></a>鼠标双击</h4><p>当移动到对应的线段上时，鼠标双击可以选择该线段，将该线段的颜色变为红色。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">canvas.ondblclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xStart, xEnd, yStart, yEnd;</span><br><span class="line">    <span class="keyword">var</span> clickPoint = &#123;&#125;;</span><br><span class="line">    clickPoint.x = scaleGlassRectangle.x + scaleGlassRectangle.width / <span class="number">2</span>;</span><br><span class="line">    clickPoint.y = scaleGlassRectangle.y + scaleGlassRectangle.height / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; scaleGlassLines.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> scaleLine = scaleGlassLines[i];</span><br><span class="line"></span><br><span class="line">        xStart = scaleGlassRectangle.x + scaleLine.xStart - <span class="number">3</span>;</span><br><span class="line">        xEnd = scaleGlassRectangle.x + scaleLine.xStart + <span class="number">3</span>;</span><br><span class="line">        yStart = scaleGlassRectangle.y + scaleLine.yStart;</span><br><span class="line">        yEnd = scaleGlassRectangle.y + scaleLine.yEnd;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clickPoint.x &gt; xStart &amp;&amp; clickPoint.x &lt; xEnd &amp;&amp; clickPoint.y &lt; yStart &amp;&amp; clickPoint.y &gt; yEnd) &#123;</span><br><span class="line">            scaleLine.color = <span class="string">"#f00"</span>;</span><br><span class="line">            index = scaleLine.index;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; chartLines.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> line = chartLines[i];</span><br><span class="line">        <span class="keyword">if</span> (line.index == index) &#123;</span><br><span class="line">            line.color = <span class="string">"#f00"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            line.color = <span class="string">"#888"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><p>因为线段离得比较近，所以使用鼠标移动很难精确的选中线段，这里使用键盘的<code>w</code>, <code>a</code>, <code>s</code>, <code>d</code> 来进行精确移动<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.onkeyup = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.key == <span class="string">'w'</span>) &#123;</span><br><span class="line">        centerPoint.y = intAdd(centerPoint.y, <span class="number">-0.2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.key == <span class="string">'a'</span>) &#123;</span><br><span class="line">        centerPoint.x = intAdd(centerPoint.x, <span class="number">-0.2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.key == <span class="string">'s'</span>) &#123;</span><br><span class="line">        centerPoint.y = intAdd(centerPoint.y, <span class="number">0.2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.key == <span class="string">'d'</span>) &#123;</span><br><span class="line">        centerPoint.x = intAdd(centerPoint.x, <span class="number">0.2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong> 参考资料 </strong><br><a href="https://github.com/David-Geary/HTML5-MagnifyingGlass" target="_blank" rel="noopener">HTML5-MagnifyingGlass</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;图片放大镜&quot;&gt;&lt;a href=&quot;#图片放大镜&quot; class=&quot;headerlink&quot; title=&quot;图片放大镜&quot;&gt;&lt;/a&gt;图片放大镜&lt;/h2&gt;&lt;h3 id=&quot;效果&quot;&gt;&lt;a href=&quot;#效果&quot; class=&quot;headerlink&quot; title=&quot;效果&quot;&gt;&lt;/a&gt;效果&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/glass/002.png&quot; alt&gt;&lt;br&gt;&lt;a href=&quot;http://zhangjikai.com/demo/html5-magnifying-glass/image.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在线演示&lt;/a&gt; &amp;nbsp;&amp;nbsp; &lt;a href=&quot;https://github.com/zhangjikai/samples/tree/master/html5-magnifying-glass&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;首先选择图片的一块区域，然后将这块区域放大，然后再绘制到原先的图片上，保证两块区域的中心点一致, 如下图所示:&lt;br&gt;&lt;img src=&quot;/images/glass/001.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="HTML5" scheme="http://blog.zhangjikai.com/categories/HTML5/"/>
    
    
      <category term="HTML5" scheme="http://blog.zhangjikai.com/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>【软件】解决 win8/win10 中Windows Media Player 无法播放ipv6直播(MMS串流)</title>
    <link href="http://blog.zhangjikai.com/2016/09/13/%E3%80%90%E8%BD%AF%E4%BB%B6%E3%80%91%E8%A7%A3%E5%86%B3-win8-win10-%E4%B8%ADWindows-Meida-Player-%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BEipv6%E7%9B%B4%E6%92%AD-MMS%E4%B8%B2%E6%B5%81/"/>
    <id>http://blog.zhangjikai.com/2016/09/13/【软件】解决-win8-win10-中Windows-Meida-Player-无法播放ipv6直播-MMS串流/</id>
    <published>2016-09-12T23:55:17.000Z</published>
    <updated>2019-09-08T06:53:07.633Z</updated>
    
    <content type="html"><![CDATA[<ol><li>打开控制面板，选择 <code>程序</code><br><img src="/images/mms/01.jpg" alt><a id="more"></a></li><li><p><code>默认程序</code> -&gt; <code>设置默认程序</code><br><img src="/images/mms/02.jpg" alt></p></li><li><p>左侧选中 <code>Windows Media Player</code>，右侧选择 <code>选择此程序的默认值</code><br><img src="/images/mms/03.jpg" alt></p></li><li><p>在 <code>协议</code> 下勾选上 <code>MMS</code><br><img src="/images/mms/04.jpg" alt></p></li></ol><hr><p>参考文章: <a href="http://www.tipandtrick.net/solution-to-windows-media-player-11-wmp11-cannot-stream-and-play-mms-media-protocol-in-vista/" target="_blank" rel="noopener">Solution to Windows Media Player 11 (WMP11) Cannot Stream and Play MMS Media Protocol in Vista</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;打开控制面板，选择 &lt;code&gt;程序&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;/images/mms/01.jpg&quot; alt&gt;
    
    </summary>
    
      <category term="软件" scheme="http://blog.zhangjikai.com/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="IPV6" scheme="http://blog.zhangjikai.com/tags/IPV6/"/>
    
  </entry>
  
  <entry>
    <title>【Pthreads】Pipeline Model(Assembly Line)示例</title>
    <link href="http://blog.zhangjikai.com/2016/04/26/%E3%80%90Pthreads%E3%80%91Pipeline-Model-Assembly-Line-%E7%A4%BA%E4%BE%8B/"/>
    <id>http://blog.zhangjikai.com/2016/04/26/【Pthreads】Pipeline-Model-Assembly-Line-示例/</id>
    <published>2016-04-26T12:32:53.000Z</published>
    <updated>2019-09-08T06:53:07.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Pthreads 有几种工作模型，例如 Boss/Workder Model、Pileline Model(Assembly Line)、Background Task Model、Interface/Implementation Model，详细介绍可以参考 <a href="http://homes.di.unimi.it/~boccignone/GiuseppeBoccignone_webpage/MatDidatSOD2009_files/pthread-Tutorial.pdf" target="_blank" rel="noopener">pthread Tutorial</a>，这里给出一个流水线模型(Pipeline Model)的简单示例。在该示例中，主线程开启了两个子线程，一个子线程用来读取文件，一个子线程用于将结果写入文件，而主线程自身用来计算。<br><a id="more"></a></p><h2 id="模型说明"><a href="#模型说明" class="headerlink" title="模型说明"></a>模型说明</h2><p>很多时候，一个程序可以分为几个阶段，比如说读取数据、计算、将结果写入文件，当然我们可以使用每个线程依次执行这些操作，但是一个更好的选择是一个线程处理一个阶段，因为对于文件操作来说，硬盘的读写速率是一定的(IO很多时候会成为性能的瓶颈)，即使多个线程读取文件，其读写速率也不会变快(IO操作无法使用线程并行)。所以我们可以用一个线程来处理IO，另外的线程全部用于计算上，如果计算量较大，IO的耗时是可以掩盖过去的。比如读取一个 2G 的文件，然后进行计算。使用流水线模型，我们可以这样做，用一个线程专门读取文件，我们将其成为IO线程。IO线程一次读取 50M 数据，之后交给计算线程来处理这些数据，在计算线程处理数据的同时，IO线程再去读文件，假设处理 50M 数据的时间大于读取50M数据的时间， 当计算线程处理完上一份数据之后，要处理的下一份数据读取完毕，那么计算线程又可以紧接着处理这部分数据，这样循环操作，除了第一次读取数据的时候计算线程处于空闲状态，其余读取的时候计算线程都在进行计算，这样就掩盖掉了IO的时间</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>主线程在程序开始时创建两个子线程，一个用于读，一个用于写，读线程每次只读取一部分文件内容，写线程将这部分数据处理完之后的结果写入文件。创建完线程之后，主线程和写线程就处于等待状态，而读线程就开始读取文件，当读线程读取完第一部分数据之后，读线程进入阻塞状态，主线程开始计算，主线程计算完毕后，写线程开始写入计算结果，同时读线程开始下一部分数据的读取。按照这个流程循环取算存，直到程序结束。</p><h3 id="线程等待和唤醒"><a href="#线程等待和唤醒" class="headerlink" title="线程等待和唤醒"></a>线程等待和唤醒</h3><p>在执行中，3个线程都会进行等待操作，并且处理完自己的任务之后，还要再次进入等待状态。这里使用条件变量来控制线程的挂起和唤醒，使用while循环控制线程的状态的多次切换。下面是示例代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;read_lock);</span><br><span class="line">    <span class="keyword">while</span>(read_count == <span class="number">0</span> ) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;read_cond, &amp;read_lock);</span><br><span class="line">    &#125;</span><br><span class="line">    read_count--;</span><br><span class="line">    pthread_mutex_unlock(&amp;read_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码中，while循环会一直执行，所以我们还要加一个是否可以跳出 while 循环的判断，以便在任务结束后可以终止线程, 如下面的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;read_lock);</span><br><span class="line">    <span class="keyword">while</span>(read_count == <span class="number">0</span> &amp;&amp; !read_shutdown ) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;read_cond, &amp;read_lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(read_shutdown) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read_flag =  <span class="number">1</span> - read_flag;      </span><br><span class="line">    pthread_mutex_unlock(&amp;read_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们看到在判断线程是否挂起的 while 循环中也加入了<code>!read_shutdown</code>的判断，即如果马上就要跳出while循环，标明线程已经执行完了它的任务，则无需再进行挂起操作。唤醒该线程的代码如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;read_lock);</span><br><span class="line"><span class="keyword">if</span>(loop_index == loop_nums - <span class="number">1</span>) &#123;</span><br><span class="line">    read_shutdown = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">read_count = <span class="number">1</span>;</span><br><span class="line">pthread_cond_signal(&amp;read_cond);</span><br><span class="line">pthread_mutex_unlock(&amp;read_lock);</span><br></pre></td></tr></table></figure></p><p>下面分析一下条件变量，首先读线程和写线程都要对应一个条件变量，暂称为 <code>read_cond</code> 和 <code>write_cond</code>, 主线程用<code>read_cond</code>来告诉读线程自己已经开始计算，读线程可以继续读取下一部分数据了，用<code>write_cond</code>告诉写线程，计算已经完毕，可以将结果写入文件了 。而主线程需要两个条件变量，暂称为 <code>cal_cond</code> 和 <code>cal_cond2</code> , 读线程使用 <code>cal_cond</code> 告诉主线程自己已经读完这部分数据了，主线程可以开始计算了。而写线程用 <code>cal_cond2</code> 告诉主线程自己已经写完了上次计算结果，可以再次分配写入的任务了。如果读线程没有读完或者写线程没有写完，主线程都要进入等待状态。</p><p>我们知道每个条件变量都会对应一个条件以及一个互斥锁，下面分析一下各个条件的初始值，程序开始时读线程开始工作，主线程要等待读线程读完才能进行计算，所以 <code>read_cond</code> 对应的条件为 true， <code>cal_cond</code> 对应的条件的为 false，写线程必须要等待主线程计算完才可以写，并且在第一次的时候写线程肯定是空闲的， 所以 <code>write_cond</code> 对应的条件为 false，<code>cal_cond2</code> 对应的的条件为 ture。</p><h3 id="数据缓冲区"><a href="#数据缓冲区" class="headerlink" title="数据缓冲区"></a>数据缓冲区</h3><p>当读线程读完数据，将数据存到一个缓冲区中(比如一个数组)，主线程开始计算，此时读线程又去进行读取操作。如果读线程还是将数据读到上一次读取的缓冲区中（这个缓冲区此时正在被主线程使用），那么就会出现数据竞争。为了解决这个情况，我们可以使用两个缓冲区，读线程填满一个之后再去填另外一个，使用一个变量判断当前该使用哪个缓冲区，即如下面的形式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> read_buffer_a[BUFFER_SIZE], read_buffer_b[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">int</span> read_flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(read_flag) &#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; BUFFER_SIZE; i++) &#123;</span><br><span class="line">        <span class="built_in">fscanf</span>(read_arg-&gt;fp, <span class="string">"%d"</span>, read_buffer_a+i);</span><br><span class="line">    &#125;          </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; BUFFER_SIZE; i++) &#123;</span><br><span class="line">        <span class="built_in">fscanf</span>(read_arg-&gt;fp, <span class="string">"%d"</span>, read_buffer_b + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">read_flag = <span class="number">1</span> -read_flag;</span><br></pre></td></tr></table></figure></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>下面是完整的代码, <a href="https://github.com/zhangjikai/Pthreads-Pipeline-Demo" target="_blank" rel="noopener">这里</a>是github地址，可以下载下来运行一下。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"><span class="keyword">uint32_t</span> microseconds = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">thread_info</span>&#123;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">    <span class="keyword">int</span> run_flag;</span><br><span class="line">    <span class="keyword">int</span> buffer_flag;</span><br><span class="line">    <span class="keyword">int</span> shutdown;</span><br><span class="line">&#125; thread_info;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数参数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">thread_arg</span> &#123;</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">&#125; thread_arg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread_info input_info, output_info, cal_input_info, cal_output_info;</span><br><span class="line"><span class="keyword">int</span> read_buffer_a[BUFFER_SIZE], read_buffer_b[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">int</span> write_buffer_a[BUFFER_SIZE], write_buffer_b[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_resources</span><span class="params">(<span class="keyword">int</span> n, ...)</span> </span>&#123;</span><br><span class="line">    va_list arg_ptr ;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    va_start(arg_ptr, n);</span><br><span class="line">    thread_info * tmp_info = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">       tmp_info = va_arg(arg_ptr, thread_info *);</span><br><span class="line">       pthread_mutex_init(&amp;(tmp_info-&gt;lock), <span class="literal">NULL</span>);</span><br><span class="line">       pthread_cond_init(&amp;(tmp_info-&gt;cond), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    va_end(arg_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_resources</span><span class="params">(<span class="keyword">int</span> n, ...)</span> </span>&#123;</span><br><span class="line">    va_list arg_ptr;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    va_start(arg_ptr, n);</span><br><span class="line">    thread_info * tmp_info = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        tmp_info = va_arg(arg_ptr, thread_info *);</span><br><span class="line">        pthread_mutex_destroy(&amp;(tmp_info-&gt;lock));</span><br><span class="line">        pthread_cond_destroy(&amp;(tmp_info-&gt;cond));</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(arg_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">input_task</span><span class="params">(<span class="keyword">void</span> * args)</span></span>&#123;</span><br><span class="line">    thread_arg * input_arg = (thread_arg *) args;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;(input_info.lock));</span><br><span class="line">        <span class="keyword">while</span>(input_info.run_flag == <span class="number">0</span> &amp;&amp; !input_info.shutdown) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;(input_info.cond), &amp;(input_info.lock));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(input_info.shutdown) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        input_info.run_flag = <span class="number">0</span>;</span><br><span class="line">        input_info.buffer_flag = <span class="number">1</span> - input_info.buffer_flag;</span><br><span class="line">        pthread_mutex_unlock(&amp;(input_info.lock));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(input_info.buffer_flag) &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; BUFFER_SIZE; i++) &#123;</span><br><span class="line">                <span class="built_in">fscanf</span>(input_arg-&gt;fp, <span class="string">"%d"</span>, read_buffer_a + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; BUFFER_SIZE; i++) &#123;</span><br><span class="line">                <span class="built_in">fscanf</span>(input_arg-&gt;fp, <span class="string">"%d"</span>, read_buffer_b + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;(cal_input_info.lock));</span><br><span class="line">        cal_input_info.run_flag = <span class="number">1</span>;</span><br><span class="line">        pthread_cond_signal(&amp;(cal_input_info.cond));</span><br><span class="line">        pthread_mutex_unlock(&amp;(cal_input_info.lock));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">output_task</span><span class="params">(<span class="keyword">void</span> * args)</span></span>&#123;</span><br><span class="line">    thread_arg * output_arg = (thread_arg *) args;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;(output_info.lock));</span><br><span class="line">        <span class="keyword">while</span>(output_info.run_flag == <span class="number">0</span> &amp;&amp; !output_info.shutdown) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;(output_info.cond), &amp;(output_info.lock));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(output_info.shutdown) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output_info.run_flag = <span class="number">0</span>;</span><br><span class="line">        output_info.buffer_flag = <span class="number">1</span> - output_info.buffer_flag;</span><br><span class="line">        pthread_mutex_unlock(&amp;(output_info.lock));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(output_info.buffer_flag) &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; BUFFER_SIZE; i++) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(output_arg-&gt;fp, <span class="string">"%d\n"</span>, write_buffer_a[i]);</span><br><span class="line">                usleep(microseconds);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; BUFFER_SIZE; i++) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(output_arg-&gt;fp, <span class="string">"%d\n"</span>, write_buffer_b[i]);</span><br><span class="line">                usleep(microseconds);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;(cal_output_info.lock));</span><br><span class="line">        cal_output_info.run_flag = <span class="number">1</span>;</span><br><span class="line">        pthread_cond_signal(&amp;(cal_output_info.cond));</span><br><span class="line">        pthread_mutex_unlock(&amp;(cal_output_info.lock));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fp_input, *fp_output;</span><br><span class="line">    <span class="keyword">char</span> *input_name = <span class="string">"input.txt"</span>;</span><br><span class="line">    <span class="keyword">char</span> *output_name = <span class="string">"output.txt"</span>;</span><br><span class="line">    <span class="keyword">int</span> total_nums = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> loop_nums = total_nums / BUFFER_SIZE;</span><br><span class="line">    <span class="keyword">int</span> loop_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    thread_arg input_arg, output_arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fp_input = fopen(input_name, <span class="string">"r"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can't load input file\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fp_output = fopen(output_name, <span class="string">"w+"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can't load output file\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input_arg.fp = fp_input;</span><br><span class="line">    output_arg.fp = fp_output;</span><br><span class="line"></span><br><span class="line">    init_resources(<span class="number">4</span>, &amp;input_info, &amp;output_info, &amp;cal_input_info, &amp;cal_output_info);</span><br><span class="line">    input_info.buffer_flag = output_info.buffer_flag = cal_input_info.buffer_flag = <span class="number">0</span>;</span><br><span class="line">    input_info.run_flag = cal_output_info.run_flag = <span class="number">1</span>;</span><br><span class="line">    output_info.run_flag = cal_input_info.run_flag = <span class="number">0</span>;</span><br><span class="line">    input_info.shutdown = output_info.shutdown = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;(input_info.thread_id), <span class="literal">NULL</span>, input_task, &amp;input_arg);</span><br><span class="line">    pthread_create(&amp;(output_info.thread_id), <span class="literal">NULL</span>, output_task, &amp;output_arg);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;(cal_input_info.lock));</span><br><span class="line">        <span class="keyword">while</span>(cal_input_info.run_flag == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;(cal_input_info.cond), &amp;(cal_input_info.lock));</span><br><span class="line">        &#125;</span><br><span class="line">        cal_input_info.buffer_flag = <span class="number">1</span> - cal_input_info.buffer_flag;</span><br><span class="line">        cal_input_info.run_flag = <span class="number">0</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;(cal_input_info.lock));</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;(input_info.lock));</span><br><span class="line">        <span class="keyword">if</span>(loop_index == loop_nums - <span class="number">1</span>) &#123;</span><br><span class="line">            input_info.shutdown = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        input_info.run_flag = <span class="number">1</span>;</span><br><span class="line">        pthread_cond_signal(&amp;(input_info.cond));</span><br><span class="line">        pthread_mutex_unlock(&amp;(input_info.lock));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里可以使用OpenMp</span></span><br><span class="line">        <span class="keyword">if</span>(cal_input_info.buffer_flag) &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; BUFFER_SIZE; i++) &#123;</span><br><span class="line">                write_buffer_a[i] = read_buffer_a[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; BUFFER_SIZE; i++) &#123;</span><br><span class="line">                write_buffer_b[i] = read_buffer_b[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_lock(&amp;(cal_output_info.lock));</span><br><span class="line">        <span class="keyword">while</span>(cal_output_info.run_flag == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;(cal_output_info.cond), &amp;(cal_output_info.lock));</span><br><span class="line">        &#125;</span><br><span class="line">        cal_output_info.run_flag = <span class="number">0</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;(cal_output_info.lock));</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_lock(&amp;(output_info.lock));</span><br><span class="line">        output_info.run_flag = <span class="number">1</span>;</span><br><span class="line">        pthread_cond_signal(&amp;(output_info.cond));</span><br><span class="line">        pthread_mutex_unlock(&amp;(output_info.lock));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(loop_index == loop_nums - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        loop_index++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_lock(&amp;(cal_output_info.lock));</span><br><span class="line">    <span class="keyword">while</span>(cal_output_info.run_flag == <span class="number">0</span>) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;(cal_output_info.cond), &amp;(cal_output_info.lock));</span><br><span class="line">    &#125;</span><br><span class="line">    cal_output_info.run_flag = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;(cal_output_info.lock));</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;(output_info.lock));</span><br><span class="line">    output_info.run_flag = <span class="number">1</span>;</span><br><span class="line">    output_info.shutdown = <span class="number">1</span>;</span><br><span class="line">    pthread_cond_signal(&amp;(output_info.cond));</span><br><span class="line">    pthread_mutex_unlock(&amp;(output_info.lock));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pthread_join(input_info.thread_id, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(output_info.thread_id, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    free_resources(<span class="number">4</span>, &amp;input_info, &amp;output_info, &amp;cal_input_info, &amp;cal_output_info);</span><br><span class="line">    fclose(fp_input);</span><br><span class="line">    fclose(fp_output);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文主要参考了这个<a href="https://github.com/mbrossard/threadpool" target="_blank" rel="noopener">Pthreads线程池</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Pthreads 有几种工作模型，例如 Boss/Workder Model、Pileline Model(Assembly Line)、Background Task Model、Interface/Implementation Model，详细介绍可以参考 &lt;a href=&quot;http://homes.di.unimi.it/~boccignone/GiuseppeBoccignone_webpage/MatDidatSOD2009_files/pthread-Tutorial.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pthread Tutorial&lt;/a&gt;，这里给出一个流水线模型(Pipeline Model)的简单示例。在该示例中，主线程开启了两个子线程，一个子线程用来读取文件，一个子线程用于将结果写入文件，而主线程自身用来计算。&lt;br&gt;
    
    </summary>
    
      <category term="Pthreads" scheme="http://blog.zhangjikai.com/categories/Pthreads/"/>
    
    
      <category term="Pthreads" scheme="http://blog.zhangjikai.com/tags/Pthreads/"/>
    
  </entry>
  
  <entry>
    <title>【Pthreads学习笔记】基本使用</title>
    <link href="http://blog.zhangjikai.com/2016/04/25/%E3%80%90Pthreads%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.zhangjikai.com/2016/04/25/【Pthreads学习笔记】基本使用/</id>
    <published>2016-04-25T01:47:41.000Z</published>
    <updated>2019-09-08T06:53:07.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>与OpenMP相比，Pthreads的使用相对要复杂一些，需要我们显式的创建、管理、销毁线程，但也正因为如此，我们对于线程有更强的控制，可以更加灵活的使用线程。这里主要记录一下Pthreads的基本使用方法，如果不是十分复杂的使用环境，这些知识应该可以了。本文大部分内容都是参考自<a href="http://homes.di.unimi.it/~boccignone/GiuseppeBoccignone_webpage/MatDidatSOD2009_files/pthread-Tutorial.pdf" target="_blank" rel="noopener">这里</a>，有兴趣的可以看一下原文。</p><a id="more"></a><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">hello</span><span class="params">(<span class="keyword">void</span> * args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span>  rank = (<span class="keyword">long</span>) args;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello form sub thread %ld\n"</span>, rank);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thread_num = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">long</span> thread_index;</span><br><span class="line">    <span class="keyword">pthread_t</span> * thread_handles;</span><br><span class="line"></span><br><span class="line">    thread_handles =(<span class="keyword">pthread_t</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span> ) * thread_num);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(thread_index = <span class="number">0</span>; thread_index &lt; thread_num; thread_index++) &#123;</span><br><span class="line">        pthread_create(&amp;thread_handles[thread_index], <span class="literal">NULL</span>, hello, (<span class="keyword">void</span> *)thread_index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello from main thread\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(thread_index = <span class="number">0</span>; thread_index &lt; thread_num; thread_index++) &#123;</span><br><span class="line">        pthread_join(thread_handles[thread_index], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(thread_handles);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译程序, 需要加上 ‘-lpthread’<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o helloworld helloworld.c -lpthread</span><br></pre></td></tr></table></figure></p><p>一种可能的输出结果<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello from main thread</span><br><span class="line">Hello form sub thread 2</span><br><span class="line">Hello form sub thread 3</span><br><span class="line">Hello form sub thread 1</span><br><span class="line">Hello form sub thread 0</span><br></pre></td></tr></table></figure></p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>Pthreads使用 <code>pthread_create</code> 函数来创建线程, 函数原型如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">( <span class="keyword">pthread_t</span> *               thread, </span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *    attr, </span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> *                    (*start_routine) (<span class="keyword">void</span> *), </span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> *                    arg</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></p><p>参数说明:<br><strong>thread</strong><br>　　<small>指向执行线程标识符的指针, 通过该变量来控制线程</small><br><strong>attr</strong><br>　　<small>设置线程属性, 如果为NULL, 则使用默认的属性</small><br><strong>start_routine</strong><br>　　<small>线程运行函数的起始地址</small><br><strong>arg</strong><br>　　<small>运行函数的参数, 这里使用 <code>void*</code>来作为参数类型, 以便可以向运行函数中传递任意类型的参数, 当然需要在运行函数中将参数转换为其原来的类型.</small><br><strong>返回值</strong><br>　　<small>如果创建线程成功会返回0, 否则返回错误码.</small>  </p><p>下面是一个使用示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thread_function</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * incoming = (<span class="keyword">int</span> *)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"this is in pthread and arg is %d\n"</span>, *incoming);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello_world</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id ;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">63</span>;</span><br><span class="line">    pthread_create(&amp;thread_id, <span class="literal">NULL</span>, thread_function, &amp;value);</span><br><span class="line">    <span class="comment">// 等待线程执行完</span></span><br><span class="line">    pthread_join(thread_id, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的代码中, 在程序最后加上了 <code>pthread_join</code> 函数, 用来完成线程间的同步, 即主线程等待指定的线程(在上面的代码中是 thread_id 对应的线程)执行完再往下执行. 在下面会详细介绍该函数.</p><h2 id="Join-和-Detach"><a href="#Join-和-Detach" class="headerlink" title="Join 和 Detach"></a>Join 和 Detach</h2><h3 id="Join-合并"><a href="#Join-合并" class="headerlink" title="Join(合并)"></a>Join(合并)</h3><p><code>pthread_join</code> 可以用于线程之间的同步, 当一个线程对另一个线程调用了join操作之后, 该线程会处于阻塞状态, 直到另外一个线程执行完毕. 下面是一个示意图:<br><img src="/images/pthread/pthread_join.png" alt></p><p>下面是 <code>pthread_join</code>的函数原型:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">( <span class="keyword">pthread_t</span> thread, </span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span> **   retval</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></p><p>参数说明:<br><strong>thread</strong><br>　　<small>线程标识符, 用来指定等待哪个线程</small><br><strong>retaval</strong><br>　　<small>用来存储等待线程的返回值</small>  </p><p>下面是通过获取函数返回值的一个示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">p_result</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * m = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="number">3</span>);</span><br><span class="line">    m[<span class="number">0</span>] = <span class="string">'A'</span>;</span><br><span class="line">    m[<span class="number">1</span>] = <span class="string">'B'</span>;</span><br><span class="line">    m[<span class="number">2</span>] = <span class="string">'C'</span>;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_get_result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">void</span> * exit_status ;</span><br><span class="line">    pthread_create(&amp;thread_id, <span class="literal">NULL</span>, p_result, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(thread_id, &amp; exit_status);</span><br><span class="line">    <span class="keyword">char</span> * m = (<span class="keyword">char</span>* ) exit_status;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"m is %s\n"</span>, m);</span><br><span class="line">    <span class="built_in">free</span>(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 <code>p_result</code> 函数中为了使线程执行完, 我们还可以访问到变量 m 中的数据, m 的内存采用动态分配的方式, 如果静态分配, 即如 <code>char m[3]</code> 的形式, 那么在函数执行完就会清空 m 的值, 我们就无法获得想要的结果.</p><p>对于一个线程来说, 其终止方式有两种: 执行完线程函数或者自身调用 <code>pthread_exit(void *)</code>, 如果线程通过执行完线程函数而终止的, 那么其他线程通过<code>pthread_join</code>获得的线程返回值就是线程函数的返回值(如上面的例子), 如果线程是通过 <code>pthread_exit(void *)</code> 方式结束的线程, 其线程返回值就是 <code>pthread_exit</code> 传入的参数, 下面是一个示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">p_exit_result</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"print before pthread_exit\n"</span>);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span> *)<span class="number">10L</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"print after pthread_exit\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_exit_result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">void</span> * exit_status ;</span><br><span class="line">    pthread_create(&amp;thread_id, <span class="literal">NULL</span>, p_exit_result, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(thread_id, &amp; exit_status);</span><br><span class="line">    <span class="keyword">long</span> m = (<span class="keyword">long</span> ) exit_status;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"m is %ld\n"</span>, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是输出结果<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print before pthread_exit</span><br><span class="line">m is 10</span><br></pre></td></tr></table></figure></p><p>一般来说, 使用 Pthreads 创建的线程默认应该是可 join 的, 但是并不是所有实现都会这样, 所以必要情况下, 我们可以在创建线程时, 显式的指定线程是可 join 的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> thread_id;</span><br><span class="line"><span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">pthread_attr_init(&amp;attr);</span><br><span class="line">pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line">pthread_create(&amp;thread_id, &amp;attr, work, (<span class="keyword">void</span> *)arg);</span><br><span class="line">pthread_attr_destroy(&amp;attr);</span><br><span class="line">pthread_join(thread_id, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p><h3 id="Detach-分离"><a href="#Detach-分离" class="headerlink" title="Detach(分离)"></a>Detach(分离)</h3><p>对于可 join 的线程, 只有当其他线程对其调用了 <code>pthread_join</code> 之后, 该线程才会释放所占用的资源(例如线程所对应的标识符pthread_t, 线程的返回值信息), 如果想要系统回收线程的资源, 而不是通过调用<code>pthread_join</code>回收资源(会阻塞线程), 我们可以将线程设置为 <code>DETACHED (分离的)</code>, 有三种方式将线程设为 <code>detached</code>的</p><ul><li>创建线程时指定线程的 <code>detach</code> 属性: <code>pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</code></li><li>通过在子线程中调用 <code>pthread_detach(pthread_self());</code> </li><li>在主线程中调用 <code>pthread_detach(thread_id);</code>(非阻塞, 执行完会立即会返回), </li></ul><p>通过上面的方式将线程设为 <code>detached</code>, 线程运行结束后会自动释放所有资源.</p><h2 id="Mutex-互斥锁"><a href="#Mutex-互斥锁" class="headerlink" title="Mutex(互斥锁)"></a>Mutex(互斥锁)</h2><p>互斥锁用来保护共享变量, 它可以保证某个时间内只有一个线程访问共享变量, 下面是使用互斥锁的具体步骤</p><ul><li>声明 <code>pthread_mutex_t</code> (互斥锁类型) 类型的变量</li><li>调用 <code>pthread_mutex_init()</code> 来初始化变量</li><li>在访问共享变量之前, 调用 <code>pthread_mutex_lock()</code> 获得互斥锁, 如果互斥锁被其他线程占用, 该线程会处于等待状态</li><li>访问完共享变量之后, 调用 <code>pthread_mutex_unlock()</code> 释放互斥锁, 以便其他线程使用</li><li>程序执行完后调用 <code>pthread_mutex_destroy()</code>释放资源.</li></ul><p>创建互斥锁有两种方式: 静态方式和动态方式. 静态方式是使用宏 <code>PTHREAD_MUTEX_INITIALIZER</code> 来初始化锁, 如下所示:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure></p><p>动态方式是调用 <code>pthread_mutex_init</code> 函数动态初始锁, 下面是该函数原型<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> * attr)</span></span></span><br></pre></td></tr></table></figure></p><p>下面是使用互斥锁的一个示例(使用动态方式):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line"><span class="keyword">int</span> share_data;</span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">p_lock</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span>; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        share_data++;</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">void</span> *exit_status;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;thread_id, <span class="literal">NULL</span>, p_lock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//sleep(1);</span></span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Shared integer's value = %d\n"</span>, share_data);</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    pthread_join(thread_id, &amp; exit_status);</span><br><span class="line">    pthread_mutex_destroy(&amp;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下是使用互斥量的几个注意点:</p><ul><li>使用 lock 和 unlock 一个互斥锁时, 一定要先初始化该互斥锁</li><li>释放互斥锁的线程必须是获得互斥锁的那个线程</li><li>当 destroy 互斥锁的时候, 不该有线程还在使用这个互斥锁</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>在动态创建互斥锁时, 我们可以传入一个锁属性变量 <code>pthread_mutexattr_t</code> 来初始化锁的属性, 通过下面两个函数来初始化和销毁该属性对象<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_destroy</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure></p><p>然后可以调用下面的方法对属性进行设置</p><p><strong>范围</strong><br>可以指定互斥锁是进程之间的同步还是进程内的同步, 下面是对应的两个锁的范围(scope)</p><ul><li><code>PTHREAD_PROCESS_SHARE</code>: 进程间同步</li><li><code>PTHREAD_PROCESS_PRIVATE</code>: 进程内同步, 默认值</li></ul><p>通过调用下面的函数可以设置和获取锁的范围<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_setpshared</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure></p><p><strong>类型</strong><br>互斥锁的类型有以下几种取值方式(为了兼容性, 一个类型可能有多个名称):</p><ul><li><strong><code>PTHREAD_MUTEX_TIMED_NP / PTHREAD_MUTEX_NORMAL /  PTHREAD_MUTEX_DEFAULT</code></strong> : 缺省值, 也就是普通锁. 当一个线程获得锁之后, 其余请求锁的线程将形成一个等待队列, 并在加锁线程解锁后按照优先级获得锁. 这种策略保证了资源分配的公正性.</li><li><strong><code>PTHREAD_MUTEX_RECURSIVE_NP /  PTHREAD_MUTEX_RECURSIVE</code></strong> : 嵌套锁, 允许一个线程对同一个锁成功获得多次, 并通过多次 unlock 来解锁. 如果是不同线程请求, 则在加锁线程解锁后重新竞争.</li><li><strong><code>PTHREAD_MUTEX_ERRORCHECK_NP / PTHREAD_MUTEX_ERRORCHECK</code></strong>: 如果同一个线程请求同一个锁，则返回<code>EDEADLK</code>，否则与<code>PTHREAD_MUTEX_TIMED_NP</code>类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁</li><li><strong><code>PTHREAD_MUTEX_ADAPTIVE_NP</code></strong>: 适应锁，动作最简单的锁类型，仅等待解锁后重新竞争</li></ul><p>可以使用下面的函数获取和设置锁的类型<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_gettype</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> *type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_settype</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure></p><h2 id="Condition-Variables-条件变量"><a href="#Condition-Variables-条件变量" class="headerlink" title="Condition Variables(条件变量)"></a>Condition Variables(条件变量)</h2><p>条件变量对应的数据类型为 <code>pthread_cond_t</code>, 通过使用条件变量, 可以使线程在某个 <strong>特定条件</strong> 或者 <strong>事件</strong> 发生之前处于挂起状态. 当事件或者条件发生之后, 另一个线程可以通过信号来唤起挂起的线程. 条件变量主要使用下面几个函数</p><p><strong>初始化(init)</strong><br>和互斥锁一样, 条件变量也有两种初始化方式: 静态方式和动态方式<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER; </span><br><span class="line"><span class="comment">// 动态, 成功返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br></pre></td></tr></table></figure></p><p><strong>销毁(destroy)</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure></p><p><strong>等待函数(wait)</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">( <span class="keyword">pthread_cond_t</span> *   <span class="keyword">restrict</span> cond, </span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">pthread_mutex_t</span> *  <span class="keyword">restrict</span> mutex )</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">( <span class="keyword">pthread_cond_t</span> *         <span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">pthread_mutex_t</span> *        <span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> struct timespec *  <span class="keyword">restrict</span> abstime )</span></span>;</span><br></pre></td></tr></table></figure></p><p>通过调用 wait 函数, 线程会处于挂起状态. 其中 <code>pthread_cond_timedwait</code> 的含义为: 如果在 <code>abstime</code> 时间内(系统时间小于abstime), 线程没有被唤醒, 那么线程就会结束等待, 同时返回 <code>ETIMEDOUT</code> 错误.</p><p><strong>唤醒函数(signal)</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure></p><p>singal 函数一次只能唤醒一个线程, 而 broadcast 会唤醒所有在当前条件变量下等待的线程. </p><p>下面是条件变量的具体使用, 首先一个线程会根据条件来确实是否需要处于挂起状态, 即如下面的形式<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">    pthread_cond_wait(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果flag不为0, 那么线程就不进入等待状态, 否则就挂起线程, 等待flag不为0(满足条件了, 可以往下执行)时被唤醒. 唤醒该线程的代码如下所示:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">pthread_cond_signal(...);</span><br></pre></td></tr></table></figure></p><p>下面考虑一下这种情况, 首先 <code>flag = 0</code>, 当线程1执行到 <code>if(flag == 0)</code> 时, 发现不满足继续往下执行的条件, 即将进入挂起状态, 就在其刚要挂起的时候(还没挂起), 线程2执行了唤醒线程1的代码(修改flag的值, 唤醒线程1), 假设线程2执行完上述操作之后, 线程1仍然还没有挂起, 所以 <code>pthread_cond_signal</code> 并没有起到作用. 此后线程1终于进入了挂起状态, 等待线程2的唤醒, 而线程2则认为它已经唤醒了线程1, 让其往下执行了. 此时问题就来了, 如果线程2不再执行唤醒线程1的操作, 那么线程1就会永远处于挂起状态. 为了解决这种情况, 需要满足从判断 <code>flag==0</code> 到 <code>pthread_cond_wait()</code> 执行,  <code>flag</code> 的值不能发生变化,并且不能提前执行唤醒操作. 为了实现这种需求, 我们需要加一个锁操作,<br>等待代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">    pthread_cond_wait(...);</span><br><span class="line">&#125; </span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure></p><p>唤醒代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">pthread_cond_signal(&amp;condition);</span><br></pre></td></tr></table></figure></p><p>我们看到 <code>pthread_cond_wait</code> 的函数原型中第一个参数为条件变量, 第二个参数为互斥锁, 之所以需要传入互斥锁, 是因为如果不传入互斥锁, 当线程进入挂起状态时, 就无法释放掉该互斥锁, 而其他线程就无法获得该互斥锁,就没办法更新<code>flag</code>的值, 也无法唤醒线程1. 线程1就会永远处于挂起状态, 线程2就会永远处于请求互斥锁的状态. 所以当线程1进入挂起状态时需要释放掉互斥锁, 被唤醒之后再重新获得互斥锁, 即 <code>pthread_cond_wait</code> 可以看成下面的操作:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">wait_on_signal(&amp;condition);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br></pre></td></tr></table></figure></p><p>所有一个条件变量总是和一个互斥锁关联.<br>下面再来看一下等待代码, 在某些特定情况下, 即使没有线程调用 <code>pthread_cond_signal</code>函数, ‘pthread_cond_wait’ 函数也有可能返回(具体解释可以看看<a href="https://en.wikipedia.org/wiki/Spurious_wakeup" target="_blank" rel="noopener"> spurious wakeup</a>), 但是此时条件并不满足, 如果程序往下执行, 那么就可能会出错. 所以为了避免这种情况, 即使线程被唤醒了, 也应该再检查一下条件是否满足, 即使用 while 循环代替 if 判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">while</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">    pthread_cond_wait(...);</span><br><span class="line">&#125; </span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure><p>下面是一个使用示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_cond_t</span> is_zero;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="keyword">int</span> con_share_data = <span class="number">32767</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">p_condition</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(con_share_data &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        con_share_data--;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cond_signal(&amp;is_zero);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_condition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">void</span> *exit_status;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    pthread_cond_init(&amp;is_zero, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;thread_id, <span class="literal">NULL</span>, p_condition, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span>(con_share_data != <span class="number">0</span>) &#123;</span><br><span class="line">        pthread_cond_wait(&amp; is_zero, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    pthread_join(thread_id, &amp;exit_status);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;is_zero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Semaphores-信号量"><a href="#Semaphores-信号量" class="headerlink" title="Semaphores(信号量)"></a>Semaphores(信号量)</h2><p>信号量本质上可以看做是一个计数器, 它主要有两种操作, 第一类操作为 down 或者 wait – <code>sem_wait(...)</code>, 目的是为了减小计数器(将信号俩减1), 另一类为 up 或者 signal – <code>sem_post(...)</code> , 目的是为了增大计数器(将信号量加1). 当线程调用 <code>sem_wait()</code> 时, 如果信号量的值大于0, 那么只会把信号量减1, 线程会继续往下执行. 如果信号量的值为0, 那么线程就会进入阻塞状态, 直到另外一个线程执行了 <code>sem_post()</code> 操作, 对信号量进行了增操作, 该线程才会继续往下执行.</p><p>信号量主要用于对一些稀缺资源的同步, 什么叫做稀缺资源, 就是说这个资源只有有限的几个, 但是又多于一个, 在某一个时刻, 可以供有限的几个线程使用, 但又不是全部线程使用. 如果将信号量初始化为1, 那么该信号量就等同于互斥锁了, 因此一次只能有一个线程获得信号量的资源, 如果其他线程想要获得, 必须等该线程对信号量进行增操作. 举个例子说: 有10个人去银行办理业务, 但是银行只有4个窗口(信号量初始化为4), 所以前4个人到了银行就可以办理业务, 但是第5个人之后就必须要等待, 等前面的某个人办理完业务(增加信号量), 空出窗口来. 而当第5个人去办理业务时, 空出的窗口又被占用了(减小信号量), 剩下的人还是要等待. 信号量在执行过程中和上述例子不同的一点是, 当有空余的资源出现时, 线程并不一定按照 FIFO(先进先出) 的顺序来获取资源, 而有可能是随机一个线程获得资源. </p><p>下面是信号量相关的函数<br><strong>类型</strong><br>信号量的类型是 <code>sem_t</code>, 需要引入头文件 <code>#include &lt;semaphore.h&gt;</code></p><p><strong>初始化和销毁</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure></p><p>init 函数的第二个参数用来标识信号量的范围: 0 表示一个进程中线程间共享, 非0 表示进程间共享. 第三个参数就是信号量的可用数量.</p><p><strong>wait和signal</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure></p><p>下面是一个使用示例<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sem_share_data = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// use like a mutex</span></span><br><span class="line"><span class="keyword">sem_t</span> binary_sem; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">p_sem</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    sem_wait(&amp;binary_sem);     <span class="comment">// 减少信号量</span></span><br><span class="line">    <span class="comment">// 在这里使用共享数据; </span></span><br><span class="line">    sem_post(&amp;binary_sem);     <span class="comment">// 增加信号量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_sem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sem_init(&amp;binary_sem, <span class="number">0</span>, <span class="number">1</span>);   <span class="comment">// 信号量初始化为1, 当初互斥锁使用</span></span><br><span class="line">    <span class="comment">// 在这里创建线程</span></span><br><span class="line">    sem_wait(&amp;binary_sem);</span><br><span class="line">    <span class="comment">// 在这里使用共享变量</span></span><br><span class="line">    sem_post(&amp;binary_sem);</span><br><span class="line">    <span class="comment">// 在这里join线程</span></span><br><span class="line">    sem_destroy(&amp;binary_sem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Reader-Writer-Locks-读写锁"><a href="#Reader-Writer-Locks-读写锁" class="headerlink" title="Reader/Writer Locks 读写锁"></a>Reader/Writer Locks 读写锁</h2><p>对于读写锁来说, 多个线程可以同时获得读锁, 但某一个时间内, 只有一个线程可以获得写锁. 如果已经有线程获得了<strong>读锁</strong>, 则任何请求<strong>写锁</strong>的线程将被阻塞在写锁函数的调用上, 同时如果线程已经获得了<strong>写锁</strong>, 那么任何请求<strong>读锁</strong>或者<strong>写锁</strong> 的线程都会被阻塞. 下面是读写锁的基本函数:</p><p><strong>锁类型</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_rwlock_t</span></span><br></pre></td></tr></table></figure></p><p><strong>初始化/销毁</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure></p><p><strong>读锁</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure></p><p><strong>写锁</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure></p><p><strong>释放锁</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure></p><p>下面是一个使用示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_rwlock_t</span> rw_lock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">p_rwlock</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    pthread_rwlock_rdlock(&amp;rw_lock);</span><br><span class="line">    <span class="comment">// 读取共享变量</span></span><br><span class="line">    pthread_rwlock_unlock(&amp;rw_lock);</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">test_rwlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pthread_rwlock_init(&amp;rw_lock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    pthread_rwlock_wrlock(&amp;rw_lock);</span><br><span class="line">    <span class="comment">// 修改共享变量</span></span><br><span class="line">    pthread_rwlock_unlock(&amp;rw_lock);</span><br><span class="line">    <span class="comment">// join线程</span></span><br><span class="line">    pthread_rwlock_destroy(&amp;rw_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://homes.di.unimi.it/~boccignone/GiuseppeBoccignone_webpage/MatDidatSOD2009_files/pthread-Tutorial.pdf" target="_blank" rel="noopener">pthread Tutoriaed Tutorial</a><br><a href="https://computing.llnl.gov/tutorials/pthreads/#PassingArguments" target="_blank" rel="noopener">POSIX Threads Programming</a><br><a href="http://blog.csdn.net/jw903/article/details/31738877" target="_blank" rel="noopener">Linux线程-互斥锁pthread_mutex_t</a><br><a href="http://www.cnblogs.com/mywolrd/archive/2009/02/05/1930707.html#topic_not_covered" target="_blank" rel="noopener">Pthread：POSIX 多线程程序设计</a></p><p>下面列出一些学习资料，如果想深入学习Pthreads可以看下这些资料(摘自<a href="http://www.cnblogs.com/mywolrd/archive/2009/02/05/1930707.html#topic_not_covered" target="_blank" rel="noopener">POSIX 多线程程序设计</a>)：<br><a href="http://download.csdn.net/detail/future_fighter/992248" target="_blank" rel="noopener">Pthreads多线程编程指南</a><br><a href="http://download.csdn.net/detail/future_fighter/992239" target="_blank" rel="noopener">Programing with POSIX thread</a><br><a href="http://download.csdn.net/detail/future_fighter/992213" target="_blank" rel="noopener">Pthread Primer</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;与OpenMP相比，Pthreads的使用相对要复杂一些，需要我们显式的创建、管理、销毁线程，但也正因为如此，我们对于线程有更强的控制，可以更加灵活的使用线程。这里主要记录一下Pthreads的基本使用方法，如果不是十分复杂的使用环境，这些知识应该可以了。本文大部分内容都是参考自&lt;a href=&quot;http://homes.di.unimi.it/~boccignone/GiuseppeBoccignone_webpage/MatDidatSOD2009_files/pthread-Tutorial.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;，有兴趣的可以看一下原文。&lt;/p&gt;
    
    </summary>
    
      <category term="Pthreads" scheme="http://blog.zhangjikai.com/categories/Pthreads/"/>
    
    
      <category term="学习笔记" scheme="http://blog.zhangjikai.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Pthreads" scheme="http://blog.zhangjikai.com/tags/Pthreads/"/>
    
  </entry>
  
  <entry>
    <title>【C】解析命令行参数--getopt和getopt_long</title>
    <link href="http://blog.zhangjikai.com/2016/03/05/%E3%80%90C%E3%80%91%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0--getopt%E5%92%8Cgetopt_long/"/>
    <id>http://blog.zhangjikai.com/2016/03/05/【C】解析命令行参数--getopt和getopt_long/</id>
    <published>2016-03-05T08:42:12.000Z</published>
    <updated>2019-09-08T06:53:07.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在程序中一般都会用到命令行选项, 我们可以使用getopt 和getopt_long函数来解析命令行参数</p><h2 id="getopt"><a href="#getopt" class="headerlink" title="getopt"></a>getopt</h2><p>getopt主要用来处理短命令行选项, 例如<code>./test -v</code>中<code>-v</code>就是一个短选项. 使用该函数需要引入头文件<code>&lt;unistd.h&gt;</code>, 下面是该函数的定义<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[], <span class="keyword">const</span> <span class="keyword">char</span> * optstring)</span></span>;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>其中 argc 和 argv 是main函数中的传递的参数个数和内容, optstring用来指定可以处理哪些选项, 下面是optstring的一个示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"a:bc"</span></span><br></pre></td></tr></table></figure></p><p>该示例表明程序可以接受3个选项: <code>-a -b -c</code>, 其中 <code>a</code> 后面的 <code>:</code>表示该选项后面要跟一个参数, 即如 <code>-a text</code>的形式, 选项后面跟的参数会被保存到 optarg 变量中. 下面是一个使用示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch = getopt(argc, argv, <span class="string">"a:b"</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"option a: %s\n"</span>, optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'b'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"option b \n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'?'</span>: <span class="comment">// 输入未定义的选项, 都会将该选项的值变为 ?</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"unknown option \n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"default \n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行 <code>./test -a aa -b -c</code> 输出结果如下:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">option a: aa</span><br><span class="line">option b </span><br><span class="line">unknown option</span><br></pre></td></tr></table></figure></p><h2 id="getopt-long"><a href="#getopt-long" class="headerlink" title="getopt_long"></a>getopt_long</h2><p>getopt_long支持长选项的命令行解析, 所为长选项就是诸如<code>--help</code>的形式, 使用该函数, 需要引入<code>&lt;getopt.h&gt;</code>下面是函数原型:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt_long</span><span class="params">(<span class="keyword">int</span> argc, </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">char</span> * <span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">char</span> *optstring,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> struct option *longopts,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> *longindex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt_long_only</span><span class="params">(<span class="keyword">int</span> argc,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">char</span> * <span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">char</span> *optstring,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> struct option *longopts,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> *longindex)</span></span>;</span><br></pre></td></tr></table></figure></p><p>其中 <strong>argc</strong> , <strong>argv</strong> , <strong>optstring</strong> 和<strong>getopt</strong>中的含义一样, 下面解释一下<strong>longopts</strong> 和<strong>longindex</strong></p><p><strong>longopts</strong>  </p><p>longopts 指向一个struct option 的数组, 下面是option的定义:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">option</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span>         has_arg;</span><br><span class="line">    <span class="keyword">int</span>        *flag;</span><br><span class="line">    <span class="keyword">int</span>         val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>下面是各字段的含义</p><ul><li><strong>name</strong> - 长选项的名称, 例如 <code>help</code></li><li><strong>has_arg</strong> - 是否带参数, 0 不带参数, 1 必须带参数, 2 参数可选</li><li><strong>flag</strong> - 指定长选项如何返回结果, 如果flag为NULL, <strong>getopt_long</strong>() 会返回val. 如果flag不为NULL, <strong>getopt_long</strong>会返回0, 并且将val的值存储到flag中</li><li><strong>val</strong> - 将要被<strong>getopt_long</strong>返回或者存储到flag指向的变量中的值</li></ul><p>下面是<strong>longopts</strong>的一个示例<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">opts</span>[] = &#123;</span></span><br><span class="line">       &#123;<span class="string">"version"</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="string">'v'</span>&#125;,</span><br><span class="line">       &#123;<span class="string">"name"</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">'n'</span>&#125;,</span><br><span class="line">       &#123;<span class="string">"help"</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="string">'h'</span>&#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure></p><p>我们来看<code>{&quot;version&quot;, 0, NULL, &#39;v&#39;}</code>, <strong>version</strong> 即为长选项的名称, 即按如下形式<code>--version</code>, <strong>0</strong> 表示该选项后面不带参数, <strong>NULL</strong> 表示直接将<strong>v</strong>返回(字符v在ascii码中对应的数值), 即在使用<strong>getopt_long</strong>遍历到该条选项时, <strong>getopt_long</strong> 返回值为字符v对应的ascii码值.</p><p><strong>longindex</strong>  </p><p>longindex表示长选项在longopts中的位置, 例如在上面的示例中, <strong>version</strong> 对应的 <strong>longindex</strong> 为0, <strong>name</strong> 对应的 <strong>longindex</strong> 为1, <strong>help</strong>对应的 <strong>longindex</strong> 为2, 该项主要用于调试, 一般设为 NULL 即可.</p><p>下面是一个使用示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_getpot_long</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *optstring = <span class="string">"vn:h"</span>;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">opts</span>[] = &#123;</span></span><br><span class="line">        &#123;<span class="string">"version"</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="string">'v'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"name"</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">'n'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"help"</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="string">'h'</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((c = getopt_long(argc, argv, optstring, opts, <span class="literal">NULL</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'n'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"username is %s\n"</span>, optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'v'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"version is 0.0.1\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"this is help\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'?'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"unknown option\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"the return val is 0\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"------\n"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们运行程序 <code>./test --name zhangjikai --version --help --haha</code>, 下面是运行结果:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">username is zhangjikai</span><br><span class="line">version is 0.0.1</span><br><span class="line">this is help</span><br><span class="line">./test: unrecognized option '--haha'</span><br><span class="line">unknown option</span><br></pre></td></tr></table></figure></p><p>当然我们也可以使用短选项 <code>./test -n zhangjikai -v -h</code><br>下面我们对程序做一下修改, 这一次将 struct option 中的 <strong>flag</strong> 和 <strong>longindex</strong> 设为具体的值<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_getpot_long2</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *optstring = <span class="string">"vn:h"</span>;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f_v = <span class="number">-1</span>, f_n = <span class="number">-1</span>, f_h = <span class="number">-1</span>, opt_index = <span class="number">-1</span>; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">opts</span>[] = &#123;</span></span><br><span class="line">        &#123;<span class="string">"version"</span>, <span class="number">0</span>, &amp;f_v, <span class="string">'v'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"name"</span>, <span class="number">1</span>, &amp;f_n, <span class="string">'n'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"help"</span>, <span class="number">0</span>, &amp;f_h, <span class="string">'h'</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((c = getopt_long(argc, argv, optstring, opts, &amp;opt_index)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'n'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"username is %s\n"</span>, optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'v'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"version is 0.0.1\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"this is help\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'?'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"unknown option\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"f_v is %d \n"</span>, f_v);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"f_n is %d \n"</span>, f_n);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"f_h is %d \n"</span>, f_h);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"------\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"opt_index is %d\n\n"</span>, opt_index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行程序: <code>./test --name zhangjikai --version --help</code> , 下面是运行结果:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">f_v is -1 </span><br><span class="line">f_n is 110 </span><br><span class="line">f_h is -1 </span><br><span class="line">opt_index is 1</span><br><span class="line"></span><br><span class="line">f_v is 118 </span><br><span class="line">f_n is 110 </span><br><span class="line">f_h is -1 </span><br><span class="line">opt_index is 0</span><br><span class="line"></span><br><span class="line">f_v is 118 </span><br><span class="line">f_n is 110 </span><br><span class="line">f_h is 104 </span><br><span class="line">opt_index is 2</span><br></pre></td></tr></table></figure></p><p>我们可以看到当给 <strong>flag</strong> 指定具体的指针之后, <strong>getopt_long</strong> 会返回0, 因此会去执行case 0, 并且 <strong>val</strong> 的值赋给了 <strong>flag</strong> 指向的变量. 下面我们用短选项执行一下程序 <code>./test -n zhangjikai -v -h</code>, 下面是运行结果<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">username is zhangjikai</span><br><span class="line">opt_index is <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">version is <span class="number">0.0</span><span class="number">.1</span></span><br><span class="line">opt_index is <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span> is help</span><br><span class="line">opt_index is <span class="number">-1</span></span><br></pre></td></tr></table></figure></p><p>我们看到使用短选项的时候 <strong>getopt_long</strong> 就相当于 <strong>getopt</strong> , <strong>flag</strong> 和 <strong>longindex</strong>都不起作用了. </p><h3 id="getopt-long-和-getopt-long-only"><a href="#getopt-long-和-getopt-long-only" class="headerlink" title="getopt_long 和 getopt_long_only"></a>getopt_long 和 getopt_long_only</h3><p>下面解释一下 <strong>getopt_long</strong> 和 <strong>getopt_long_only</strong>的区别, 首先用下列选项运行一下 <strong>use_getopt_long</strong>  <code>./test -name zhangjkai -version -help</code> , 下面是输出结果:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">username is ame</span><br><span class="line">version is 0.0.1</span><br><span class="line">./test: invalid option -- 'e'</span><br><span class="line">unknown option</span><br><span class="line">./test: invalid option -- 'r'</span><br><span class="line">unknown option</span><br><span class="line">./test: invalid option -- 's'</span><br><span class="line">unknown option</span><br><span class="line">./test: invalid option -- 'i'</span><br><span class="line">unknown option</span><br><span class="line">./test: invalid option -- 'o'</span><br><span class="line">unknown option</span><br><span class="line">username is -help</span><br></pre></td></tr></table></figure></p><p>我们看到使用短选项标识符 <code>-</code> 指向长选项时, 程序还是会按短选项来处理, 即一个字符一个字符的解析. 下面我们将 <strong>use_getopt_long</strong> 做一下更改, 即将 <code>getopt_long</code> 改为 <code>getopt_long_only</code> , 如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_getpot_long3</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *optstring = <span class="string">"vn:h"</span>;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">opts</span>[] = &#123;</span></span><br><span class="line">        &#123;<span class="string">"version"</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="string">'v'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"name"</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">'n'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"help"</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="string">'h'</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((c = getopt_long_only(argc, argv, optstring, opts, <span class="literal">NULL</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'n'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"username is %s\n"</span>, optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'v'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"version is 0.0.1\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"this is help\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'?'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"unknown option\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"the return val is 0\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"------\n"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面再运行程序 <code>./test -name zhangjikai -version -help</code> , 下面是运行结果:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">username is zhangjikai</span><br><span class="line">version is 0.0.1</span><br><span class="line">this is help</span><br></pre></td></tr></table></figure></p><p>即使用 <strong>getopt_long_only</strong> 时, <code>-</code> 和 <code>--</code>都可以作用于长选项, 而使用 <strong>getopt_only</strong> 时, 只有 <code>--</code>可以作用于长选项.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在程序中一般都会用到命令行选项, 我们可以使用getopt 和getopt_long函数来解析命令行参数&lt;/p&gt;
&lt;h2 id=&quot;getopt&quot;&gt;&lt;a href=&quot;#getopt&quot; class=&quot;headerlink&quot; title=&quot;getopt&quot;&gt;&lt;/a&gt;getopt&lt;/h2&gt;&lt;p&gt;getopt主要用来处理短命令行选项, 例如&lt;code&gt;./test -v&lt;/code&gt;中&lt;code&gt;-v&lt;/code&gt;就是一个短选项. 使用该函数需要引入头文件&lt;code&gt;&amp;lt;unistd.h&amp;gt;&lt;/code&gt;, 下面是该函数的定义&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getopt&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; argv[], &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * optstring)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://blog.zhangjikai.com/categories/C/"/>
    
    
      <category term="C" scheme="http://blog.zhangjikai.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【C】文件操作(二)</title>
    <link href="http://blog.zhangjikai.com/2016/03/04/%E3%80%90C%E3%80%91%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C(%E4%BA%8C)/"/>
    <id>http://blog.zhangjikai.com/2016/03/04/【C】文件操作(二)/</id>
    <published>2016-03-04T10:45:21.000Z</published>
    <updated>2019-09-08T06:53:07.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里主要记录一下C对二进制的读写操作, 包括随机读取文件和写入文件</p><h2 id="fseek-和-ftell"><a href="#fseek-和-ftell" class="headerlink" title="fseek 和 ftell"></a>fseek 和 ftell</h2><p><strong>fseek</strong><br>fseek主要用来移动文件指针, 它允许用户像对待数组那样对待一个文件, 可以直接将文件指针移动到任意字节处, 下面是它的函数原型:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span> <span class="params">( FILE * stream, <span class="keyword">long</span> <span class="keyword">int</span> offset, <span class="keyword">int</span> origin )</span></span>;</span><br></pre></td></tr></table></figure></p><p>下面是个参数的含义</p><ul><li>stream - 打开的文件指针</li><li>offset - 偏移量, 表示从起始点开始要移动的距离(起始点的选择由origin指定), 可以为正(向前移)、负(往回移), 也可以为零(保持不动).</li><li>origin - 用来指定起始点的模式, 可以使用下面定义的几个模式常量:<ol><li>SEEK_SET : 以文件开始位置作为起始点</li><li>SEEK_CUR : 以文件指针当前所在的位置作为起始点</li><li>SEEK_END : 以文件结尾作为起始点</li></ol></li></ul><a id="more"></a><p>下面是一些使用示例, 其中fp是一个文件指针<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_SET)  <span class="comment">// 移动到文件开头</span></span><br><span class="line">fseek(fp, <span class="number">10L</span>, SEEK_SET)  <span class="comment">// 移动到文件的第10个字节</span></span><br><span class="line">fseek(fp, <span class="number">2L</span>, SEEK_CUR)  <span class="comment">// 从文件的当前位置向前移动两个字节</span></span><br><span class="line">fssek(fp, <span class="number">0L</span>, SEEK_END)  <span class="comment">// 移动到文件的结尾处</span></span><br><span class="line">fseek(fp, <span class="number">-10L</span>, SEEK_END)  <span class="comment">// 从文件结尾处退回10个字节</span></span><br></pre></td></tr></table></figure></p><p>如果函数执行正常, 那么返回值为0, 如果有错误, 则返回值为-1.<br><strong>ftell</strong><br>ftell函数用来获得当前文件指针的位置, 它返回当前文件指针距离文件开始处的字节数目, 函数原型如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ftell</span> <span class="params">( FILE * stream )</span></span>;</span><br></pre></td></tr></table></figure></p><p>如果函数执行失败会返回-1,</p><p>下面是一个使用示例, 接合fseek和ftell用来获得文件的大小<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">file_size</span><span class="params">(<span class="keyword">char</span> *fileName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> size;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span>((fp = fopen(fileName, <span class="string">"rb"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can't open file %s\n"</span>, fileName);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    fseek (fp, <span class="number">0</span> , SEEK_END);</span><br><span class="line">    size = ftell(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> mb;</span><br><span class="line">    mb = size * <span class="number">1.0</span> / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"file size is %ldB and %.2fMB \n"</span>, size, mb); </span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h2><blockquote><p>Writes an array of <strong>count</strong> elements, each one with a size of <strong>size</strong> bytes, from the block of memory pointed by <strong>ptr</strong> to the current position in the <strong>stream</strong>.</p></blockquote><p>以二进制的形式将数据块写入文件, 函数原型为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> fwrite ( <span class="keyword">const</span> <span class="keyword">void</span> * ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count, FILE * stream );</span><br></pre></td></tr></table></figure></p><p>下面是参数意义:</p><ul><li>ptr - 要写入的内存数据地址</li><li>size - 单个数据块的大小</li><li>count - 写入的数据块的数量</li><li>stream - 写入的目标文件</li></ul><p>如果写入成功, 会返回写入的数据块的数量, 即count, 如果返回值不等于count, 说明程序运行出现了错误.<br>下面是一个使用示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">file_fwrite</span><span class="params">(<span class="keyword">char</span> *fileName)</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span>((fp = fopen(fileName, <span class="string">"w+b"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can't open file %s\n"</span>, fileName);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">20</span>, i;</span><br><span class="line">    <span class="keyword">int</span> *buffer;</span><br><span class="line">    buffer = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * count);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        buffer[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> success_num = <span class="number">0</span>;</span><br><span class="line">    success_num = fwrite(buffer, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) , count, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"success_num is %ld\n"</span>, success_num);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是写入的内容<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0100 0000 0200 0000 0300 0000</span><br><span class="line">0400 0000 0500 0000 0600 0000 0700 0000</span><br><span class="line">0800 0000 0900 0000 0a00 0000 0b00 0000</span><br><span class="line">0c00 0000 0d00 0000 0e00 0000 0f00 0000</span><br><span class="line">1000 0000 1100 0000 1200 0000 1300 0000</span><br></pre></td></tr></table></figure></p><p>上面是以16进制的形式进行显示, 即一个数字为4位, 一个int值占32位(4个字节),  在上面的内容中, 8个数字为1个int, 如 <code>0000 0000</code>为第一个int值, 即0, <code>0100 0000</code>为第二个int值, 即1. 这里需要说明的是在写入时是字节作为一个基本单位的, 并且低位字节是先写入的, 如<code>0100 0000</code>, 其中<code>01</code>就是int的最低位的字节. 我们来看这个例子, 如果写入文件之后的值为<code>1234 5678</code>, 那么其原先的值就是<code>0x78563412</code></p><h2 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h2><blockquote><p>Reads an array of <strong>count</strong> elements, each one with a size of <strong>size</strong> bytes, from the <strong>stream</strong> and stores them in the block of memory specified by <strong>ptr</strong>.</p></blockquote><p>以二进制的形式将数据块读入内存, 下面是函数原型:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> fread ( <span class="keyword">void</span> * ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count, FILE * stream );</span><br></pre></td></tr></table></figure></p><p>下面是参数含义</p><ul><li>ptr - 读入文件数据的内存地址</li><li>size - 单个数据块的大小</li><li>count - 数据块的数量</li><li>stream - 读取的文件</li></ul><p>如果读入成功, 会返回读入的数据块的数量. 下面是一个使用示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">file_fread</span><span class="params">(<span class="keyword">char</span> *fileName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count;</span><br><span class="line">    <span class="keyword">int</span> *buffer;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span>((fp = fopen(fileName, <span class="string">"rb"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can't open file %s\n"</span>, fileName);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    fseek (fp, <span class="number">0</span> , SEEK_END);</span><br><span class="line">    count = ftell(fp);</span><br><span class="line">    rewind(fp);</span><br><span class="line">    buffer =(<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * count);</span><br><span class="line"></span><br><span class="line">    fread(buffer, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), count / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), fp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count/ <span class="keyword">sizeof</span>(<span class="keyword">int</span>); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, buffer[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="rewind"><a href="#rewind" class="headerlink" title="rewind"></a>rewind</h2><blockquote><p>Sets the position indicator associated with stream to the beginning of the file.</p></blockquote><p>重置文件指针到文件开头位置, 下面是函数原型:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span> <span class="params">( FILE * stream )</span></span>;</span><br></pre></td></tr></table></figure></p><h2 id="setbuf-和-setvbuf"><a href="#setbuf-和-setvbuf" class="headerlink" title="setbuf 和 setvbuf"></a>setbuf 和 setvbuf</h2><p>当打开一个文件后, 系统会自动为该文件流分配一个缓冲区, 其大小为<code>BUFSIZ</code>, 我们可以通过打印<code>BUFSIZ</code>来获得默认的缓冲区大小. 如果想自定义缓冲区, 可以使用setbuf和setvbuf函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, BUFSIZ);</span><br></pre></td></tr></table></figure></p><p><strong>setbuf</strong></p><blockquote><p>Specifies the buffer to be used by the stream for I/O operations, which becomes a fully buffered stream. Or, alternatively, if buffer is a null pointer, buffering is disabled for the stream, which becomes an unbuffered stream.</p></blockquote><p>为文件流指定一个缓冲区, 函数原型为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span> <span class="params">( FILE * stream, <span class="keyword">char</span> * buffer )</span></span>;</span><br></pre></td></tr></table></figure></p><p>buffer表示指定的缓冲区, 需要注意的一点是, 这里缓冲区的大小仍然为<code>BUFSIZ</code>, 只不过是缓冲区的位置发生了改变, 因此buffer的大小应该大于或者等于<code>BUFSIZ</code>.  该函数应该在文件刚被打开时调用, 不能在进行了读写操作之后再调用. 如果buffer的为NULL, 就表示禁用缓冲区. 下面是一个使用示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buffer[BUFSIZ];</span><br><span class="line">  FILE *pFile1, *pFile2;</span><br><span class="line"></span><br><span class="line">  pFile1=fopen (<span class="string">"myfile1.txt"</span>,<span class="string">"w"</span>);</span><br><span class="line">  pFile2=fopen (<span class="string">"myfile2.txt"</span>,<span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line">  setbuf ( pFile1 , buffer );</span><br><span class="line">  <span class="built_in">fputs</span> (<span class="string">"This is sent to a buffered stream"</span>,pFile1);</span><br><span class="line">  fflush (pFile1);</span><br><span class="line"></span><br><span class="line">  setbuf ( pFile2 , <span class="literal">NULL</span> );</span><br><span class="line">  <span class="built_in">fputs</span> (<span class="string">"This is sent to an unbuffered stream"</span>,pFile2);</span><br><span class="line"></span><br><span class="line">  fclose (pFile1);</span><br><span class="line">  fclose (pFile2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>setvbuf</strong></p><blockquote><p>Specifies a buffer for stream. The function allows to specify the mode and size of the buffer (in bytes).</p></blockquote><p>为文件指定一个缓冲区, 同时可以指定缓冲区的类型和大小, 下面是函数原型:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span> <span class="params">( FILE * stream, <span class="keyword">char</span> * buffer, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size )</span></span>;</span><br></pre></td></tr></table></figure></p><p>其中 stream表示操作的文件, buffer为指定的缓冲区首地址, 如果缓冲区为NULL, 系统会自动创建一个大小为size的缓冲区, mode为缓冲区的类别, size为缓冲区的大小, 其中mode的值可以为下面几个:</p><ul><li><p><strong>_IOFBF</strong> - 全缓冲(Full buffering), 当缓冲区满时才执行真正的I/O操作, 例如对磁盘文件的读写. </p><blockquote><p> On output, data is written once the buffer is full (or flushed). On Input, the buffer is filled when an input operation is requested and the buffer is empty.</p></blockquote></li><li><p><strong>_IOLBF</strong> - 行缓冲(Line buffering), 在输入和输出时遇到换行符时才进行真正的I/O操作, 例如标准输入(stdin)和标准输出(stdout). </p><blockquote><p>On output, data is written when a newline character is inserted into the stream or when the buffer is full (or flushed), whatever happens first. On Input, the buffer is filled up to the next newline character when an input operation is requested and the buffer is empty. </p></blockquote></li><li><p><strong>_IONBF</strong> - 无缓冲(No buffering), 在这种情况下buffer和size参数会被忽略.</p></li></ul><p>其实setbuf将相当于调用了setvbuf<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setvbuf(stream, buf, buf ? _IOFBF : _IONBF, BUFSIZE)</span><br></pre></td></tr></table></figure></p><p>下面是一个使用示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">  FILE *pFile;</span><br><span class="line">  pFile=fopen (<span class="string">"myfile.txt"</span>,<span class="string">"w"</span>);</span><br><span class="line">  setvbuf ( pFile , <span class="literal">NULL</span> , _IOFBF , <span class="number">1024</span> );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// File operations here</span></span><br><span class="line"></span><br><span class="line">  fclose (pFile);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="fflush"><a href="#fflush" class="headerlink" title="fflush"></a>fflush</h2><p>对于输入输出流, 下列情况会自动刷新缓冲区</p><ul><li>当进行输出(output)操作时, 输出缓冲区满了</li><li>当流(stream)被关闭</li><li>当程序调用exit方法终止</li><li>当缓冲区为行缓冲区时, 一个换行符(newline)被写入</li><li>Whenever an input operation on any stream actually reads data from its file.</li></ul><p>对于一个输出流, 可以调用fflush进行显示的刷新缓冲区, 即将缓冲区的内容写入到文件中, 但是对于一个输入流使用fflush函数的效果没有定义. 下面是函数原型:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span> <span class="params">( FILE * stream )</span></span>;</span><br></pre></td></tr></table></figure></p><p>如果stream为NULL, 那么所有的缓冲区都将被刷新.</p><h2 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h2><p>stat函数主要用于获取文件状态, 函数原型为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, struct stat *buf)</span></span></span><br></pre></td></tr></table></figure></p><p>下面是struct stat的定义:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="comment">//device 文件的设备编号</span></span><br><span class="line">    <span class="keyword">dev_t</span> st_dev;   </span><br><span class="line">    <span class="comment">//inode 文件的i-node</span></span><br><span class="line">    <span class="keyword">ino_t</span> st_ino;   </span><br><span class="line">    <span class="comment">//protection 文件的类型和存取的权限</span></span><br><span class="line">    <span class="keyword">mode_t</span> st_mode;  </span><br><span class="line">    <span class="comment">//number of hard links 连到该文件的硬连接数目, 刚建立的文件值为1.</span></span><br><span class="line">    <span class="keyword">nlink_t</span> st_nlink;  </span><br><span class="line">    <span class="comment">//user ID of owner 文件所有者的用户识别码</span></span><br><span class="line">    <span class="keyword">uid_t</span> st_uid;  </span><br><span class="line">    <span class="comment">//group ID of owner 文件所有者的组识别码</span></span><br><span class="line">    <span class="keyword">gid_t</span> st_gid;  </span><br><span class="line">    <span class="comment">//device type 若此文件为装置设备文件, 则为其设备编号</span></span><br><span class="line">    <span class="keyword">dev_t</span> st_rdev;  </span><br><span class="line">    <span class="comment">//total size, in bytes 文件大小, 以字节计算</span></span><br><span class="line">    <span class="keyword">off_t</span> st_size;  </span><br><span class="line">    <span class="comment">//blocksize for filesystem I/O 文件系统的I/O 缓冲区大小.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> st_blksize;  </span><br><span class="line">    <span class="comment">//number of blocks allocated 占用文件区块的个数, 每一区块大小为512 个字节.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> st_blocks; </span><br><span class="line">    <span class="comment">//time of lastaccess 文件最近一次被存取或被执行的时间, 一般只有在用mknod、utime、read、write 与tructate 时改变.</span></span><br><span class="line">    <span class="keyword">time_t</span> st_atime;  </span><br><span class="line">    <span class="comment">//time of last modification 文件最后一次被修改的时间, 一般只有在用mknod、utime 和write 时才会改变</span></span><br><span class="line">    <span class="keyword">time_t</span> st_mtime;  </span><br><span class="line">    <span class="comment">//time of last change i-node 最近一次被更改的时间, 此参数会在文件所有者、组、权限被更改时更新</span></span><br><span class="line">    <span class="keyword">time_t</span> st_ctime;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其中st_mode定义了以下数种情况</p><ol><li><strong>S_IFMT</strong> - 0170000 文件类型的位遮罩</li><li><strong>S_IFSOCK</strong> - 0140000 scoket</li><li><strong>S_IFLNK</strong> - 0120000 符号连接</li><li><strong>S_IFREG</strong> - 0100000 一般文件</li><li><strong>S_IFBLK</strong> - 0060000 区块装置</li><li><strong>S_IFDIR</strong> - 0040000 目录</li><li><strong>S_IFCHR</strong> - 0020000 字符装置</li><li><strong>S_IFIFO</strong> - 0010000 先进先出</li><li><strong>S_ISUID</strong> - 04000 文件的 (set user-id on execution)位</li><li><strong>S_ISGID</strong> - 02000 文件的 (set group-id on execution)位</li><li><strong>S_ISVTX</strong> - 01000 文件的sticky 位</li><li><strong>S_IRUSR (S_IREAD)</strong> - 00400 文件所有者具可读取权限</li><li><strong>S_IWUSR (S_IWRITE)</strong> - 00200 文件所有者具可写入权限</li><li><strong>S_IXUSR (S_IEXEC)</strong> - 00100 文件所有者具可执行权限</li><li><strong>S_IRGRP</strong> - 00040 用户组具可读取权限</li><li><strong>S_IWGRP</strong> - 00020 用户组具可写入权限</li><li><strong>S_IXGRP</strong> - 00010 用户组具可执行权限</li><li><strong>S_IROTH</strong> - 00004 其他用户具可读取权限</li><li><strong>S_IWOTH</strong> - 00002 其他用户具可写入权限</li><li><strong>S_IXOTH</strong> - 00001 其他用户具可执行权限上述的文件类型在 POSIX 中定义了检查这些类型的宏定义</li><li><strong>S_ISLNK (st_mode)</strong> - 判断是否为符号连接</li><li><strong>S_ISREG (st_mode)</strong> - 是否为一般文件</li><li><strong>S_ISDIR (st_mode)</strong> - 是否为目录</li><li><strong>S_ISCHR (st_mode)</strong> - 是否为字符装置文件</li><li><strong>S_ISBLK (s3e)</strong> - 是否为先进先出</li><li><strong>S_ISSOCK (st_mode)</strong> - 是否为socket 若一目录具有sticky 位 (S_ISVTX), 则表示在此目录下的文件只能被该文件所有者、此目录所有者或root 来删除或改名.</li></ol><p>下面是一个使用示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">file_stat</span><span class="params">(<span class="keyword">char</span> * fileName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">fileStat</span>;</span></span><br><span class="line">    stat(fileName, &amp;fileStat);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Information for %s\n"</span>, fileName);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------------------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"File Size: \t\t%ld bytes\n"</span>,fileStat.st_size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Number of Links: \t%ld\n"</span>,fileStat.st_nlink);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"File inode: \t\t%ld\n"</span>,fileStat.st_ino);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"File Permissions: \t"</span>);</span><br><span class="line">    <span class="built_in">printf</span>( (S_ISDIR(fileStat.st_mode)) ? <span class="string">"d"</span> : <span class="string">"-"</span>);</span><br><span class="line">    <span class="built_in">printf</span>( (fileStat.st_mode &amp; S_IRUSR) ? <span class="string">"r"</span> : <span class="string">"-"</span>);</span><br><span class="line">    <span class="built_in">printf</span>( (fileStat.st_mode &amp; S_IWUSR) ? <span class="string">"w"</span> : <span class="string">"-"</span>);</span><br><span class="line">    <span class="built_in">printf</span>( (fileStat.st_mode &amp; S_IXUSR) ? <span class="string">"x"</span> : <span class="string">"-"</span>);</span><br><span class="line">    <span class="built_in">printf</span>( (fileStat.st_mode &amp; S_IRGRP) ? <span class="string">"r"</span> : <span class="string">"-"</span>);</span><br><span class="line">    <span class="built_in">printf</span>( (fileStat.st_mode &amp; S_IWGRP) ? <span class="string">"w"</span> : <span class="string">"-"</span>);</span><br><span class="line">    <span class="built_in">printf</span>( (fileStat.st_mode &amp; S_IXGRP) ? <span class="string">"x"</span> : <span class="string">"-"</span>);</span><br><span class="line">    <span class="built_in">printf</span>( (fileStat.st_mode &amp; S_IROTH) ? <span class="string">"r"</span> : <span class="string">"-"</span>);</span><br><span class="line">    <span class="built_in">printf</span>( (fileStat.st_mode &amp; S_IWOTH) ? <span class="string">"w"</span> : <span class="string">"-"</span>);</span><br><span class="line">    <span class="built_in">printf</span>( (fileStat.st_mode &amp; S_IXOTH) ? <span class="string">"x"</span> : <span class="string">"-"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The file %s a symbolic link\n"</span>, (S_ISLNK(fileStat.st_mode)) ? <span class="string">"is"</span> : <span class="string">"is not"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果如下:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Information for data/test.txt</span><br><span class="line">---------------------------</span><br><span class="line">File Size:      24023896 bytes</span><br><span class="line">Number of Links:    1</span><br><span class="line">File inode:         8261278</span><br><span class="line">File Permissions:   -rw-rw-r--</span><br><span class="line"></span><br><span class="line">The file is not a symbolic link</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这里主要记录一下C对二进制的读写操作, 包括随机读取文件和写入文件&lt;/p&gt;
&lt;h2 id=&quot;fseek-和-ftell&quot;&gt;&lt;a href=&quot;#fseek-和-ftell&quot; class=&quot;headerlink&quot; title=&quot;fseek 和 ftell&quot;&gt;&lt;/a&gt;fseek 和 ftell&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;fseek&lt;/strong&gt;&lt;br&gt;fseek主要用来移动文件指针, 它允许用户像对待数组那样对待一个文件, 可以直接将文件指针移动到任意字节处, 下面是它的函数原型:&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fseek&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;( FILE * stream, &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; offset, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; origin )&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;下面是个参数的含义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stream - 打开的文件指针&lt;/li&gt;
&lt;li&gt;offset - 偏移量, 表示从起始点开始要移动的距离(起始点的选择由origin指定), 可以为正(向前移)、负(往回移), 也可以为零(保持不动).&lt;/li&gt;
&lt;li&gt;origin - 用来指定起始点的模式, 可以使用下面定义的几个模式常量:&lt;ol&gt;
&lt;li&gt;SEEK_SET : 以文件开始位置作为起始点&lt;/li&gt;
&lt;li&gt;SEEK_CUR : 以文件指针当前所在的位置作为起始点&lt;/li&gt;
&lt;li&gt;SEEK_END : 以文件结尾作为起始点&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="C" scheme="http://blog.zhangjikai.com/categories/C/"/>
    
    
      <category term="C" scheme="http://blog.zhangjikai.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【OpenMP学习笔记】更多指令和子句介绍</title>
    <link href="http://blog.zhangjikai.com/2016/02/26/%E3%80%90OpenMP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%9B%B4%E5%A4%9A%E6%8C%87%E4%BB%A4%E5%92%8C%E5%AD%90%E5%8F%A5%E4%BB%8B%E7%BB%8D/"/>
    <id>http://blog.zhangjikai.com/2016/02/26/【OpenMP学习笔记】更多指令和子句介绍/</id>
    <published>2016-02-26T09:44:15.000Z</published>
    <updated>2019-09-08T06:53:07.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h3><p>flush指令主要用于处理内存一致性问题. 每个处理器(processor)都有自己的本地(local)存储单元:寄存器和缓存, 当一个线程更新了共享变量之后, 新的值会首先存储到寄存器中, 然后更新到本地缓存中. 这些更新并非立刻就可以被其他线程得知, 因此在其它处理器中运行的线程不能访问这些存储单元. 如果一个线程不知道这些更新而使用共享变量的旧值就行运算, 就可能会得到错误的结果.<br>通过使用flush指令, 可以保证线程读取到的共享变量的最新值. 下面是语法形式:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp flush[(list)]</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>list指定需要flush的共享变量, 如果不指定list, 将flush作用于所有的共享变量. 在下面的几个位置已经隐式的添加了不指定list的flush指令.</p><ul><li>所有隐式和显式的路障(barrier)</li><li>Entry to and exit from critical regions</li><li>Entry to and exit from lock routines</li></ul><h3 id="threadprivate"><a href="#threadprivate" class="headerlink" title="threadprivate"></a>threadprivate</h3><p>threadprivate作用于全局变量, 用来指定该全局变量被各个线程各自复制一份私有的拷贝, 即各个线程具有<strong>各自私有</strong>、<strong>线程范围</strong>内的<strong>全局对象</strong>, 语法形式如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp threadprivate(list)</span></span><br></pre></td></tr></table></figure></p><p>其与private不同的时, threadprivate变量是存储在heap或者<a href="https://en.wikipedia.org/wiki/Thread-local_storage" target="_blank" rel="noopener">Thread local storage</a>当中, 可以跨并行域访问, 而private绝大多数情况是存储在stack中, 只在当前并行域中访问, 下面是一个使用示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> counter;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp threadprivate(counter)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_threadprivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel </span></span><br><span class="line">    &#123;</span><br><span class="line">        counter = omp_get_thread_num();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1: thread %d : counter is %d\n"</span>, omp_get_thread_num(), counter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"2: thread %d : counter is %d\n"</span>, omp_get_thread_num(), counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是输出结果<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1: thread 3 : counter is 3</span><br><span class="line">1: thread 0 : counter is 0</span><br><span class="line">1: thread 2 : counter is 2</span><br><span class="line">1: thread 1 : counter is 1</span><br><span class="line"></span><br><span class="line">2: thread 2 : counter is 2</span><br><span class="line">2: thread 0 : counter is 0</span><br><span class="line">2: thread 3 : counter is 3</span><br><span class="line">2: thread 1 : counter is 1</span><br></pre></td></tr></table></figure></p><p>从输出结果我们可以看到, 在第二个并行域中, counter保存了在第一个并行域中的值. 如果要使两个并行域之间可以共享threadprivate变量的值, 需要满足以下几个条件:</p><ul><li>任意一个并行域都不能嵌套在其他并行域中(Neither parallel region is nested inside another explicit parallel region.)</li><li>执行两个并行域的线程数量要相同(The number of threads used to execute both parallel regions is the same.)</li><li>执行两个并行域时的线程亲和度策略要相同( The thread affinity policies used to execute both parallel regions are the same.)</li><li>在进入并行域之前dyn-var变量的值必须为false(0). (The value of the dyn-var internal control variable in the enclosing task region is false at entry to both parallel regions.)</li></ul><h2 id="子句"><a href="#子句" class="headerlink" title="子句"></a>子句</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>用来控制并行域是串行执行还是并行执行, 只能作用于paralle指令, 下面是其语法形式:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel <span class="meta-keyword">if</span>(scalar-logical-expression)</span></span><br></pre></td></tr></table></figure></p><p>如果if的判断条件为true, 则并行执行, 否则串行执行, 下面是一个使用示例<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_if</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>, tid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n = 1\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel <span class="meta-keyword">if</span>(n&gt;5) default(none) \</span></span><br><span class="line">    <span class="keyword">private</span>(tid) shared(n)</span><br><span class="line">    &#123;</span><br><span class="line">        tid = omp_get_thread_num();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread %d is running\n"</span>, tid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    n = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n = 10\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel <span class="meta-keyword">if</span>(n&gt;5) default(none) \</span></span><br><span class="line">    <span class="keyword">private</span>(tid) shared(n)</span><br><span class="line">    &#123;</span><br><span class="line">        tid = omp_get_thread_num();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread %d is running\n"</span>, tid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果如下<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n = 1</span><br><span class="line">thread 0 is running</span><br><span class="line"></span><br><span class="line">n = 10</span><br><span class="line">thread 0 is running</span><br><span class="line">thread 2 is running</span><br><span class="line">thread 3 is running</span><br><span class="line">thread 1 is running</span><br></pre></td></tr></table></figure></p><h3 id="reduction"><a href="#reduction" class="headerlink" title="reduction"></a>reduction</h3><p>如果利用循环, 将某项计算的所有结果进行求和(或者减、乘等其他操作)得出一个数值, 这在并行计算中十分常见, 通常将其称为规约. OpenMP提供了reduction子句由于规约操作, 其语法形式为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduction(<span class="keyword">operator</span>:<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure></p><p>下面是一个使用实例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_reduction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum, i;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for default(none) \</span></span><br><span class="line">    <span class="keyword">private</span>(i) shared(a,n) reduction(+:sum)</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum is %d\n"</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用规约子句之后, 无需再对sum进行保护, 下面是reduction支持的操作符以及变量的初值<br><img src="/images/openmp/reduction.png" alt><br>在使用乘法时发现其初始值同样为0, 可能和具体的实现有关. </p><h3 id="copyin"><a href="#copyin" class="headerlink" title="copyin"></a>copyin</h3><p>将主线程中threadprivate变量的值复制到执行并行域的各个线程的threadprivate变量中, 作为各线程中threadprivate变量的初始值. 作用于parallel指令, 下面是一个使用示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> counter = <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp threadprivate(counter)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_copyin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"counter is %d\n"</span>, counter);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel copyin(counter) </span></span><br><span class="line">    &#123;</span><br><span class="line">        counter = omp_get_thread_num() + counter + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" thread %d : counter is %d\n"</span>, omp_get_thread_num(), counter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"counter is %d\n"</span>, counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是输出结果:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">counter is 10</span><br><span class="line">thread 0 : counter is 11</span><br><span class="line">thread 2 : counter is 13</span><br><span class="line">thread 3 : counter is 14</span><br><span class="line">thread 1 : counter is 12</span><br><span class="line">counter is 11</span><br></pre></td></tr></table></figure></p><h3 id="copyprivate"><a href="#copyprivate" class="headerlink" title="copyprivate"></a>copyprivate</h3><p>将一个线程私有变量的值广播到执行同一并行域的其他线程. 只能作用于single指令, 下面是一个使用示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> counter = <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp threadprivate(counter)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_copyprivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel private(i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp single copyprivate(i, counter) </span></span><br><span class="line">        &#123;</span><br><span class="line">            i = <span class="number">50</span>;</span><br><span class="line">            counter = <span class="number">100</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"thread %d execute single\n"</span>, omp_get_thread_num());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread %d: i is %d and counter is %d\n"</span>,omp_get_thread_num(), i, counter);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是程序运行结果:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread 3 execute single</span><br><span class="line">thread 2: i is 50 and counter is 100</span><br><span class="line">thread 3: i is 50 and counter is 100</span><br><span class="line">thread 0: i is 50 and counter is 100</span><br><span class="line">thread 1: i is 50 and counter is 100</span><br></pre></td></tr></table></figure></p><p>下面是将copyprivate(i, counter)去掉的运行结果<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread 0 execute single</span><br><span class="line">thread 2: i is 0 and counter is 10</span><br><span class="line">thread 0: i is 50 and counter is 100</span><br><span class="line">thread 3: i is 0 and counter is 10</span><br><span class="line">thread 1: i is 32750 and counter is 10</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;指令&quot;&gt;&lt;a href=&quot;#指令&quot; class=&quot;headerlink&quot; title=&quot;指令&quot;&gt;&lt;/a&gt;指令&lt;/h2&gt;&lt;h3 id=&quot;flush&quot;&gt;&lt;a href=&quot;#flush&quot; class=&quot;headerlink&quot; title=&quot;flush&quot;&gt;&lt;/a&gt;flush&lt;/h3&gt;&lt;p&gt;flush指令主要用于处理内存一致性问题. 每个处理器(processor)都有自己的本地(local)存储单元:寄存器和缓存, 当一个线程更新了共享变量之后, 新的值会首先存储到寄存器中, 然后更新到本地缓存中. 这些更新并非立刻就可以被其他线程得知, 因此在其它处理器中运行的线程不能访问这些存储单元. 如果一个线程不知道这些更新而使用共享变量的旧值就行运算, 就可能会得到错误的结果.&lt;br&gt;通过使用flush指令, 可以保证线程读取到的共享变量的最新值. 下面是语法形式:&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;pragma&lt;/span&gt; omp flush[(list)]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OpenMP" scheme="http://blog.zhangjikai.com/categories/OpenMP/"/>
    
    
      <category term="学习笔记" scheme="http://blog.zhangjikai.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OpenMP" scheme="http://blog.zhangjikai.com/tags/OpenMP/"/>
    
  </entry>
  
  <entry>
    <title>【OpenMP学习笔记】与运行环境交互</title>
    <link href="http://blog.zhangjikai.com/2016/02/26/%E3%80%90OpenMP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E4%BA%A4%E4%BA%92/"/>
    <id>http://blog.zhangjikai.com/2016/02/26/【OpenMP学习笔记】与运行环境交互/</id>
    <published>2016-02-26T01:23:49.000Z</published>
    <updated>2019-09-08T06:53:07.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Internal-Control-Variables"><a href="#Internal-Control-Variables" class="headerlink" title="Internal Control Variables"></a>Internal Control Variables</h2><p>OpenMP标准定义了内部控制变量(internal control variables), 这些变量可以影响程序运行时的行为, 但是它们不能被直接访问或者修改, 我们需要通过OpenMP函数或者环境变量来访问或者修改它们, 下面是被定义的内部变量</p><ul><li>nthread-var : 存储并行域的线程数量</li><li>dyn-var : 控制在并行域执行时是否可以动态调整线程的数量</li><li>nest-var : 控制在并行域执行时是否允许嵌套并行</li><li>run-sched-var : 存储在循环域(loop regions)使用 runtime 调度子句时的调度类型</li><li>def-sched-var : 存储对于循环域默认的调度类型</li></ul><a id="more"></a><h2 id="nthread-var"><a href="#nthread-var" class="headerlink" title="nthread-var"></a>nthread-var</h2><p>我们可以通过以下几种方式来设置线程数量  </p><p><strong>OMP_NUM_THREADS</strong><br>我们可以在命令行(command line)下设置OMP_NUM_THREADS环境变量的值, 而该变量的值用于初始化 nthread-var 变量.  </p><p><strong>omp_set_num_threads</strong><br>在程序中我们可以使用omp_set_num_threads函数来设置线程数量, 语法形式为<code>omp_set_num_threads(integer)</code></p><p><strong>num_threads</strong><br>最后我们可以在构造并行域的时候使用num_threads子句来控制线程的数量</p><p>上面的三种方式优先级依次递增, 另外在程序执行时, 我们可以使用下面几个函数获得线程的数量信息</p><ul><li>omp_get_max_threads : 获得可以使用的最大线程数量, 数量是可以确定的, 与在串行域还是并行域调用无关. </li><li>omp_get_num_threads: 获得当前运行线程的数量, 如果不在并行域内调用则返回1</li><li>omp_get_thread_num: 获得线程的编号, 从0开始</li></ul><p>下面是一个使用示例<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_numthread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"max thread nums is %d\n"</span>, omp_get_max_threads());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"omp_get_num_threads: out parallel region is %d\n"</span>, omp_get_num_threads());</span><br><span class="line">    </span><br><span class="line">    omp_set_num_threads(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after omp_set_num_threads: max thread nums is %d\n"</span>, omp_get_max_threads());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp master</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"omp_get_num_threads: in parallel region is %d\n\n"</span>, omp_get_num_threads());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1: thread %d is running\n"</span>, omp_get_thread_num());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel num_threads(3)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"2: thread %d is running\n"</span>, omp_get_thread_num());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是程序运行结果:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">max thread nums is 4</span><br><span class="line">omp_get_num_threads: out parallel region is 1</span><br><span class="line">after omp_set_num_threads: max thread nums is 2</span><br><span class="line">omp_get_num_threads: in parallel region is 2</span><br><span class="line"></span><br><span class="line">1: thread 0 is running</span><br><span class="line">1: thread 1 is running</span><br><span class="line"></span><br><span class="line">2: thread 0 is running</span><br><span class="line">2: thread 1 is running</span><br><span class="line">2: thread 2 is running</span><br></pre></td></tr></table></figure></p><h2 id="dyn-var"><a href="#dyn-var" class="headerlink" title="dyn-var"></a>dyn-var</h2><p>dyn-var控制程序是否在运行中是都可以动态的调整线程的数量, 可以通过下面的两种方式来设置</p><p><strong>OMP_DYNAMIC</strong><br>通过OMP_DYNAMIC环境变量来控制, 如果设为true, 则代表允许动态调整, 设为false则不可以</p><p><strong>omp_set_dynamic</strong><br>通过omp_set_dynamic函数, omp_set_dynamic(1)表示允许, omp_set_dynamic(0)表示不可以, 注意omp_set_dynamic可以传入其他非负整数, 但是作用和输入1是相同的, 都是表示true.</p><p>可以通过omp_get_dynamic来获得dynamic的状态, 返回值为0和1, 下面是一个使用示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_dynamic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"dynamic state is %d\n"</span>, omp_get_dynamic());</span><br><span class="line"></span><br><span class="line">    omp_set_num_threads(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread %d is running\n"</span>, omp_get_thread_num());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    omp_set_dynamic(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"dynamic state is %d\n"</span>, omp_get_dynamic());</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread %d is running\n"</span>, omp_get_thread_num());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是输出结果:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dynamic state is 0</span><br><span class="line">thread 3 is running</span><br><span class="line">thread 4 is running</span><br><span class="line">thread 0 is running</span><br><span class="line">thread 5 is running</span><br><span class="line">thread 1 is running</span><br><span class="line">thread 2 is running</span><br><span class="line"></span><br><span class="line">dynamic state is 1</span><br><span class="line">thread 3 is running</span><br><span class="line">thread 1 is running</span><br><span class="line">thread 2 is running</span><br><span class="line">thread 0 is running</span><br></pre></td></tr></table></figure></p><p>当允许动态调整之后, 第二个for循环只打印了四次,即只有四个线程在执行. 一般来说动态调整会根据系统资源来确定线程数量, 大多数情况下会生成和CPU数目相同的线程. 还有一点, 动态调整时生成的线程不会超过当前运行环境所允许的最大线程数量, 在上面的代码中, 如果将<code>omp_set_num_threads(6)</code>改为<code>omp_set_num_threads(2)</code>, 那么动态调整时最多只会生成两个线程. </p><h2 id="nest-var"><a href="#nest-var" class="headerlink" title="nest-var"></a>nest-var</h2><p>nest-var用来控制是否可以嵌套并行, 可以通过下面两种方式来设置</p><p><strong>OMP_NESTED</strong><br>通过设置OMP_NESTED环境变量, true表示允许, false表示不允许</p><p><strong>omp_set_nested</strong><br>通过omp_set_nested函数, omp_set_nested(1或其他非负整数)表示允许, omp_set_nested(0)表示不允许.</p><p>可以通过omp_get_nested来获得是否可以嵌套并行, 返回值是0或1, 下面是一个使用示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_nested</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"nested state is %d\n"</span>, omp_get_nested());</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel num_threads(2) private(tid)</span></span><br><span class="line">    &#123;</span><br><span class="line">        tid = omp_get_thread_num();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"In outer parallel region: thread %d is running\n"</span>, tid);</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel num_threads(2) firstprivate(tid)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"In nested parallel region: thread %d is running and outer thread is %d\n"</span>, omp_get_thread_num(), tid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    omp_set_nested(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"nested state is %d\n"</span>, omp_get_nested());</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel num_threads(2) private(tid)</span></span><br><span class="line">    &#123;</span><br><span class="line">        tid = omp_get_thread_num();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"In outer parallel region: thread %d is running\n"</span>, tid);</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel num_threads(2)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"In nested parallel region: thread %d is running and outer thread is %d\n"</span>, omp_get_thread_num(), tid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是程序运行结果:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nested state is <span class="number">0</span></span><br><span class="line">In outer parallel region: thread <span class="number">0</span> is running</span><br><span class="line">In nested parallel region: thread <span class="number">0</span> is running <span class="keyword">and</span> outer thread is <span class="number">0</span></span><br><span class="line">In outer parallel region: thread <span class="number">1</span> is running</span><br><span class="line">In nested parallel region: thread <span class="number">0</span> is running <span class="keyword">and</span> outer thread is <span class="number">1</span></span><br><span class="line"></span><br><span class="line">nested state is <span class="number">1</span></span><br><span class="line">In outer parallel region: thread <span class="number">1</span> is running</span><br><span class="line">In outer parallel region: thread <span class="number">0</span> is running</span><br><span class="line">In nested parallel region: thread <span class="number">0</span> is running <span class="keyword">and</span> outer thread is <span class="number">0</span></span><br><span class="line">In nested parallel region: thread <span class="number">0</span> is running <span class="keyword">and</span> outer thread is <span class="number">1</span></span><br><span class="line">In nested parallel region: thread <span class="number">1</span> is running <span class="keyword">and</span> outer thread is <span class="number">1</span></span><br><span class="line">In nested parallel region: thread <span class="number">1</span> is running <span class="keyword">and</span> outer thread is <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>当不允许嵌套并行时, 在并行域内创建的新并行域会以单线程执行, 而允许嵌套并行之后, 会在并行域内创建新的并行域, 为其分配新的线程执行.</p><h2 id="def-sched-var"><a href="#def-sched-var" class="headerlink" title="def-sched-var"></a>def-sched-var</h2><p>通过OMP_SCHEDULE环境变量, 可以设置循环调度为runtime时的调度类型, 具体参见<a href="http://localhost:4000/2016/01/25/OpenMP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/#schedule" target="_blank" rel="noopener">这里</a></p><h2 id="其它函数"><a href="#其它函数" class="headerlink" title="其它函数"></a>其它函数</h2><p><strong>omp_get_num_procs</strong><br>获得程序中可以使用的处理器数量, 是一个全局的值</p><p><strong>omp_in_parallel</strong><br>判断是否在一个活跃的并行域(active parallel region)内, 返回0或1.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Internal-Control-Variables&quot;&gt;&lt;a href=&quot;#Internal-Control-Variables&quot; class=&quot;headerlink&quot; title=&quot;Internal Control Variables&quot;&gt;&lt;/a&gt;Internal Control Variables&lt;/h2&gt;&lt;p&gt;OpenMP标准定义了内部控制变量(internal control variables), 这些变量可以影响程序运行时的行为, 但是它们不能被直接访问或者修改, 我们需要通过OpenMP函数或者环境变量来访问或者修改它们, 下面是被定义的内部变量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nthread-var : 存储并行域的线程数量&lt;/li&gt;
&lt;li&gt;dyn-var : 控制在并行域执行时是否可以动态调整线程的数量&lt;/li&gt;
&lt;li&gt;nest-var : 控制在并行域执行时是否允许嵌套并行&lt;/li&gt;
&lt;li&gt;run-sched-var : 存储在循环域(loop regions)使用 runtime 调度子句时的调度类型&lt;/li&gt;
&lt;li&gt;def-sched-var : 存储对于循环域默认的调度类型&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="OpenMP" scheme="http://blog.zhangjikai.com/categories/OpenMP/"/>
    
    
      <category term="学习笔记" scheme="http://blog.zhangjikai.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OpenMP" scheme="http://blog.zhangjikai.com/tags/OpenMP/"/>
    
  </entry>
  
  <entry>
    <title>【应用】在线文件管理</title>
    <link href="http://blog.zhangjikai.com/2016/02/01/%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91%E5%9C%A8%E7%BA%BF%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>http://blog.zhangjikai.com/2016/02/01/【应用】在线文件管理/</id>
    <published>2016-02-01T02:51:30.000Z</published>
    <updated>2019-09-08T06:53:07.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该应用主要目的是为了在使用linux系统的时候，实现手机和电脑之间的文件传输。前台界面使用的是<a href="https://github.com/joni2back/angular-filemanager" target="_blank" rel="noopener">angular-filemanager</a>, 后台使用的是Spring MVC， 可以下载<a href="https://github.com/zhangjikai/FileManager/releases" target="_blank" rel="noopener">该应用的war包</a>， 放到tomcat中使用。程序对angular-filemanager的原始功能进行了精简， 同时做了一些更改。下面该应用的具体功能：</p><ul><li>文件上传下载（上传使用的是<a href="https://github.com/hayageek/jquery-upload-file" target="_blank" rel="noopener">jquery-upload-file</a>）</li><li>手机扫码快速打开网页</li><li>图片预览</li><li>文本文件在线编辑</li><li>文件/文件夹重名</li><li>文件/文件夹删除</li></ul><a id="more"></a><p>下面是该应用的一些截图<br><img src="/images/filemanager/01.jpg" alt="主界面">  </p><p><img src="/images/filemanager/02.jpg" alt="文件上传"> </p><p><img src="/images/filemanager/03.jpg" alt="文件上传完成">  </p><p><img src="/images/filemanager/04.jpg" alt="二维码">  </p><p><img src="/images/filemanager/05.jpg" alt="手机端"></p><h2 id="前台"><a href="#前台" class="headerlink" title="前台"></a>前台</h2><p>前台使用的是使用angularjs + bootstrap写的一个在线文件管理系统， <a href="https://github.com/joni2back/angular-filemanager" target="_blank" rel="noopener">这里</a>是github地址， 后台作者已经给出了php和servlet的实现， 之所以使用Spring MVC重写后台，主要是为了熟悉一下Spring MVC， 同时精简了该管理系统的一些功能，因为主要目的是在linux系统下为手机和电脑之间的文件传输提供一个中介，当然也可以在windows系统下使用，也可以将该应用作为一个局域网中的一个文件共享系统。下面主要介绍在更改界面时的遇到的一些问题。</p><h3 id="Jquery-upload-file"><a href="#Jquery-upload-file" class="headerlink" title="Jquery-upload-file"></a>Jquery-upload-file</h3><p>进行文件上传的插件有很多，比如<a href="https://github.com/kartik-v/bootstrap-fileinput" target="_blank" rel="noopener">bootstrap-fileinput</a> 和 <a href="https://github.com/blueimp/jQuery-File-Upload" target="_blank" rel="noopener">jQuery-File-Upload</a>，不过这里使用的是<a href="https://github.com/hayageek/jquery-upload-file" target="_blank" rel="noopener">jquery-upload-file</a>，因为感觉比上面两种更加简单，下面是一个使用示例：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>jquery-upload-file demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"http://7xqp2l.com1.z0.glb.clouddn.com/uploadfile.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://7xqp2l.com1.z0.glb.clouddn.com/jquery-1.11.2.min.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://7xqp2l.com1.z0.glb.clouddn.com/jquery.uploadfile.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#content</span> &#123;</span></span><br><span class="line">            width: 600px;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.ajax-file-upload-filename</span> &#123;</span></span><br><span class="line">            width: 590px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"fileuploader"</span>&gt;</span>Upload<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"extrabutton"</span> <span class="attr">class</span>=<span class="string">"ajax-file-upload-green"</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> extraObj = $(<span class="string">"#fileuploader"</span>).uploadFile(&#123;</span></span><br><span class="line"><span class="actionscript">            url: <span class="string">"uploadFile"</span>,</span></span><br><span class="line"><span class="actionscript">            fileName: <span class="string">"file"</span>,</span></span><br><span class="line"><span class="actionscript">            showFileSize: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">            showDelete: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">            autoSubmit: <span class="literal">false</span>,</span></span><br><span class="line">            statusBarWidth: 590,</span><br><span class="line">            dragdropWidth: 590,</span><br><span class="line">            dragdropHeight: 200,</span><br><span class="line"><span class="actionscript">            uploadStr: <span class="string">"选择"</span>,</span></span><br><span class="line"><span class="actionscript">            cancelStr: <span class="string">"取消"</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="string">"abortStr"</span>: <span class="string">"终止"</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="string">"deleteStr"</span>: <span class="string">"删除"</span>,</span></span><br><span class="line"><span class="actionscript">            dynamicFormData: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> data = &#123;<span class="string">"param"</span>: <span class="string">""</span>&#125;;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> data;</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            onSuccess: <span class="function"><span class="keyword">function</span> <span class="params">(files, data, xhr, pd)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> obj = <span class="built_in">eval</span>(data);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(obj);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line"><span class="javascript">        $(<span class="string">"#extrabutton"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            extraObj.startUpload();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>下面是效果<br><img src="/images/filemanager/06.jpg" alt></p><p><a href="http://zhangjikai.com/demo/jquery.upload.file/index.html" target="_blank" rel="noopener">在线演示(只是界面)</a><br>下面说几个选项：</p><ul><li><code>url</code> - 文件上传地址，相当于<code>&lt;form&gt;</code>的<code>action</code>属性</li><li><code>fileName</code> - 文件上传的<code>name</code>属性，相当于<code>&lt;input type=&#39;file&#39; name=&#39;file&#39;&gt;</code>中的<code>name</code></li><li><code>dynamicFormData</code> - 提供动态的表单数据，格式为<code>{&quot;key&quot;: &quot;value&quot;}</code></li><li><code>onSuccess</code> - 文件上传成功的回调函数</li></ul><p>更多的选项和参数可以参考<a href="http://hayageek.com/docs/jquery-upload-file.php#doc" target="_blank" rel="noopener">官方文档</a></p><h3 id="Angularjs-集成-jquery-upload-file"><a href="#Angularjs-集成-jquery-upload-file" class="headerlink" title="Angularjs 集成 jquery-upload-file"></a>Angularjs 集成 jquery-upload-file</h3><p>我们使用jquery-upload-file插件代替了系统中原来的上传界面，关于angularjs和jquery插件的整合可以参考<a href="http://www.cnblogs.com/lenniu/p/3207556.html" target="_blank" rel="noopener">Angularjs集成第三方js插件之Uploadify</a>，下面说明如何讲angularjs和jquery-upload-file整合</p><h4 id="在angularjs中配置jquery-upload-file的directive"><a href="#在angularjs中配置jquery-upload-file的directive" class="headerlink" title="在angularjs中配置jquery-upload-file的directive"></a>在angularjs中配置jquery-upload-file的directive</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">app.directive(<span class="string">"jqueryUpload"</span>, [<span class="string">"fileNavigator"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">fileNavigator</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">           <span class="built_in">require</span>: <span class="string">'?ngModel'</span>,</span><br><span class="line">           restrict: <span class="string">'A'</span>,</span><br><span class="line">           link: <span class="function"><span class="keyword">function</span> (<span class="params">$scope, element, attrs, ngModel</span>) </span>&#123;</span><br><span class="line">               extraObj = $(element).uploadFile(&#123;</span><br><span class="line">                   url: <span class="string">"uploadFile"</span>,</span><br><span class="line">                   fileName: <span class="string">"file"</span>,</span><br><span class="line">                   showFileSize: <span class="literal">true</span>,</span><br><span class="line">                   showDelete: <span class="literal">true</span>,</span><br><span class="line">                   autoSubmit: <span class="literal">false</span>,</span><br><span class="line">                   statusBarWidth: <span class="string">"auto"</span>,</span><br><span class="line">                   dragdropWidth: <span class="string">"auto"</span>,</span><br><span class="line">                   dragdropHeight: <span class="number">200</span>,</span><br><span class="line">                   uploadStr: <span class="string">"选择"</span>,</span><br><span class="line">                   cancelStr: <span class="string">"取消"</span>,</span><br><span class="line">                   <span class="string">"abortStr"</span>: <span class="string">"终止"</span>,</span><br><span class="line">                   <span class="string">"deleteStr"</span>: <span class="string">"删除"</span>,</span><br><span class="line">                   dynamicFormData: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                       <span class="keyword">var</span> data = &#123;<span class="string">"path"</span>: $scope.fileNavigator.currentPath.join(<span class="string">'/'</span>)&#125;;</span><br><span class="line">                       <span class="keyword">return</span> data;</span><br><span class="line">                   &#125;,</span><br><span class="line">                   onSuccess: <span class="function"><span class="keyword">function</span> (<span class="params">files, data, xhr, pd</span>) </span>&#123;</span><br><span class="line">                       <span class="keyword">var</span> obj = <span class="built_in">eval</span>(data);</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">if</span> (obj.success) &#123;</span><br><span class="line">                           $scope.fileNavigator.refresh();</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           pd.progressDiv.hide();</span><br><span class="line">                           pd.statusbar.append(<span class="string">"&lt;span class='ajax-file-upload-error'&gt;ERROR: "</span> + obj.error + <span class="string">"&lt;/span&gt;"</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;]);</span><br></pre></td></tr></table></figure><p>其中<code>[&quot;fileNavigator&quot;, function (fileNavigator)</code>表示将fileNavigator注入进来以便使用。<code>extraObj</code>是预定义的一个全局变量，因为实在没有搞清楚angularjs的全局变量如何定义使用，所以直接在index.html中定义了该变量<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> extraObj;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="使用directive"><a href="#使用directive" class="headerlink" title="使用directive"></a>使用directive</h4><p>定义好了directive之后，使用十分简单，如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;fileuploader&quot; jquery-upload=&quot;&quot; &gt;选择&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>其中<code>jquery-upload</code>和directive中的<code>jqueryUpload</code>相对应。</p><h3 id="Bootstrap-弹出框"><a href="#Bootstrap-弹出框" class="headerlink" title="Bootstrap 弹出框"></a>Bootstrap 弹出框</h3><p>bootstrap对弹出框进行了封装，使用起来十分方便，下面是一个使用示例：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>bootstrap modal demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"http://7xqp2l.com1.z0.glb.clouddn.com/bootstrap-v3.3.4-bootstrap.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://7xqp2l.com1.z0.glb.clouddn.com/jquery-1.11.2.min.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://7xqp2l.com1.z0.glb.clouddn.com/bootstrap-v3.3.4-bootstrap.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-primary btn-lg"</span> <span class="attr">data-toggle</span>=<span class="string">"modal"</span> <span class="attr">data-target</span>=<span class="string">"#myModal"</span>&gt;</span>通过data-target打开弹窗<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-primary btn-lg"</span> <span class="attr">onclick</span>=<span class="string">"openDialog();"</span>&gt;</span>通过js打开弹窗<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal fade"</span> <span class="attr">id</span>=<span class="string">"myModal"</span> <span class="attr">tabindex</span>=<span class="string">"-1"</span> <span class="attr">role</span>=<span class="string">"dialog"</span> <span class="attr">aria-labelledby</span>=<span class="string">"myModalLabel"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-dialog"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-content"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-header"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"close"</span> <span class="attr">data-dismiss</span>=<span class="string">"modal"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span>&amp;times;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"modal-title"</span> <span class="attr">id</span>=<span class="string">"myModalLabel"</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-body"</span>&gt;</span>这里是内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-footer"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span> <span class="attr">data-dismiss</span>=<span class="string">"modal"</span>&gt;</span>关闭<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- /.modal-content --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- /.modal --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">openDialog</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">'#myModal'</span>).modal();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>有两种方式可以操作弹窗</p><ul><li>指定data-target属性</li><li>使用javascript控制</li></ul><p>上面代码演示了这两种方式，<a href="http://zhangjikai.com/demo/bootstrap/modal.html" target="_blank" rel="noopener">在线演示</a></p><h3 id="Jquery生成二维码"><a href="#Jquery生成二维码" class="headerlink" title="Jquery生成二维码"></a>Jquery生成二维码</h3><p>二维码生成插件使用的jquery-qrcode，<a href="https://github.com/jeromeetienne/jquery-qrcode" target="_blank" rel="noopener">这里</a>是github地址，下面是一个示例代码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>jquery 二维码生成插件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://7xqp2l.com1.z0.glb.clouddn.com/jquery-1.11.2.min.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://7xqp2l.com1.z0.glb.clouddn.com/jquery.qrcode.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#qrcode1</span>&#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">            margin-right: 20px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-id">#qrcode2</span>&#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"qrcode1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"qrcode2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">'#qrcode1'</span>).qrcode(<span class="string">"http://zhangjikai.com"</span>);</span></span><br><span class="line"><span class="javascript">    $(<span class="string">'#qrcode2'</span>).qrcode(&#123;<span class="attr">width</span>: <span class="number">128</span>,<span class="attr">height</span>: <span class="number">128</span>,<span class="attr">text</span>: <span class="string">"http://zhangjikai.com"</span>&#125;);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="Jquery-动态操作DOM元素"><a href="#Jquery-动态操作DOM元素" class="headerlink" title="Jquery 动态操作DOM元素"></a>Jquery 动态操作DOM元素</h3><p>下面是一个示例<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>jquery-upload-file demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://7xqp2l.com1.z0.glb.clouddn.com/jquery-1.11.2.min.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#content</span> &#123;</span></span><br><span class="line">            width: 600px;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.red_color</span>&#123;</span></span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> content = $(<span class="string">"#content"</span>);</span></span><br><span class="line"><span class="javascript">    $(<span class="string">"&lt;h1 /&gt;"</span>, &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="string">"text"</span>:<span class="string">"Hello World"</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">"class"</span> : <span class="string">"red_color"</span></span></span><br><span class="line">    &#125;).appendTo(content);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> ulObj = $(<span class="string">"&lt;ul /&gt;"</span>,&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="string">"id"</span> : <span class="string">"ulObj"</span></span></span><br><span class="line">    &#125;).appendTo(content);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">"&lt;li /&gt;"</span>, &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="string">"text"</span> : <span class="string">"这是项目"</span> + i</span></span><br><span class="line">        &#125;).appendTo(ulObj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> btnObj = $(<span class="string">"&lt;button /&gt;"</span>, &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="string">"text"</span> : <span class="string">"点我删除列表"</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">"id"</span> : <span class="string">"btnObj"</span></span></span><br><span class="line">    &#125;).appendTo(content);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    $(<span class="string">"#btnObj"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">"#ulObj"</span>).remove();</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><a href="http://zhangjikai.com/demo/jquery/operate_dom.html" target="_blank" rel="noopener">在线演示</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;该应用主要目的是为了在使用linux系统的时候，实现手机和电脑之间的文件传输。前台界面使用的是&lt;a href=&quot;https://github.com/joni2back/angular-filemanager&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;angular-filemanager&lt;/a&gt;, 后台使用的是Spring MVC， 可以下载&lt;a href=&quot;https://github.com/zhangjikai/FileManager/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;该应用的war包&lt;/a&gt;， 放到tomcat中使用。程序对angular-filemanager的原始功能进行了精简， 同时做了一些更改。下面该应用的具体功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件上传下载（上传使用的是&lt;a href=&quot;https://github.com/hayageek/jquery-upload-file&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jquery-upload-file&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;手机扫码快速打开网页&lt;/li&gt;
&lt;li&gt;图片预览&lt;/li&gt;
&lt;li&gt;文本文件在线编辑&lt;/li&gt;
&lt;li&gt;文件/文件夹重名&lt;/li&gt;
&lt;li&gt;文件/文件夹删除&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="应用" scheme="http://blog.zhangjikai.com/categories/%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="应用" scheme="http://blog.zhangjikai.com/tags/%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>【OpenMP学习笔记】编译制导指令</title>
    <link href="http://blog.zhangjikai.com/2016/01/25/%E3%80%90OpenMP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%BC%96%E8%AF%91%E5%88%B6%E5%AF%BC%E6%8C%87%E4%BB%A4/"/>
    <id>http://blog.zhangjikai.com/2016/01/25/【OpenMP学习笔记】编译制导指令/</id>
    <published>2016-01-25T07:30:39.000Z</published>
    <updated>2019-09-08T06:53:07.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>OpenMP通过在串行程序中插入编译制导指令, 来实现并行化, 支持OpenMP的编译器可以识别, 处理这些指令并实现对应的功能. 所有的编译制导指令都是以<code>#pragma omp</code>开始, 后面跟具体的功能指令(directive)或者命令.  一般格式如下所示:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp directive [clause [[,] clause]...]</span></span><br><span class="line">    structured block</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="Parallel-Construct-并行域结构"><a href="#Parallel-Construct-并行域结构" class="headerlink" title="Parallel Construct(并行域结构)"></a>Parallel Construct(并行域结构)</h2><p>为了使程序可以并行执行, 我们首先要构造一个并行域(parallel region), 在这里我们使用<code>parallel</code>指令来实现并行域的构造, 其语法形式如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel  [clause [[,] clause]...]</span></span><br><span class="line">     structured block</span><br></pre></td></tr></table></figure></p><p>我们看到其实就是在omp后面加了一个<code>parallel</code>关键字, 该指令主要作用就是用来构造并行域, 创建线程组并且并发执行任务. 需要注意的是该指令只保证代码以并行的方式执行, 但是并不负责线程之间的任务分发. 在并行域执行结束之后, 会有一个隐式的屏障(barrier), 来同步所有的该区域内的所有线程. 下面是一个使用示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Hello from thread %d\n"</span>, omp_get_thread_num());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中<code>omp_get_thread_num()</code>用来获取当前线程的编号, 该函数是定义在<code>&lt;omp.h&gt;</code>中的. 输出结果如下:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello from thread 1</span><br><span class="line">Hello from thread 3</span><br><span class="line">Hello from thread 0</span><br><span class="line">Hello from thread 2</span><br></pre></td></tr></table></figure></p><p>parallel指令后面可以跟一些子句(clause), 如下所示<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if(scalar-expression)</span><br><span class="line"></span><br><span class="line">num_threads(integer-expression)</span><br><span class="line"></span><br><span class="line">private(list)</span><br><span class="line"></span><br><span class="line">firstprivate(list)</span><br><span class="line"></span><br><span class="line">shared(list)</span><br><span class="line"></span><br><span class="line">default(none | shared)</span><br><span class="line"></span><br><span class="line">copyin(list)</span><br><span class="line"></span><br><span class="line">reduction(operator:list)</span><br></pre></td></tr></table></figure></p><p>在后面会介绍这些从句的用法</p><h2 id="Work-sharing-Construct-任务分担结构"><a href="#Work-sharing-Construct-任务分担结构" class="headerlink" title="Work-sharing Construct(任务分担结构)"></a>Work-sharing Construct(任务分担结构)</h2><p>任务分担指令主要用于为线程分配不同的任务, 一个任务分担域(work-sharing region)必须要和一个活跃(active)的并行域(parellel region)关联, 如果任务分担指令处于一个不活跃的并行域或者处于一个串行域中, 那么该指令就会被忽略. 在C/C++有3个任务分担指令: for、sections、single, 严格意义上讲只有for和sections是任务分担指令, 而single只是协助任务分担的指令.</p><p><img src="/images/openmp/work-share-directive.png" alt></p><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>用于for循环中, 将不同的循环分配给不同的线程, 语法如下所示:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp for [clause[[,] clause]...]</span></span><br><span class="line">    <span class="keyword">for</span>-loop</span><br></pre></td></tr></table></figure></p><p>下面是一个使用示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_for</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel shared(n) private(i) </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Thread %d executes loop iteration %d\n"</span>, omp_get_thread_num(),i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是程序执行结果<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread 2 executes loop iteration 5</span><br><span class="line">Thread 2 executes loop iteration 6</span><br><span class="line">Thread 3 executes loop iteration 7</span><br><span class="line">Thread 3 executes loop iteration 8</span><br><span class="line">Thread 0 executes loop iteration 0</span><br><span class="line">Thread 0 executes loop iteration 1</span><br><span class="line">Thread 0 executes loop iteration 2</span><br><span class="line">Thread 1 executes loop iteration 3</span><br><span class="line">Thread 1 executes loop iteration 4</span><br></pre></td></tr></table></figure></p><p>在上面的程序中共有4个线程执行9次循环, 线程0分到了3次, 剩余的线程分到了2次,  这是一种常用的调度方式, 即假设有n次循环迭代, t个线程, 那么每个线程分配到n/t 或者 n/t + 1 次<strong>连续</strong>的迭代计算, 但是某些情况下使用这种方式并不是最好的选择, 我们可以使用<code>schedule</code> 来指定调度方式, 在后面会具体介绍. 下面是for 指令后面可以跟的一些子句:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private(list)</span><br><span class="line"></span><br><span class="line">fistprivate(list)</span><br><span class="line"></span><br><span class="line">lastprivate(list)</span><br><span class="line"></span><br><span class="line">reduction(operator:list)</span><br><span class="line"></span><br><span class="line">ordered</span><br><span class="line"></span><br><span class="line">schedule(kind[,chunk_size])</span><br><span class="line"></span><br><span class="line">nowait</span><br></pre></td></tr></table></figure></p><h3 id="sections"><a href="#sections" class="headerlink" title="sections"></a>sections</h3><p>sections指令可以为不同的线程分配不同的任务, 语法如下所示:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp sections [clause[[,] clause]...] </span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">#<span class="meta-keyword">pragma</span> omp section]</span></span><br><span class="line">            structured block</span><br><span class="line">        [<span class="meta">#<span class="meta-keyword">pragma</span> omp section]</span></span><br><span class="line">            structured block</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>从上面的代码中我们可以看到, sections将代码分为多个section, 每个线程处理一个section, 下面是一个使用示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用#pragma omp sections 和 #pragma omp section, 来使不同的线程执行不同的任务</span></span><br><span class="line"><span class="comment"> * 如果线程数量大于section数量, 那么多余的线程会处于空闲状态(idle)</span></span><br><span class="line"><span class="comment"> * 如果线程数量少于section数量, 那么一个线程会执行多个section代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In funcA: this section is executed by thread %d\n"</span>,</span><br><span class="line">            omp_get_thread_num());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In funcB: this section is executed by thread %d\n"</span>,</span><br><span class="line">            omp_get_thread_num());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_section</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp sections</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> omp section </span></span><br><span class="line">            &#123;</span><br><span class="line">                (<span class="keyword">void</span>)funcA();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> omp section </span></span><br><span class="line">            &#123;</span><br><span class="line">                (<span class="keyword">void</span>)funcB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是执行结果:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In funcA: this section is executed by thread 3</span><br><span class="line">In funcB: this section is executed by thread 0</span><br></pre></td></tr></table></figure></p><p>下面是sections后面可以跟的一些子句<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private(list)</span><br><span class="line"></span><br><span class="line">firstprivate(list)</span><br><span class="line"></span><br><span class="line">lastprivate(list)</span><br><span class="line"></span><br><span class="line">reduction(operator:list)</span><br><span class="line"></span><br><span class="line">nowait</span><br></pre></td></tr></table></figure></p><h3 id="single"><a href="#single" class="headerlink" title="single"></a>single</h3><p>single 指令用来指定某段代码块只能被一个线程来执行, 如果没有nowait字句, 所有线程在 single 指令结束处隐市同步点同步, 如果single指令有nowait从句, 则别的线程直接往下执行. 不过single指令并不指定哪个线程来执行. 语法如下所示:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp single [clause[[,] clause]...]</span></span><br><span class="line">    structured block</span><br></pre></td></tr></table></figure></p><p>下面是一个使用示例<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_single</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, n = <span class="number">10</span>, i;</span><br><span class="line">    <span class="keyword">int</span> b[n];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel shared(a, b) private(i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 只有一个线程会执行这段代码, 其他线程会等待该线程执行完毕</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp single </span></span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Single construct executed by thread %d\n"</span>, omp_get_thread_num());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A barrier is automatically inserted here</span></span><br><span class="line">        </span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            b[i] = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After the parallel region:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"b[%d] = %d\n"</span>,i,b[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是执行结果:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Single construct executed by thread 2</span><br><span class="line">After the parallel region:</span><br><span class="line">b[0] = 10</span><br><span class="line">b[1] = 10</span><br><span class="line">b[2] = 10</span><br><span class="line">b[3] = 10</span><br><span class="line">b[4] = 10</span><br><span class="line">b[5] = 10</span><br><span class="line">b[6] = 10</span><br><span class="line">b[7] = 10</span><br><span class="line">b[8] = 10</span><br><span class="line">b[9] = 10</span><br></pre></td></tr></table></figure></p><p>下面是single指令后面可以跟随的子句:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private(list)</span><br><span class="line"></span><br><span class="line">firstprivate(list)</span><br><span class="line"></span><br><span class="line">copyprivate(list)</span><br><span class="line"></span><br><span class="line">nowait</span><br></pre></td></tr></table></figure></p><h3 id="Combined-Parallel-Work-Sharing-Constructs"><a href="#Combined-Parallel-Work-Sharing-Constructs" class="headerlink" title="Combined Parallel Work-Sharing Constructs"></a>Combined Parallel Work-Sharing Constructs</h3><p>将parallel指令和work-sharing指令结合起来, 使代码更加简洁. 如下面的代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line">    <span class="keyword">for</span>(.....)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以写为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span>(.....)</span><br></pre></td></tr></table></figure></p><p>具体的参见下图:<br><img src="/images/openmp/combined-parallel.png" alt><br>使用这些组合结构体(combined constructs)不仅增加程序的可读性, 而且对程序的性能有一定的帮助. 当使用这些组合结构体的时候, 编译器可以知道下一步要做什么, 从而可能会生成更高效的代码.</p><h2 id="Clauses-to-Control-Parallel-and-Work-Sharing-Constructs"><a href="#Clauses-to-Control-Parallel-and-Work-Sharing-Constructs" class="headerlink" title="Clauses to Control Parallel and Work-Sharing Constructs"></a>Clauses to Control Parallel and Work-Sharing Constructs</h2><p>OpenMP指令后面可以跟一些子句, 用来控制构造器的行为. 下面介绍一些常用的子句.</p><h3 id="shared"><a href="#shared" class="headerlink" title="shared"></a>shared</h3><p>shared子句用来指定哪些数据是在线程之间共享的, 语法形式为<code>shared(list)</code>, 下面是其使用方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for shared(a)</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] += i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在并行域中使用共享变量时, 如果存在写操作, 需要对共享变量加以保存, 因为可能存在多个线程同时修改共享变量或者在一个线程读取共享变量时另外一个变量在更新共享变量的情况, 而这些情况都可能会引起程序错误. </p><h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>private子句用来指定哪些数据是线程私有的, 即每个线程具有变量的私有副本, 线程之间互不影响. 其语法形式为<code>private(list)</code>, 使用方法如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_private</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">2</span>, a = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// i,a 定义为private之后不改变原先的值</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for private(i, a)</span></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a = i+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"In for: thread %d has a value of a = %d for i = %d\n"</span>, omp_get_thread_num(),a,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Out for: thread %d has a value of a = %d for i = %d\n"</span>, omp_get_thread_num(),a,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是程序运行结果:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In for: thread 2 has a value of a = 5 for i = 4</span><br><span class="line">In for: thread 2 has a value of a = 6 for i = 5</span><br><span class="line">In for: thread 3 has a value of a = 7 for i = 6</span><br><span class="line">In for: thread 3 has a value of a = 8 for i = 7</span><br><span class="line">In for: thread 0 has a value of a = 1 for i = 0</span><br><span class="line">In for: thread 0 has a value of a = 2 for i = 1</span><br><span class="line">In for: thread 1 has a value of a = 3 for i = 2</span><br><span class="line">In for: thread 1 has a value of a = 4 for i = 3</span><br><span class="line"></span><br><span class="line">Out for: thread 0 has a value of a = 3 for i = 2</span><br></pre></td></tr></table></figure></p><p>对于private子句中的变量, 需要注意一下两点:</p><ul><li>不论该变量之前有没有初始值, 在进入并行域之后都是未初始化的.</li><li>并行域中对变量的修改只在该域中起作用, 当离开并行域后, 变量值仍然是未进入并行域之前的值</li></ul><h3 id="lastprivate"><a href="#lastprivate" class="headerlink" title="lastprivate"></a>lastprivate</h3><p>lastprivate会在退出并行域时, 将其修饰变量的最后取值(last value)保存下来, 可以作用于 <code>for</code> 和 <code>sections</code>, 语法格式为<code>lastprivate(list)</code>. 关于last value的定义: 如果是作用于for指令, 那么last value就是指串行执行的最后一次循环的值；如果是作用于sections指令, 那么last value就是执行完最后一个包含该变量的section之后的值. 使用方法如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_last_private</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">2</span>, a = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// lastprivate 将for中最后一次循环(i == n-1) a 的值赋给a    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for private(i) lastprivate(a)</span></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a = i+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"In for: thread %d has a value of a = %d for i = %d\n"</span>, omp_get_thread_num(),a,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Out for: thread %d has a value of a = %d for i = %d\n"</span>, omp_get_thread_num(),a,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序执行结果为:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In for: thread 3 has a value of a = 7 for i = 6</span><br><span class="line">In for: thread 3 has a value of a = 8 for i = 7</span><br><span class="line">In for: thread 2 has a value of a = 5 for i = 4</span><br><span class="line">In for: thread 2 has a value of a = 6 for i = 5</span><br><span class="line">In for: thread 1 has a value of a = 3 for i = 2</span><br><span class="line">In for: thread 0 has a value of a = 1 for i = 0</span><br><span class="line">In for: thread 0 has a value of a = 2 for i = 1</span><br><span class="line">In for: thread 1 has a value of a = 4 for i = 3</span><br><span class="line"></span><br><span class="line">Out for: thread 0 has a value of a = 8 for i = 2</span><br></pre></td></tr></table></figure></p><h3 id="firstprivate"><a href="#firstprivate" class="headerlink" title="firstprivate"></a>firstprivate</h3><p>firstprivate 子句用于为private变量提供初始值. 使用firstprivate修饰的变量会使用在前面定义的同名变量的值作为其初始值. 语法形式为<code>firstprivate(list)</code>, 使用方法如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_first_private</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, a[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n ;i++) &#123;</span><br><span class="line">        a[i] = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for private(i) firstprivate(a)</span></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread %d: a[%d] is %d\n"</span>, omp_get_thread_num(), i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果如下:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">thread 0: a[0] is 1</span><br><span class="line">thread 0: a[1] is 2</span><br><span class="line">thread 2: a[4] is 5</span><br><span class="line">thread 2: a[5] is 6</span><br><span class="line">thread 3: a[6] is 7</span><br><span class="line">thread 3: a[7] is 8</span><br><span class="line">thread 1: a[2] is 3</span><br><span class="line">thread 1: a[3] is 4</span><br></pre></td></tr></table></figure></p><h3 id="default"><a href="#default" class="headerlink" title="default"></a>default</h3><p>default子句用于设置变量默认的data-sharing属性, 在C/C++中只支持<code>default(none | shared)</code>, 其中<code>default(shared)</code>设置所有的变量默认为共享的, <code>default(none)</code>取消变量的默认属性, 需要显示指定变量是共享的还是私有的.</p><h3 id="nowait"><a href="#nowait" class="headerlink" title="nowait"></a>nowait</h3><p>用于取消任务分担结构(work-sharing constructs)中的隐式屏障(implicit barrier), 下面是一个使用示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_nowait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, n =<span class="number">6</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp for nowait </span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"thread %d: ++++\n"</span>, omp_get_thread_num());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"thread %d: ----\n"</span>, omp_get_thread_num());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果第一个 for 后面没有加 nowait , 那么输出如下所示:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">thread 3: ++++</span><br><span class="line">thread 0: ++++</span><br><span class="line">thread 0: ++++</span><br><span class="line">thread 2: ++++</span><br><span class="line">thread 1: ++++</span><br><span class="line">thread 1: ++++</span><br><span class="line">thread 0: ----</span><br><span class="line">thread 0: ----</span><br><span class="line">thread 3: ----</span><br><span class="line">thread 1: ----</span><br><span class="line">thread 1: ----</span><br><span class="line">thread 2: ----</span><br></pre></td></tr></table></figure></p><p>因为for指令有一个隐式的屏障, 会同步所有的线程直到第一个for循环执行完, 再继续往下执行. 加上 nowait 之后就消除了这个屏障, 使线程执行完第一个for循环之后无需再等待其他线程就可以去执行第二个for循环的内容, 下面是加上nowait之后的输出:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">thread 2: ++++</span><br><span class="line">thread 2: ----</span><br><span class="line">thread 1: ++++</span><br><span class="line">thread 1: ++++</span><br><span class="line">thread 1: ----</span><br><span class="line">thread 1: ----</span><br><span class="line">thread 3: ++++</span><br><span class="line">thread 3: ----</span><br><span class="line">thread 0: ++++</span><br><span class="line">thread 0: ++++</span><br><span class="line">thread 0: ----</span><br><span class="line">thread 0: ----</span><br></pre></td></tr></table></figure></p><p>使用nowait时需要注意前后for之间有没有依赖关系, 如果第二个for循环需要用到第一个for循环的结果, 那么使用nowait就可能会造成程序错误.</p><h3 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h3><p>schedule子句只作用于循环结构(loop construct), 它用来设置循环任务的调度方式. 语法形式为<code>schedule(kind[,chunk_size])</code>, 其中kind的取值有 <code>static</code>, <code>dynamic</code>, <code>guided</code>, <code>auto</code>, <code>runtime</code>, chunk_size是可选项,可以指定也可以不指定. 下面是使用方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_schedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, n = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for default(none) schedule(static, 2) \</span></span><br><span class="line">    <span class="keyword">private</span>(i) shared(n)</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Iteration %d executed by thread %d\n"</span>, i, omp_get_thread_num());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面介绍一下各个取值的含义, 假设有n次循环, t个线程<br><strong>static</strong><br>静态调度, 如果不指定chunk_size , 那么会为每个线程分配 n/t 或者 n/t+1(不能除尽)次连续的迭代计算, 如果指定了 chunk_size, 那么每次为线程分配chunk_size次迭代计算, 如果第一轮没有分配完, 则循环进行下一轮分配, 假设n=8, t=4, 下表给出了chunk_size未指定、等于1、等于3时的分配情况.</p><table><thead><tr><th style="text-align:center"><strong>线程编号\chunk_size</strong></th><th style="text-align:center"><strong>未指定</strong></th><th style="text-align:center"><strong>chunk_size = 1</strong></th><th style="text-align:center"><strong>chunk_size = 3</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>0</strong></td><td style="text-align:center">0 1</td><td style="text-align:center">0 4</td><td style="text-align:center">0 1 2</td></tr><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:center">2 3</td><td style="text-align:center">1 5</td><td style="text-align:center">3 4 5</td></tr><tr><td style="text-align:center"><strong>2</strong></td><td style="text-align:center">4 5</td><td style="text-align:center">2 6</td><td style="text-align:center">6 7</td></tr><tr><td style="text-align:center"><strong>3</strong></td><td style="text-align:center">6 7</td><td style="text-align:center">3 7</td><td style="text-align:center">　</td></tr></tbody></table><p><strong>dynamic</strong><br>动态调度, 动态为线程分配迭代计算, 只要线程空闲就为其分配任务, 计算快的线程分配到更多的迭代. 如果不指定chunk_size参数, 则每次为一个线程分配一次迭代循环(相当于chunk_size=1), 若指定chunk_size, 则每次为一个线程分配chunk_size次迭代循环. 在动态调度下, 分配结果是不固定的, 重复执行同一个程序, 每次的分配结果一般来说是不同的,  下面给出n=12, t=4时, chunk_size未指定、等于2时的分配情况(运行两次)</p><table><thead><tr><th style="text-align:center"><strong>线程编号\chunk_size</strong></th><th style="text-align:left"><strong>未指定(第一次)</strong></th><th style="text-align:left"><strong>未指定(第二次)</strong></th><th style="text-align:left"><strong>chunk_size=2(第一次)</strong></th><th style="text-align:left"><strong>chunk_size = 2(第二次)</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>0</strong></td><td style="text-align:left">2</td><td style="text-align:left">0</td><td style="text-align:left">4 5 8 9 10 11</td><td style="text-align:left">0 1</td></tr><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:left">0 4 5 6 7 8 9 10 11</td><td style="text-align:left">3</td><td style="text-align:left">0 1</td><td style="text-align:left">4 5</td></tr><tr><td style="text-align:center"><strong>2</strong></td><td style="text-align:left">3</td><td style="text-align:left">1 4 5 6 7 8 9 10 11</td><td style="text-align:left">2 3</td><td style="text-align:left">6 7</td></tr><tr><td style="text-align:center"><strong>3</strong></td><td style="text-align:left">1</td><td style="text-align:left">2</td><td style="text-align:left">6 7</td><td style="text-align:left">2 3 8 9 10 11</td></tr></tbody></table><p>使用动态动态可以一定程度减少负载不均衡的问题, 但是需要注意任务动态申请时也会有一定的开销.</p><p><strong>guided</strong><br>guided调度是一种指定性的启发式自调度方法. 开始时每个线程会分配到较大的迭代块, 之后分配到的迭代块的大小会逐渐递减. 如果指定chunk_size, 则迭代块会按指数级下降到指定的chunk_size大小, 如果没有指定size参数, 那么迭代块大小最小会降到1(相当于chunk_size=1). 和动态调度一样, 执行块的线程会分到更多的任务, 不同的是这里迭代块的大小是变化的. 同样使用guided调度的分配结果也不是固定的, 重复执行会得到不同的分配结果. 下面给出n=20, t=4, chunk_size未指定、chunk_size=3时的分配情况(执行两次)</p><table><thead><tr><th style="text-align:center"><strong>线程编号\chunk_size</strong></th><th style="text-align:left"><strong>未指定(第一次)</strong></th><th style="text-align:left"><strong>未指定(第二次)</strong></th><th style="text-align:left"><strong>chunk_size=3(第一次)</strong></th><th style="text-align:left"><strong>chunk_size = 3(第二次)</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>0</strong></td><td style="text-align:left">12 13</td><td style="text-align:left">0 1 2 3 4</td><td style="text-align:left">0 1 2 3 4</td><td style="text-align:left">5 6 7 8 　18 19</td></tr><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:left">5 6 7 8 　16 17　 18 19</td><td style="text-align:left">5 6 7 8</td><td style="text-align:left">9 10 11</td><td style="text-align:left">9 10 11</td></tr><tr><td style="text-align:center"><strong>2</strong></td><td style="text-align:left">0 1 2 3 4　 14 15</td><td style="text-align:left">9 10 11　 14 15 16　 17 18 19</td><td style="text-align:left">5 6 7 8  　15 16 17 　18 19</td><td style="text-align:left">0 1 2 3 4 　 15 16 17</td></tr><tr><td style="text-align:center"><strong>3</strong></td><td style="text-align:left">9 10 11</td><td style="text-align:left">12 13</td><td style="text-align:left">12 13 14</td><td style="text-align:left">12 13 14</td></tr></tbody></table><p>当设置chunk_size=3时, 因为最后只剩下18、19两次循环, 所以最后执行的那个线程只分配到2次循环.</p><p>下面的图展示了当循环次数为200次, 线程数量为4时, <strong>static</strong> 、 <strong>(dynamic,7)</strong> 、<strong>(guided, 7)</strong> 3种调度方式的分配情况<br><img src="/images/openmp/schedule.png" alt></p><p><strong>runtime</strong><br>运行时调度, 并不是一种真正的调度方式, 在运行时同时环境变量OMP_SCHEDULE来确定调度类型, 最终的调度类型仍为上面的3种调度方式之一. 在bash下可以使用下面的方式设置:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> OMP_SCHEDULE=<span class="string">"static"</span></span><br></pre></td></tr></table></figure></p><p><strong>auto</strong><br>将选择的权利赋予编译器, 让编译器自己选择合适的调度决策.</p><h4 id="负载不均衡"><a href="#负载不均衡" class="headerlink" title="负载不均衡"></a>负载不均衡</h4><p>在for循环中, 如果每次循环之间花费的时间是不同的, 那么就可能出现负载不均衡问题, 下面代码模拟一下这种情况,<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_schedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j, n = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> start, end;</span><br><span class="line">    GET_TIME(start);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for default(none) schedule(static) \</span></span><br><span class="line">    <span class="keyword">private</span>(i, j) shared(n)</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//printf("Iteration %d executed by thread %d\n", i, omp_get_thread_num());</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            system(<span class="string">"sleep 0.1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    GET_TIME(end);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"static   : use time %.2fs\n"</span>, end-start);</span><br><span class="line"></span><br><span class="line">    GET_TIME(start);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for default(none) schedule(static,2) \</span></span><br><span class="line">    <span class="keyword">private</span>(i, j) shared(n)</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            system(<span class="string">"sleep 0.1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    GET_TIME(end);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"static,2 : use time %.2fs\n"</span>, end-start);</span><br><span class="line"></span><br><span class="line">    GET_TIME(start);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for default(none) schedule(dynamic) \</span></span><br><span class="line">    <span class="keyword">private</span>(i, j) shared(n)</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            system(<span class="string">"sleep 0.1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    GET_TIME(end);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"dynamic  : use time %.2fs\n"</span>, end-start);</span><br><span class="line"></span><br><span class="line">    GET_TIME(start);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for default(none) schedule(dynamic, 2) \</span></span><br><span class="line">    <span class="keyword">private</span>(i, j) shared(n)</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            system(<span class="string">"sleep 0.1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    GET_TIME(end);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"dynamic,2: use time %.2fs\n"</span>, end-start);</span><br><span class="line"></span><br><span class="line">    GET_TIME(start);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for default(none) schedule(guided) \</span></span><br><span class="line">    <span class="keyword">private</span>(i, j) shared(n)</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            system(<span class="string">"sleep 0.1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    GET_TIME(end);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"guided   : use time %.2fs\n"</span>, end-start);</span><br><span class="line"></span><br><span class="line">    GET_TIME(start);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for default(none) schedule(guided, 2) \</span></span><br><span class="line">    <span class="keyword">private</span>(i, j) shared(n)</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            system(<span class="string">"sleep 0.1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    GET_TIME(end);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"guided,2 : use time %.2fs\n"</span>, end-start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>GET_TIME的定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TIMER_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TIMER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_TIME(now) &#123; \</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">t</span>;</span> \</span><br><span class="line">   gettimeofday(&amp;t, <span class="literal">NULL</span>); \</span><br><span class="line">   now = t.tv_sec + t.tv_usec/<span class="number">1000000.0</span>; \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>在上面的代码中, 对于第一个for循环, i越大, 循环消耗的时间越多, 下面是n=10时的输出<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static   : use time 1.74s</span><br><span class="line">static,2 : use time 1.84s</span><br><span class="line">dynamic  : use time 1.53s</span><br><span class="line">dynamic,2: use time 1.84s</span><br><span class="line">guided   : use time 1.63s</span><br><span class="line">guided,2 : use time 1.53s</span><br></pre></td></tr></table></figure></p><p>下面是n=20的输出<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static   : use time 8.67s</span><br><span class="line">static,2 : use time 6.42s</span><br><span class="line">dynamic  : use time 5.62s</span><br><span class="line">dynamic,2: use time 6.43s</span><br><span class="line">guided   : use time 5.92s</span><br><span class="line">guided,2 : use time 6.43s</span><br></pre></td></tr></table></figure></p><p>对于static调度, 如果不指定chunk_size的值, 则会将最后几次循环分给最后一个线程, 而最后几次循环是最耗时的, 其他线程执行完各自的工作需要等待这个线程执行完毕, 浪费了系统资源, 这就造成了负载不均衡. dynamic和guided可以在一定程度上减轻负载不均衡, 但是也不是绝对的, 最终选用哪种方式还是要根据具体的问题.</p><h2 id="Synchronization-Constructs-同步"><a href="#Synchronization-Constructs-同步" class="headerlink" title="Synchronization Constructs(同步)"></a>Synchronization Constructs(同步)</h2><p>同步指令主要用来控制多个线程之间对于共享变量的访问. 它可以保证线程以一定的顺序更新共享变量, 或者保证两个或多个线程不同时修改共享变量.</p><h3 id="barrier"><a href="#barrier" class="headerlink" title="barrier"></a>barrier</h3><p>同步路障(barrier), 当线程遇到路障时必须要停下等待, 直到并行区域中的所有线程都到达路障点, 线程才继续往下执行. 在每一个并行域和任务分担域的结束处都会有一个隐式的同步路障, 即在parallel、for、sections、single构造的区域之后会有一个隐式的路障, 因此在很多时候我们无需显示的插入路障. 下面是语法形式:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp barrier</span></span><br></pre></td></tr></table></figure></p><p>下面是一个使用示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_time</span><span class="params">(<span class="keyword">int</span> tid, <span class="keyword">char</span>* s )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[len];</span><br><span class="line">    NOW_TIME(buf, len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread %d %s at %s\n"</span>, tid, s, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_barrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel private(tid)</span></span><br><span class="line">    &#123;</span><br><span class="line">        tid = omp_get_thread_num();</span><br><span class="line">        <span class="keyword">if</span>(tid &lt; omp_get_num_threads() / <span class="number">2</span>)</span><br><span class="line">            system(<span class="string">"sleep 3"</span>);</span><br><span class="line">        print_time(tid, <span class="string">"before barrier "</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp barrier</span></span><br><span class="line"></span><br><span class="line">        print_time(tid, <span class="string">"after  barrier "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中NOW_TIME的定义如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TIMER_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TIMER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOW_TIME(buf, len) &#123; \</span></span><br><span class="line">    <span class="keyword">time_t</span> nowtime; \</span><br><span class="line">    nowtime = time(<span class="literal">NULL</span>); \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">local</span>;</span> \</span><br><span class="line">    local = localtime(&amp;nowtime); \</span><br><span class="line">    strftime(buf, len, <span class="string">"%H:%M:%S"</span>, local); \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>在上面的代码中有一半的线程(tid &lt; 2) 会睡眠3秒之后再继续往下执行, 首先看看不加路障的输出, 即去掉<code>#pragma omp barrier</code><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread 3 before barrier  at 16:55:44</span><br><span class="line">Thread 2 before barrier  at 16:55:44</span><br><span class="line">Thread 3 after  barrier  at 16:55:44</span><br><span class="line">Thread 2 after  barrier  at 16:55:44</span><br><span class="line">Thread 1 before barrier  at 16:55:47</span><br><span class="line">Thread 0 before barrier  at 16:55:47</span><br><span class="line">Thread 0 after  barrier  at 16:55:47</span><br><span class="line">Thread 1 after  barrier  at 16:55:47</span><br></pre></td></tr></table></figure></p><p>下面上加上路障的输出结果:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread 3 before barrier  at 17:05:29</span><br><span class="line">Thread 2 before barrier  at 17:05:29</span><br><span class="line">Thread 0 before barrier  at 17:05:32</span><br><span class="line">Thread 1 before barrier  at 17:05:32</span><br><span class="line">Thread 0 after  barrier  at 17:05:32</span><br><span class="line">Thread 1 after  barrier  at 17:05:32</span><br><span class="line">Thread 2 after  barrier  at 17:05:32</span><br><span class="line">Thread 3 after  barrier  at 17:05:32</span><br></pre></td></tr></table></figure></p><p>通过对比我们可以看出, 加上路障之后, 各线程要在路障点同步一次, 然后再继续往下执行.</p><h3 id="ordered"><a href="#ordered" class="headerlink" title="ordered"></a>ordered</h3><p>ordered结构允许在并行域中以串行的顺序执行一段代码, 如果我们在并行域中想按照顺序打印被不同的线程计算的数据, 就可以使用这个子句, 下面是语法形式<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp ordered</span></span><br><span class="line">    structured block</span><br></pre></td></tr></table></figure></p><p>在使用时需要注意一下两点</p><ul><li>ordered 只作用于循环结构(loop construct)</li><li>使用ordered时需要在构造并行域的时候加上ordered子句, 如下面所示<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for ordered</span></span><br></pre></td></tr></table></figure></li></ul><p>下面是一个使用示例<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, tid, n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for default(none) ordered  schedule(dynamic) \</span></span><br><span class="line">    <span class="keyword">private</span> (i, tid) shared(n, a)</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        tid = omp_get_thread_num();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Thread %d updates a[%d]\n"</span>, tid, i);</span><br><span class="line"></span><br><span class="line">        a[i] += i;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp ordered</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Thread %d printf value of a[%d] = %d\n"</span>, tid, i, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是程序运行结果:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread 0 updates a[0]</span><br><span class="line">Thread 2 updates a[2]</span><br><span class="line">Thread 1 updates a[3]</span><br><span class="line">Thread 0 printf value of a[0] = 0</span><br><span class="line">Thread 0 updates a[4]</span><br><span class="line">Thread 3 updates a[1]</span><br><span class="line">Thread 3 printf value of a[1] = 1</span><br><span class="line">Thread 2 printf value of a[2] = 2</span><br><span class="line">Thread 1 printf value of a[3] = 3</span><br><span class="line">Thread 0 printf value of a[4] = 4</span><br></pre></td></tr></table></figure></p><p>从输出结果我们可以看到, 在update时是以乱序的顺序更新, 但是在打印时是以串行顺序的形式打印.</p><h3 id="critical"><a href="#critical" class="headerlink" title="critical"></a>critical</h3><p>临界区(critical), 临界区保证在任意一个时间段内只有一个线程执行该区域中的代码, 一个线程要进入临界区必须要等待临界区处于空闲状态, 下面是语法形式<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp critical [(name)]</span></span><br><span class="line">    structured block</span><br></pre></td></tr></table></figure></p><p>其中name是为临界区指定的一个名字. 下面是一个求和的使用示例, 注意这里只是用来说明临界区的作用, 对于求和操作我们可以使用reduction指令<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_critical</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>, sum = <span class="number">0</span>, sumLocal, i, tid;</span><br><span class="line">    <span class="keyword">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel shared(n, a, sum) private (tid, sumLocal)</span></span><br><span class="line">    &#123;</span><br><span class="line">        tid = omp_get_thread_num();</span><br><span class="line">        sumLocal = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sumLocal += a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp critical(update_sum) </span></span><br><span class="line">        &#123;</span><br><span class="line">            sum += sumLocal;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Thread %d: sumLocal = %d sum =%d\n"</span>, tid, sumLocal, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Value of sum after parallel region: %d\n"</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在该代码中, sum是全局的, localSum是每个线程执行完各自的求和任务后的和值, 将每个线程的sumLocal加给sum, 就是最后的和值. 在执行<code>sum+=sunLocal</code>操作时, 需要保证一次只有一个线程执行该操作, 因此这里使用了临界区, 下面是运行结果:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread 2: sumLocal = 1550 sum =1550</span><br><span class="line">Thread 3: sumLocal = 2175 sum =3725</span><br><span class="line">Thread 1: sumLocal = 925 sum =4650</span><br><span class="line">Thread 0: sumLocal = 300 sum =4950</span><br><span class="line">Value of sum after parallel region: 4950</span><br></pre></td></tr></table></figure></p><p>下面是将临界区去掉的运行结果(运行结果不是固定的, 这里只是其中一种情况):<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread 2: sumLocal = 1550 sum =1550</span><br><span class="line">Thread 3: sumLocal = 2175 sum =2475</span><br><span class="line">Thread 1: sumLocal = 925 sum =925</span><br><span class="line">Thread 0: sumLocal = 300 sum =300</span><br><span class="line">Value of sum after parallel region: 2475</span><br></pre></td></tr></table></figure></p><p>通过对比我们可以看到临界区保证了程序的正确性.</p><h3 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h3><p>原子操作, 可以锁定一个特殊的<strong>存储单元(可以是一个单独的变量,也可以是数组元素)</strong>, 使得该<strong>存储单元</strong>只能原子的更新, 而不允许让多个线程同时去写. atomic只能作用于单条赋值语句, 而不能作用于代码块. 语法形式为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp atomic</span></span><br><span class="line">    statement</span><br></pre></td></tr></table></figure></p><p>在C/C++中, statement必须是下列形式之一</p><ul><li><code>x++, x--, ++x, --x</code></li><li><code>x binop= expr</code>  其中binop是二元操作符: <code>+, -, *, /,  &amp;, ^, |, &lt;&lt;, &gt;&gt;</code>之一</li></ul><p>atomic的可以有效的利用的硬件的原子操作机制来控制多个线程对共享变量的写操作, 效率较高, 下面是一个使用示例<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_atomic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> counter=<span class="number">0</span>, n = <span class="number">1000000</span>, i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for shared(counter, n)</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp atomic</span></span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"counter is %d\n"</span>, counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于下面的情况<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp atomic</span></span><br><span class="line">ic += func();</span><br></pre></td></tr></table></figure></p><p>atomic只保证ic的更新是原子的, 即不会被多个线程同时更新, 但是不会保证func函数的执行是原子的, 即多个线程可以同时执行func函数, 如果要使func的执行也是原子的, 可以使用临界区.</p><h3 id="locks"><a href="#locks" class="headerlink" title="locks"></a>locks</h3><p>互斥锁, 提供了一个更底层的机制来处理同步的问题, 比使用critical和atomic有更多的灵活性, 但也相对更加复杂一些. openmp提供了两种类型的锁–简单锁(simple locks) 和 嵌套锁(nested locks), 对于简单锁来说, 如果其处于锁住的状态, 那么它就可能无法再次被上锁. 而对于嵌套锁来说, 可以被同一个线程上锁多次. 下面是简单锁的几个函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">omp_init_lock</span><span class="params">(<span class="keyword">omp_lock_t</span> *lck)</span>   <span class="comment">// 初始化互斥锁</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">omp_destroy_lock</span><span class="params">(<span class="keyword">omp_lock_t</span> *lck)</span>   <span class="comment">// 销毁互斥锁</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">omp_set_lock</span><span class="params">(<span class="keyword">omp_lock_t</span> *lck)</span>   <span class="comment">// 获得互斥锁</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">omp_unset_lock</span><span class="params">(<span class="keyword">omp_lock_t</span> *lck)</span>   <span class="comment">// 释放互斥锁</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">omp_test_lock</span><span class="params">(<span class="keyword">omp_lock_t</span> *lck)</span>   <span class="comment">// 尝试获得互斥锁, 如果获得成功返回true, 否则返回false</span></span></span><br></pre></td></tr></table></figure></p><p>嵌套锁的函数和简单锁略有不同, 如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">omp_init_nest_lock</span><span class="params">(<span class="keyword">omp_nest_lock_t</span> *lck)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">omp_destroy_nest_lock</span><span class="params">(<span class="keyword">omp_nest_lock_t</span> *lck)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">omp_set_nest_lock</span><span class="params">(<span class="keyword">omp_nest_lock_t</span> *lck)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">omp_unset_nest_lock</span><span class="params">(<span class="keyword">omp_nest_lock_t</span> *lck)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">omp_test_nest_lock</span><span class="params">(<span class="keyword">omp_nest_lock_t</span> *lck)</span></span></span><br></pre></td></tr></table></figure></p><p>下面是一个使用示例<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">omp_lock_t</span> lock;</span><br><span class="line">    <span class="keyword">int</span> i,n = <span class="number">4</span>;</span><br><span class="line">    omp_init_lock(&amp;lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        omp_set_lock(&amp;lock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Thread %d: +\n"</span>, omp_get_thread_num());</span><br><span class="line">        system(<span class="string">"sleep 0.1"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Thread %d: -\n"</span>, omp_get_thread_num());</span><br><span class="line">        omp_unset_lock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    omp_destroy_lock(&amp;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中system(“sleep 0.1”) 是为了两次的输出有个间隔, 以便和不加锁时的情况进行对比. 下面是程序的输出:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread 1: +</span><br><span class="line">Thread 1: -</span><br><span class="line">Thread 2: +</span><br><span class="line">Thread 2: -</span><br><span class="line">Thread 3: +</span><br><span class="line">Thread 3: -</span><br><span class="line">Thread 0: +</span><br><span class="line">Thread 0: -</span><br></pre></td></tr></table></figure></p><p>下面是去掉锁的输出<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread 3: +</span><br><span class="line">Thread 2: +</span><br><span class="line">Thread 0: +</span><br><span class="line">Thread 1: +</span><br><span class="line">Thread 2: -</span><br><span class="line">Thread 3: -</span><br><span class="line">Thread 0: -</span><br><span class="line">Thread 1: -</span><br></pre></td></tr></table></figure></p><h3 id="master"><a href="#master" class="headerlink" title="master"></a>master</h3><p>用于指定一段代码只由主线程执行. master指令和single指令的区别如下:</p><ul><li>master指令包含的代码段只有主线程执行, 而single指令包含的代码可以由任意一个线程执行.</li><li>master指令在结束处没有隐式同步, 也不可以使用nowait从句</li></ul><p>下面是一个使用示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_master</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, i, n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> b[n];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel shared(a, b) private(i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp master</span></span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Master construct is executed by thread %d\n"</span>, omp_get_thread_num());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp barrier</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            b[i] = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After the parallel region:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"b[%d] = %d\n"</span>, i, b[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是输出结果<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Master construct is executed by thread 0</span><br><span class="line">After the parallel region:</span><br><span class="line">b[0] = 10</span><br><span class="line">b[1] = 10</span><br><span class="line">b[2] = 10</span><br><span class="line">b[3] = 10</span><br><span class="line">b[4] = 10</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;OpenMP通过在串行程序中插入编译制导指令, 来实现并行化, 支持OpenMP的编译器可以识别, 处理这些指令并实现对应的功能. 所有的编译制导指令都是以&lt;code&gt;#pragma omp&lt;/code&gt;开始, 后面跟具体的功能指令(directive)或者命令.  一般格式如下所示:&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;pragma&lt;/span&gt; omp directive [clause [[,] clause]...]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    structured block&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OpenMP" scheme="http://blog.zhangjikai.com/categories/OpenMP/"/>
    
    
      <category term="学习笔记" scheme="http://blog.zhangjikai.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OpenMP" scheme="http://blog.zhangjikai.com/tags/OpenMP/"/>
    
  </entry>
  
</feed>
